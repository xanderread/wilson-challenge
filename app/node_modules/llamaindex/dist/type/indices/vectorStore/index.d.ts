import { type BaseEmbedding } from "@llamaindex/core/embeddings";
import type { MessageContent } from "@llamaindex/core/llms";
import type { BaseNodePostprocessor } from "@llamaindex/core/postprocessor";
import type { QueryBundle } from "@llamaindex/core/query-engine";
import type { BaseSynthesizer } from "@llamaindex/core/response-synthesizers";
import { BaseRetriever } from "@llamaindex/core/retriever";
import { ModalityType, type BaseNode, type Document, type NodeWithScore } from "@llamaindex/core/schema";
import type { ServiceContext } from "../../ServiceContext.js";
import { RetrieverQueryEngine } from "../../engines/query/RetrieverQueryEngine.js";
import { DocStoreStrategy } from "../../ingestion/strategies/index.js";
import type { StorageContext } from "../../storage/StorageContext.js";
import type { BaseIndexStore } from "../../storage/indexStore/types.js";
import type { BaseVectorStore, MetadataFilters, VectorStoreByType, VectorStoreQueryResult } from "../../vector-store/index.js";
import type { BaseIndexInit } from "../BaseIndex.js";
import { BaseIndex } from "../BaseIndex.js";
import { IndexDict } from "../json-to-index-struct.js";
interface IndexStructOptions {
    indexStruct?: IndexDict | undefined;
    indexId?: string | undefined;
}
export interface VectorIndexOptions extends IndexStructOptions {
    nodes?: BaseNode[] | undefined;
    serviceContext?: ServiceContext | undefined;
    storageContext?: StorageContext | undefined;
    vectorStores?: VectorStoreByType | undefined;
    logProgress?: boolean | undefined;
}
export interface VectorIndexConstructorProps extends BaseIndexInit<IndexDict> {
    indexStore: BaseIndexStore;
    vectorStores?: VectorStoreByType | undefined;
}
/**
 * The VectorStoreIndex, an index that stores the nodes only according to their vector embeddings.
 */
export declare class VectorStoreIndex extends BaseIndex<IndexDict> {
    indexStore: BaseIndexStore;
    embedModel?: BaseEmbedding | undefined;
    vectorStores: VectorStoreByType;
    private constructor();
    /**
     * The async init function creates a new VectorStoreIndex.
     * @param options
     * @returns
     */
    static init(options: VectorIndexOptions): Promise<VectorStoreIndex>;
    private static setupIndexStructFromStorage;
    /**
     * Calculates the embeddings for the given nodes.
     *
     * @param nodes - An array of BaseNode objects representing the nodes for which embeddings are to be calculated.
     * @param {Object} [options] - An optional object containing additional parameters.
     *   @param {boolean} [options.logProgress] - A boolean indicating whether to log progress to the console (useful for debugging).
     */
    getNodeEmbeddingResults(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<BaseNode[]>;
    /**
     * Get embeddings for nodes and place them into the index.
     * @param nodes
     * @returns
     */
    buildIndexFromNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<void>;
    /**
     * High level API: split documents, get embeddings, and build index.
     * @param documents
     * @param args
     * @returns
     */
    static fromDocuments(documents: Document[], args?: VectorIndexOptions & {
        docStoreStrategy?: DocStoreStrategy;
    }): Promise<VectorStoreIndex>;
    static fromVectorStores(vectorStores: VectorStoreByType, serviceContext?: ServiceContext): Promise<VectorStoreIndex>;
    static fromVectorStore(vectorStore: BaseVectorStore, serviceContext?: ServiceContext): Promise<VectorStoreIndex>;
    asRetriever(options?: OmitIndex<VectorIndexRetrieverOptions>): VectorIndexRetriever;
    /**
     * Create a RetrieverQueryEngine.
     * similarityTopK is only used if no existing retriever is provided.
     */
    asQueryEngine(options?: {
        retriever?: BaseRetriever;
        responseSynthesizer?: BaseSynthesizer;
        preFilters?: MetadataFilters;
        nodePostprocessors?: BaseNodePostprocessor[];
        similarityTopK?: number;
    }): RetrieverQueryEngine;
    protected insertNodesToStore(newIds: string[], nodes: BaseNode[], vectorStore: BaseVectorStore): Promise<void>;
    insertNodes(nodes: BaseNode[], options?: {
        logProgress?: boolean | undefined;
    }): Promise<void>;
    deleteRefDoc(refDocId: string, deleteFromDocStore?: boolean): Promise<void>;
    protected deleteRefDocFromStore(vectorStore: BaseVectorStore, refDocId: string): Promise<void>;
}
/**
 * VectorIndexRetriever retrieves nodes from a VectorIndex.
 */
type TopKMap = {
    [P in ModalityType]: number;
};
type OmitIndex<T> = T extends {
    index: any;
} ? Omit<T, "index"> : never;
export type VectorIndexRetrieverOptions = {
    index: VectorStoreIndex;
    filters?: MetadataFilters | undefined;
} & ({
    topK?: TopKMap | undefined;
} | {
    similarityTopK?: number | undefined;
});
export declare class VectorIndexRetriever extends BaseRetriever {
    index: VectorStoreIndex;
    topK: TopKMap;
    serviceContext?: ServiceContext | undefined;
    filters?: MetadataFilters | undefined;
    constructor(options: VectorIndexRetrieverOptions);
    /**
     * @deprecated, pass similarityTopK or topK in constructor instead or directly modify topK
     */
    set similarityTopK(similarityTopK: number);
    _retrieve(params: QueryBundle): Promise<NodeWithScore[]>;
    protected retrieveQuery(query: MessageContent, type: ModalityType, vectorStore: BaseVectorStore, filters?: MetadataFilters): Promise<NodeWithScore[]>;
    protected buildNodeListFromQueryResult(result: VectorStoreQueryResult): NodeWithScore<import("@llamaindex/core/schema").Metadata>[];
}
export {};
