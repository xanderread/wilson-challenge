import { BaseVectorStore, type MetadataFilter, type MetadataFilters, type VectorStoreBaseParams, type VectorStoreQuery, type VectorStoreQueryResult } from "./types.js";
import type { BaseNode, Metadata, TextNode } from "@llamaindex/core/schema";
import { Index } from "@upstash/vector";
type UpstashParams = {
    namespace?: string;
    token?: string;
    endpoint?: string;
    maxBatchSize?: number;
} & VectorStoreBaseParams;
/**
 * Provides support for writing and querying vector data in Upstash.
 */
export declare class UpstashVectorStore extends BaseVectorStore {
    storesText: boolean;
    private db;
    private maxBatchSize;
    namespace: string;
    /**
     * @param namespace namespace to use
     * @param token upstash vector token. if not set, `process.env.UPSTASH_VECTOR_REST_TOKEN` is used.
     * @param endpoint upstash vector endpoint. If not set, `process.env.UPSTASH_VECTOR_REST_URL` is used.
     * @param maxBatchSize maximum number of vectors upserted at once. Default is 1000.
     *
     * @example
     * ```ts
     * const vectorStore = new UpstashVectorStore({ namespace: "my-namespace" })
     * ```
     */
    constructor(params?: UpstashParams);
    private getDb;
    /**
     * Connects to the database specified in environment vars.
     * @returns A connection to the database, or the error encountered while connecting/setting up.
     */
    client(): Promise<Index>;
    /**
     * Adds vector record(s) to the table.
     * @param embeddingResults The Nodes to be inserted, optionally including metadata tuples.
     * @returns ids of the embeddings (infered from the id_ field of embeddingResults objects)
     */
    add(embeddingResults: BaseNode<Metadata>[]): Promise<string[]>;
    /**
     * Adds plain text record(s) to the table. Upstash take cares of embedding conversion.
     * @param text The Nodes to be inserted, optionally including metadata tuples.
     * @returns ids of the embeddings (infered from the id_ field of embeddingResults objects)
     */
    addPlainText(text: TextNode<Metadata>[]): Promise<string[]>;
    private upsertInBatches;
    /**
     * Deletes a single record from the database by id.
     * NOTE: Uses the collection property controlled by setCollection/getCollection.
     * @param refDocId Unique identifier for the record to delete.
     * @returns Promise that resolves if the delete query did not throw an error.
     */
    delete(refDocId: string): Promise<void>;
    /**
     * Deletes a single record from the database by id.
     * NOTE: Uses the collection property controlled by setCollection/getCollection.
     * @param refDocId Unique identifier for the record to delete.
     * @param deleteKwargs Required by VectorStore interface.  Currently ignored.
     * @returns Promise that resolves if the delete query did not throw an error.
     */
    deleteMany(refDocId: string[]): Promise<void>;
    /**
     * Query the vector store for the closest matching data to the query embeddings
     * @param query The VectorStoreQuery to be used
     * @param options Required by VectorStore interface.  Currently ignored.
     * @returns Zero or more Document instances with data from the vector store.
     */
    query(query: VectorStoreQuery, _options?: any): Promise<VectorStoreQueryResult>;
    toFilterString(filter: MetadataFilter): string;
    toUpstashFilter(stdFilters?: MetadataFilters): string | undefined;
    nodeToRecord(node: BaseNode<Metadata>): {
        id: any;
        vector: number[];
        metadata: Metadata;
    };
    textNodeToRecord(node: TextNode<Metadata>): {
        id: any;
        data: string;
        metadata: Metadata;
    };
}
export {};
