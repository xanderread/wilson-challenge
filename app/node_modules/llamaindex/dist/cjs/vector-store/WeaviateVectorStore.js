"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "WeaviateVectorStore", {
    enumerable: true,
    get: function() {
        return WeaviateVectorStore;
    }
});
const _schema = require("@llamaindex/core/schema");
const _weaviateclient = /*#__PURE__*/ _interop_require_wildcard(require("weaviate-client"));
const _env = require("@llamaindex/env");
const _types = require("./types.js");
const _utils = require("./utils.js");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const NODE_SCHEMA = [
    {
        dataType: [
            "text"
        ],
        description: "Text property",
        name: "text"
    },
    {
        dataType: [
            "text"
        ],
        description: "The ref_doc_id of the Node",
        name: "ref_doc_id"
    },
    {
        dataType: [
            "text"
        ],
        description: "node_info (in JSON)",
        name: "node_info"
    },
    {
        dataType: [
            "text"
        ],
        description: "The relationships of the node (in JSON)",
        name: "relationships"
    }
];
const SIMILARITY_KEYS = {
    [_types.VectorStoreQueryMode.DEFAULT]: "distance",
    [_types.VectorStoreQueryMode.HYBRID]: "score"
};
const buildFilterItem = (collection, filter)=>{
    const { key, operator, value } = filter;
    switch(operator){
        case "==":
            {
                return collection.filter.byProperty(key).equal(value);
            }
        case "!=":
            {
                return collection.filter.byProperty(key).notEqual(value);
            }
        case ">":
            {
                return collection.filter.byProperty(key).greaterThan((0, _utils.parseNumberValue)(value));
            }
        case "<":
            {
                return collection.filter.byProperty(key).lessThan((0, _utils.parseNumberValue)(value));
            }
        case ">=":
            {
                return collection.filter.byProperty(key).greaterOrEqual((0, _utils.parseNumberValue)(value));
            }
        case "<=":
            {
                return collection.filter.byProperty(key).lessOrEqual((0, _utils.parseNumberValue)(value));
            }
        case "any":
            {
                return collection.filter.byProperty(key).containsAny((0, _utils.parseArrayValue)(value).map(String));
            }
        case "all":
            {
                return collection.filter.byProperty(key).containsAll((0, _utils.parseArrayValue)(value).map(String));
            }
        default:
            {
                throw new Error(`Operator ${operator} is not supported.`);
            }
    }
};
const toWeaviateFilter = (collection, standardFilters)=>{
    if (!standardFilters?.filters.length) return undefined;
    const filtersList = standardFilters.filters.map((filter)=>buildFilterItem(collection, filter));
    if (filtersList.length === 1) return filtersList[0];
    const condition = standardFilters.condition ?? "and";
    return _weaviateclient.Filters[condition](...filtersList);
};
class WeaviateVectorStore extends _types.BaseVectorStore {
    storesText = true;
    flatMetadata = true;
    weaviateClient;
    clusterURL;
    apiKey;
    indexName;
    idKey;
    contentKey;
    embeddingKey;
    metadataKey;
    constructor(init){
        super(init);
        if (init?.weaviateClient) {
            // Use the provided client
            this.weaviateClient = init.weaviateClient;
        } else {
            // Load client cloud options from config or env
            const clusterURL = init?.cloudOptions?.clusterURL ?? (0, _env.getEnv)("WEAVIATE_CLUSTER_URL");
            const apiKey = init?.cloudOptions?.apiKey ?? (0, _env.getEnv)("WEAVIATE_API_KEY");
            if (!clusterURL || !apiKey) {
                throw new Error("Must specify WEAVIATE_CLUSTER_URL and WEAVIATE_API_KEY via env variable.");
            }
            this.clusterURL = clusterURL;
            this.apiKey = apiKey;
        }
        this.checkIndexName(init?.indexName);
        this.indexName = init?.indexName ?? "LlamaIndex";
        this.idKey = init?.idKey ?? "id";
        this.contentKey = init?.contentKey ?? "text";
        this.embeddingKey = init?.embeddingKey ?? "vectors";
        this.metadataKey = init?.metadataKey ?? "node_info";
    }
    client() {
        return this.getClient();
    }
    async add(nodes) {
        const collection = await this.ensureCollection({
            createIfNotExists: true
        });
        const result = await collection.data.insertMany(nodes.map((node)=>{
            const metadata = (0, _utils.nodeToMetadata)(node, true, this.contentKey, this.flatMetadata);
            const body = {
                [this.idKey]: node.id_,
                [this.embeddingKey]: node.getEmbedding(),
                properties: {
                    ...metadata,
                    [this.contentKey]: node.getContent(_schema.MetadataMode.NONE),
                    [this.metadataKey]: JSON.stringify(metadata),
                    relationships: JSON.stringify({
                        ref_doc_id: metadata.ref_doc_id
                    })
                }
            };
            return body;
        }));
        return Object.values(result.uuids);
    }
    async delete(refDocId, deleteOptions) {
        const collection = await this.ensureCollection();
        await collection.data.deleteMany(collection.filter.byProperty("ref_doc_id").like(refDocId), deleteOptions);
    }
    async query(query) {
        const collection = await this.ensureCollection();
        const allProperties = await this.getAllProperties();
        let filters = undefined;
        if (query.docIds) {
            filters = collection.filter.byProperty("doc_id").containsAny(query.docIds);
        }
        if (query.filters) {
            filters = toWeaviateFilter(collection, query.filters);
        }
        const hybridOptions = {
            returnMetadata: Object.values(SIMILARITY_KEYS),
            returnProperties: allProperties,
            includeVector: true
        };
        const alpha = this.getQueryAlpha(query);
        if (query.queryEmbedding) {
            hybridOptions.vector = query.queryEmbedding;
        }
        if (query.similarityTopK) {
            hybridOptions.limit = query.similarityTopK;
        }
        if (alpha) {
            hybridOptions.alpha = alpha;
        }
        if (filters) {
            hybridOptions.filters = filters;
        }
        const queryResult = await collection.query.hybrid(query.queryStr, hybridOptions);
        const entries = queryResult.objects;
        const similarityKey = SIMILARITY_KEYS[query.mode];
        const nodes = [];
        const similarities = [];
        const ids = [];
        entries.forEach((entry, index)=>{
            if (index < query.similarityTopK && entry.metadata) {
                const node = (0, _utils.metadataDictToNode)(entry.properties);
                node.setContent(entry.properties[this.contentKey]);
                nodes.push(node);
                ids.push(entry.uuid);
                similarities.push(this.getNodeSimilarity(entry, similarityKey));
            }
        });
        return {
            nodes,
            similarities,
            ids
        };
    }
    async getClient() {
        if (this.weaviateClient) return this.weaviateClient;
        const client = await _weaviateclient.default.connectToWeaviateCloud(this.clusterURL, {
            authCredentials: new _weaviateclient.default.ApiKey(this.apiKey)
        });
        this.weaviateClient = client;
        return client;
    }
    async ensureCollection({ createIfNotExists = false } = {}) {
        const client = await this.getClient();
        const exists = await this.doesCollectionExist();
        if (!exists) {
            if (createIfNotExists) {
                await this.createCollection();
            } else {
                throw new Error(`Collection ${this.indexName} does not exist.`);
            }
        }
        return client.collections.get(this.indexName);
    }
    async doesCollectionExist() {
        const client = await this.getClient();
        return client.collections.exists(this.indexName);
    }
    async createCollection() {
        const client = await this.getClient();
        return await client.collections.createFromSchema({
            class: this.indexName,
            description: `Collection for ${this.indexName}`,
            properties: NODE_SCHEMA
        });
    }
    getQueryAlpha(query) {
        if (!query.queryEmbedding) return undefined;
        if (query.mode === _types.VectorStoreQueryMode.DEFAULT) return 1;
        if (query.mode === _types.VectorStoreQueryMode.HYBRID && query.queryStr) return query.alpha;
        return undefined;
    }
    async getAllProperties() {
        const collection = await this.ensureCollection();
        const properties = (await collection.config.get()).properties;
        return properties.map((p)=>p.name);
    }
    checkIndexName(indexName) {
        if (indexName && indexName[0] !== indexName[0].toUpperCase()) {
            throw new Error("Index name must start with a capital letter, e.g. 'LlamaIndex'");
        }
    }
    getNodeSimilarity(entry, similarityKey = "distance") {
        const distance = entry.metadata?.[similarityKey];
        if (distance === undefined) return 1;
        // convert distance https://forum.weaviate.io/t/distance-vs-certainty-scores/258
        return 1 - distance;
    }
}
