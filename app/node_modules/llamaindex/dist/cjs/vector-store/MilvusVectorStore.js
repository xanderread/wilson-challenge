"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MilvusVectorStore", {
    enumerable: true,
    get: function() {
        return MilvusVectorStore;
    }
});
const _schema = require("@llamaindex/core/schema");
const _env = require("@llamaindex/env");
const _milvus2sdknode = require("@zilliz/milvus2-sdk-node");
const _types = require("./types.js");
const _utils = require("./utils.js");
function parseScalarFilters(scalarFilters) {
    const condition = scalarFilters.condition ?? "and";
    const filters = [];
    for (const filter of scalarFilters.filters){
        switch(filter.operator){
            case "==":
            case "!=":
                {
                    filters.push(`metadata["${filter.key}"] ${filter.operator} "${(0, _utils.parsePrimitiveValue)(filter.value)}"`);
                    break;
                }
            case "in":
                {
                    const filterValue = (0, _utils.parseArrayValue)(filter.value).map((v)=>`"${v}"`).join(", ");
                    filters.push(`metadata["${filter.key}"] ${filter.operator} [${filterValue}]`);
                    break;
                }
            case "nin":
                {
                    // Milvus does not support `nin` operator, so we need to manually check every value
                    // Expected: not metadata["key"] != "value1" and not metadata["key"] != "value2"
                    const filterStr = (0, _utils.parseArrayValue)(filter.value).map((v)=>`metadata["${filter.key}"] != "${v}"`).join(" && ");
                    filters.push(filterStr);
                    break;
                }
            case "<":
            case "<=":
            case ">":
            case ">=":
                {
                    filters.push(`metadata["${filter.key}"] ${filter.operator} ${(0, _utils.parsePrimitiveValue)(filter.value)}`);
                    break;
                }
            default:
                throw new Error(`Operator ${filter.operator} is not supported.`);
        }
    }
    return filters.join(` ${condition} `);
}
class MilvusVectorStore extends _types.BaseVectorStore {
    storesText = true;
    isEmbeddingQuery = false;
    flatMetadata = true;
    milvusClient;
    collectionInitialized = false;
    collectionName;
    idKey;
    contentKey;
    metadataKey;
    embeddingKey;
    constructor(init){
        super(init);
        if (init?.milvusClient) {
            this.milvusClient = init.milvusClient;
        } else {
            const configOrAddress = init?.params?.configOrAddress ?? (0, _env.getEnv)("MILVUS_ADDRESS");
            const ssl = init?.params?.ssl ?? (0, _env.getEnv)("MILVUS_SSL") === "true";
            const username = init?.params?.username ?? (0, _env.getEnv)("MILVUS_USERNAME");
            const password = init?.params?.password ?? (0, _env.getEnv)("MILVUS_PASSWORD");
            if (!configOrAddress) {
                throw new Error("Must specify MILVUS_ADDRESS via env variable.");
            }
            this.milvusClient = new _milvus2sdknode.MilvusClient(configOrAddress, ssl, username, password, init?.params?.channelOptions);
        }
        this.collectionName = init?.collection ?? "llamacollection";
        this.idKey = init?.idKey ?? "id";
        this.contentKey = init?.contentKey ?? "content";
        this.metadataKey = init?.metadataKey ?? "metadata";
        this.embeddingKey = init?.embeddingKey ?? "embedding";
    }
    client() {
        return this.milvusClient;
    }
    async createCollection() {
        await this.milvusClient.createCollection({
            collection_name: this.collectionName,
            fields: [
                {
                    name: this.idKey,
                    data_type: _milvus2sdknode.DataType.VarChar,
                    is_primary_key: true,
                    max_length: 200
                },
                {
                    name: this.embeddingKey,
                    data_type: _milvus2sdknode.DataType.FloatVector,
                    dim: 1536
                },
                {
                    name: this.contentKey,
                    data_type: _milvus2sdknode.DataType.VarChar,
                    max_length: 9000
                },
                {
                    name: this.metadataKey,
                    data_type: _milvus2sdknode.DataType.JSON
                }
            ]
        });
        await this.milvusClient.createIndex({
            collection_name: this.collectionName,
            field_name: this.embeddingKey
        });
    }
    async ensureCollection() {
        if (!this.collectionInitialized) {
            await this.milvusClient.connectPromise;
            // Check collection exists
            const isCollectionExist = await this.milvusClient.hasCollection({
                collection_name: this.collectionName
            });
            if (!isCollectionExist.value) {
                await this.createCollection();
            }
            await this.milvusClient.loadCollectionSync({
                collection_name: this.collectionName
            });
            this.collectionInitialized = true;
        }
    }
    async add(nodes) {
        await this.ensureCollection();
        const result = await this.milvusClient.insert({
            collection_name: this.collectionName,
            data: nodes.map((node)=>{
                const metadata = (0, _utils.nodeToMetadata)(node, true, this.contentKey, this.flatMetadata);
                const entry = {
                    [this.idKey]: node.id_,
                    [this.embeddingKey]: node.getEmbedding(),
                    [this.contentKey]: node.getContent(_schema.MetadataMode.NONE),
                    [this.metadataKey]: metadata
                };
                return entry;
            })
        });
        if (!result.IDs) {
            return [];
        }
        if ("int_id" in result.IDs) {
            return result.IDs.int_id.data.map((i)=>String(i));
        }
        return result.IDs.str_id.data.map((s)=>String(s));
    }
    async delete(refDocId, deleteOptions) {
        await this.ensureCollection();
        await this.milvusClient.delete({
            ids: [
                refDocId
            ],
            collection_name: this.collectionName,
            ...deleteOptions
        });
    }
    toMilvusFilter(filters) {
        if (!filters) return undefined;
        // TODO: Milvus also support standard filters, we can add it later
        return parseScalarFilters(filters);
    }
    async query(query, _options) {
        await this.ensureCollection();
        const found = await this.milvusClient.search({
            collection_name: this.collectionName,
            limit: query.similarityTopK,
            vector: query.queryEmbedding,
            filter: this.toMilvusFilter(query.filters)
        });
        const nodes = [];
        const similarities = [];
        const ids = [];
        found.results.forEach((result)=>{
            const node = (0, _utils.metadataDictToNode)(result.metadata);
            node.setContent(result.content);
            nodes.push(node);
            similarities.push(result.score);
            ids.push(String(result.id));
        });
        return {
            nodes,
            similarities,
            ids
        };
    }
    async persist() {
    // no need to do anything
    }
}
