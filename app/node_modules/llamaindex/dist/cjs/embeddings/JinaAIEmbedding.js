"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "JinaAIEmbedding", {
    enumerable: true,
    get: function() {
        return JinaAIEmbedding;
    }
});
const _embeddings = require("@llamaindex/core/embeddings");
const _env = require("@llamaindex/env");
const _utils = require("../internal/utils.js");
function isLocal(url) {
    if (url instanceof Blob) return true;
    return new URL(url).protocol === "file:";
}
const JINA_MULTIMODAL_MODELS = [
    "jina-clip-v1"
];
class JinaAIEmbedding extends _embeddings.MultiModalEmbedding {
    apiKey;
    model;
    baseURL;
    task;
    encodingType;
    dimensions;
    late_chunking;
    async getTextEmbedding(text) {
        const result = await this.getJinaEmbedding({
            input: [
                {
                    text
                }
            ]
        });
        return result.data[0].embedding;
    }
    async getImageEmbedding(image) {
        const img = await this.getImageInput(image);
        const result = await this.getJinaEmbedding({
            input: [
                img
            ]
        });
        return result.data[0].embedding;
    }
    // Retrieve multiple text embeddings in a single request
    getTextEmbeddings = async (texts)=>{
        const input = texts.map((text)=>({
                text
            }));
        const result = await this.getJinaEmbedding({
            input
        });
        return result.data.map((d)=>d.embedding);
    };
    // Retrieve multiple image embeddings in a single request
    async getImageEmbeddings(images) {
        const input = await Promise.all(images.map((img)=>this.getImageInput(img)));
        const result = await this.getJinaEmbedding({
            input
        });
        return result.data.map((d)=>d.embedding);
    }
    constructor(init){
        super();
        const apiKey = init?.apiKey ?? (0, _env.getEnv)("JINAAI_API_KEY");
        if (!apiKey) {
            throw new Error("Set Jina AI API Key in JINAAI_API_KEY env variable. Get one for free or top up your key at https://jina.ai/embeddings");
        }
        this.apiKey = apiKey;
        this.model = init?.model ?? "jina-embeddings-v3";
        this.baseURL = init?.baseURL ?? "https://api.jina.ai/v1/embeddings";
        init?.embedBatchSize && (this.embedBatchSize = init?.embedBatchSize);
        this.task = init?.task;
        this.encodingType = init?.encodingType;
        this.dimensions = init?.dimensions;
        this.late_chunking = init?.late_chunking;
    }
    async getImageInput(image) {
        if (isLocal(image) || image instanceof Blob) {
            const base64 = await (0, _utils.imageToDataUrl)(image);
            const bytes = base64.split(",")[1];
            return {
                bytes
            };
        } else {
            return {
                url: image.toString()
            };
        }
    }
    async getJinaEmbedding(params) {
        // if input includes image, check if model supports multimodal embeddings
        if (params.input.some((i)=>"url" in i || "bytes" in i) && !JINA_MULTIMODAL_MODELS.includes(this.model)) {
            throw new Error(`Model ${this.model} does not support image embeddings. Use ${JINA_MULTIMODAL_MODELS.join(", ")}`);
        }
        const response = await fetch(this.baseURL, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
                model: this.model,
                encoding_type: this.encodingType ?? "float",
                ...this.task && {
                    task: this.task
                },
                ...this.dimensions !== undefined && {
                    dimensions: this.dimensions
                },
                ...this.late_chunking !== undefined && {
                    late_chunking: this.late_chunking
                },
                ...params
            })
        });
        if (!response.ok) {
            const reason = await response.text();
            throw new Error(`Request failed with status ${response.status}: ${reason}`);
        }
        const result = await response.json();
        return {
            ...result,
            data: result.data.sort((a, b)=>a.index - b.index)
        };
    }
}
