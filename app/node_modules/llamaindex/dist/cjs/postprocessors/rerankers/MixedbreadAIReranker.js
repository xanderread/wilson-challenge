"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MixedbreadAIReranker", {
    enumerable: true,
    get: function() {
        return MixedbreadAIReranker;
    }
});
const _env = require("@llamaindex/env");
const _sdk = require("@mixedbread-ai/sdk");
const _schema = require("@llamaindex/core/schema");
const _utils = require("@llamaindex/core/utils");
class MixedbreadAIReranker {
    requestParams;
    requestOptions;
    client;
    /**
   * Constructor for MixedbreadRerank.
   * @param {Partial<MixedbreadAIRerankerParams>} params - An optional object with properties to configure the instance.
   * @throws {Error} If the API key is not provided or found in the environment variables.
   */ constructor(params){
        const apiKey = params?.apiKey ?? (0, _env.getEnv)("MXBAI_API_KEY");
        if (!apiKey) {
            throw new Error("MixedbreadAI API key not found. Either provide it in the constructor or set the 'MXBAI_API_KEY' environment variable.");
        }
        this.requestOptions = {
            maxRetries: params?.maxRetries ?? 3,
            timeoutInSeconds: params?.timeoutInSeconds,
            // Support for this already exists in the python sdk and will be added to the js sdk soon
            // @ts-ignore
            additionalHeaders: {
                "user-agent": "@mixedbread-ai/llamaindex-ts-sdk"
            }
        };
        this.client = new _sdk.MixedbreadAIClient(params?.baseUrl ? {
            apiKey,
            environment: params?.baseUrl
        } : {
            apiKey
        });
        this.requestParams = {
            model: params?.model ?? "default",
            returnInput: params?.returnInput ?? false
        };
        if (params?.topK) {
            this.requestParams.topK = params.topK;
        }
        if (params?.rankFields) {
            this.requestParams.rankFields = params.rankFields;
        }
    }
    /**
   * Reranks the nodes using the mixedbread.ai API.
   * @param {NodeWithScore[]} nodes - Array of nodes with scores.
   * @param {MessageContent} [query] - Query string.
   * @throws {Error} If query is undefined.
   *
   * @returns {Promise<NodeWithScore[]>} A Promise that resolves to an ordered list of nodes with relevance scores.
   *
   * @example
   * const nodes = [{ node: new BaseNode('To bake bread you need flour') }, { node: new BaseNode('To bake bread you need yeast') }];
   * const query = "What do you need to bake bread?";
   * const result = await reranker.postprocessNodes(nodes, query);
   * console.log(result);
   */ async postprocessNodes(nodes, query) {
        if (query === undefined) {
            throw new Error("MixedbreadAIReranker requires a query");
        }
        if (nodes.length === 0) {
            return [];
        }
        const input = nodes.map((n)=>n.node.getContent(_schema.MetadataMode.ALL));
        const result = await this.client.reranking({
            query: (0, _utils.extractText)(query),
            input,
            ...this.requestParams
        }, this.requestOptions);
        const newNodes = [];
        for (const document of result.data){
            const node = nodes[document.index];
            node.score = document.score;
            newNodes.push(node);
        }
        return newNodes;
    }
    /**
   * Returns an ordered list of documents sorted by their relevance to the provided query.
   * @param {(Array<string> | Array<BaseNode> | Array<Record<string, unknown>>)} nodes - A list of documents as strings, DocumentInterfaces, or objects with a `pageContent` key.
   * @param {string} query - The query to use for reranking the documents.
   * @param {RerankingRequestWithoutInput} [options] - Optional parameters for reranking.
   *
   * @returns {Promise<Array<MixedbreadAI.RankedDocument>>} A Promise that resolves to an ordered list of documents with relevance scores.
   *
   * @example
   * const nodes = ["To bake bread you need flour", "To bake bread you need yeast"];
   * const query = "What do you need to bake bread?";
   * const result = await reranker.rerank(nodes, query);
   * console.log(result);
   */ async rerank(nodes, query, options) {
        if (nodes.length === 0) {
            return [];
        }
        const input = typeof nodes[0] === "object" && "node" in nodes[0] ? nodes.map((n)=>n.getContent(_schema.MetadataMode.ALL)) : nodes;
        const result = await this.client.reranking({
            query,
            input,
            ...this.requestParams,
            ...options
        }, this.requestOptions);
        return result.data;
    }
}
