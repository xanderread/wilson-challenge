import { MetadataMode } from "@llamaindex/core/schema";
import { ChromaClient } from "chromadb";
import { BaseVectorStore, FilterCondition, FilterOperator, VectorStoreQueryMode } from "./types.js";
import { metadataDictToNode, nodeToMetadata } from "./utils.js";
const DEFAULT_TEXT_KEY = "text";
export class ChromaVectorStore extends BaseVectorStore {
    storesText = true;
    flatMetadata = true;
    textKey;
    chromaClient;
    collection = null;
    collectionName;
    constructor(init){
        super(init);
        this.collectionName = init.collectionName;
        this.chromaClient = new ChromaClient(init.chromaClientParams);
        this.textKey = init.textKey ?? DEFAULT_TEXT_KEY;
    }
    client() {
        return this.chromaClient;
    }
    async getCollection() {
        if (!this.collection) {
            const coll = await this.chromaClient.getOrCreateCollection({
                name: this.collectionName
            });
            this.collection = coll;
        }
        return this.collection;
    }
    getDataToInsert(nodes) {
        const metadatas = nodes.map((node)=>nodeToMetadata(node, true, this.textKey, this.flatMetadata));
        return {
            embeddings: nodes.map((node)=>node.getEmbedding()),
            ids: nodes.map((node)=>node.id_),
            metadatas,
            documents: nodes.map((node)=>node.getContent(MetadataMode.NONE))
        };
    }
    async add(nodes) {
        if (!nodes || nodes.length === 0) {
            return [];
        }
        const dataToInsert = this.getDataToInsert(nodes);
        const collection = await this.getCollection();
        await collection.add(dataToInsert);
        return nodes.map((node)=>node.id_);
    }
    async delete(refDocId, deleteOptions) {
        const collection = await this.getCollection();
        await collection.delete({
            ids: [
                refDocId
            ],
            where: deleteOptions?.where,
            whereDocument: deleteOptions?.whereDocument
        });
    }
    transformChromaFilterCondition(condition) {
        switch(condition){
            case FilterCondition.AND:
                return "$and";
            case FilterCondition.OR:
                return "$or";
            default:
                throw new Error(`Filter condition ${condition} not supported`);
        }
    }
    transformChromaFilterOperator(operator) {
        switch(operator){
            case FilterOperator.EQ:
                return "$eq";
            case FilterOperator.NE:
                return "$ne";
            case FilterOperator.GT:
                return "$gt";
            case FilterOperator.LT:
                return "$lt";
            case FilterOperator.GTE:
                return "$gte";
            case FilterOperator.LTE:
                return "$lte";
            case FilterOperator.IN:
                return "$in";
            case FilterOperator.NIN:
                return "$nin";
            default:
                throw new Error(`Filter operator ${operator} not supported`);
        }
    }
    toChromaFilter(filters) {
        const chromaFilter = {};
        const filtersList = [];
        const condition = filters.condition ? this.transformChromaFilterCondition(filters.condition) : "$and";
        if (filters.filters) {
            for (const filter of filters.filters){
                if (filter.operator) {
                    filtersList.push({
                        [filter.key]: {
                            [this.transformChromaFilterOperator(filter.operator)]: filter.value
                        }
                    });
                } else {
                    filtersList.push({
                        [filter.key]: filter.value
                    });
                }
            }
            if (filtersList.length === 1) {
                return filtersList[0];
            } else if (filtersList.length > 1) {
                chromaFilter[condition] = filtersList;
            }
        }
        return chromaFilter;
    }
    async query(query, options) {
        if (query.docIds) {
            throw new Error("ChromaDB does not support querying by docIDs");
        }
        if (query.mode != VectorStoreQueryMode.DEFAULT) {
            throw new Error("ChromaDB does not support querying by mode");
        }
        let chromaWhere = {};
        if (query.filters) {
            chromaWhere = this.toChromaFilter(query.filters);
        }
        const collection = await this.getCollection();
        const queryResponse = await collection.query({
            queryEmbeddings: query.queryEmbedding ?? undefined,
            queryTexts: query.queryStr ?? undefined,
            nResults: query.similarityTopK,
            where: Object.keys(chromaWhere).length ? chromaWhere : undefined,
            whereDocument: options?.whereDocument,
            //ChromaDB doesn't return the result embeddings by default so we need to include them
            include: [
                "distances",
                "metadatas",
                "documents",
                "embeddings"
            ]
        });
        const vectorStoreQueryResult = {
            nodes: queryResponse.ids[0].map((id, index)=>{
                const text = queryResponse.documents[0][index];
                const metaData = queryResponse.metadatas[0][index] ?? {};
                const node = metadataDictToNode(metaData);
                node.setContent(text);
                return node;
            }),
            similarities: queryResponse.distances[0].map((distance)=>1 - distance),
            ids: queryResponse.ids[0]
        };
        return vectorStoreQueryResult;
    }
}
