import { ChatMessage, LLM } from '../../llms/dist/index.cjs';
import { BaseChatStore } from '../../storage/chat-store/dist/index.cjs';
import { Tokenizer } from '@llamaindex/env';
import { SummaryPrompt } from '../../prompts/dist/index.cjs';

/**
 * A ChatMemory is used to keep the state of back and forth chat messages
 */
declare abstract class BaseMemory<AdditionalMessageOptions extends object = object> {
    /**
     * Retrieves messages from the memory, optionally including transient messages.
     * Compared to getAllMessages, this method a) allows for transient messages to be included in the retrieval and b) may return a subset of the total messages by applying a token limit.
     * @param transientMessages Optional array of temporary messages to be included in the retrieval.
     * These messages are not stored in the memory but are considered for the current interaction.
     * @returns An array of chat messages, either synchronously or as a Promise.
     */
    abstract getMessages(transientMessages?: ChatMessage<AdditionalMessageOptions>[] | undefined): ChatMessage<AdditionalMessageOptions>[] | Promise<ChatMessage<AdditionalMessageOptions>[]>;
    /**
     * Retrieves all messages stored in the memory.
     * @returns An array of all chat messages, either synchronously or as a Promise.
     */
    abstract getAllMessages(): ChatMessage<AdditionalMessageOptions>[] | Promise<ChatMessage<AdditionalMessageOptions>[]>;
    /**
     * Adds a new message to the memory.
     * @param messages The chat message to be added to the memory.
     */
    abstract put(messages: ChatMessage<AdditionalMessageOptions>): void;
    /**
     * Clears all messages from the memory.
     */
    abstract reset(): void;
    protected _tokenCountForMessages(messages: ChatMessage[]): number;
}
declare abstract class BaseChatStoreMemory<AdditionalMessageOptions extends object = object> extends BaseMemory<AdditionalMessageOptions> {
    chatStore: BaseChatStore<AdditionalMessageOptions>;
    chatStoreKey: string;
    protected constructor(chatStore?: BaseChatStore<AdditionalMessageOptions>, chatStoreKey?: string);
    getAllMessages(): ChatMessage<AdditionalMessageOptions>[];
    put(messages: ChatMessage<AdditionalMessageOptions>): void;
    set(messages: ChatMessage<AdditionalMessageOptions>[]): void;
    reset(): void;
}

type ChatMemoryBufferOptions<AdditionalMessageOptions extends object = object> = {
    tokenLimit?: number | undefined;
    chatStore?: BaseChatStore<AdditionalMessageOptions> | undefined;
    chatStoreKey?: string | undefined;
    chatHistory?: ChatMessage<AdditionalMessageOptions>[] | undefined;
    llm?: LLM<object, AdditionalMessageOptions> | undefined;
};
declare class ChatMemoryBuffer<AdditionalMessageOptions extends object = object> extends BaseChatStoreMemory<AdditionalMessageOptions> {
    tokenLimit: number;
    constructor(options?: Partial<ChatMemoryBufferOptions<AdditionalMessageOptions>>);
    getMessages(transientMessages?: ChatMessage<AdditionalMessageOptions>[] | undefined, initialTokenCount?: number): ChatMessage<AdditionalMessageOptions>[];
}

declare class ChatSummaryMemoryBuffer extends BaseMemory {
    /**
     * Tokenizer function that converts text to tokens,
     *  this is used to calculate the number of tokens in a message.
     */
    tokenizer: Tokenizer;
    tokensToSummarize: number;
    messages: ChatMessage[];
    summaryPrompt: SummaryPrompt;
    llm: LLM;
    constructor(options?: Partial<ChatSummaryMemoryBuffer>);
    private summarize;
    private get lastSummaryIndex();
    getLastSummary(): ChatMessage | null;
    private get systemMessages();
    private get nonSystemMessages();
    /**
     * Calculates the messages that describe the conversation so far.
     * If there's no memory, all non-system messages are used.
     * If there's a memory, uses all messages after the last summary message.
     */
    private calcConversationMessages;
    private calcCurrentRequestMessages;
    reset(): void;
    getMessages(transientMessages?: ChatMessage[]): Promise<ChatMessage[]>;
    getAllMessages(): Promise<ChatMessage[]>;
    put(message: ChatMessage): void;
}

export { BaseMemory, ChatMemoryBuffer, ChatSummaryMemoryBuffer };
