Object.defineProperty(exports, '__esModule', { value: true });

var env = require('@llamaindex/env');

const IndexStructType = {
    NODE: "node",
    TREE: "tree",
    LIST: "list",
    KEYWORD_TABLE: "keyword_table",
    DICT: "dict",
    SIMPLE_DICT: "simple_dict",
    WEAVIATE: "weaviate",
    PINECONE: "pinecone",
    QDRANT: "qdrant",
    LANCEDB: "lancedb",
    MILVUS: "milvus",
    CHROMA: "chroma",
    MYSCALE: "myscale",
    CLICKHOUSE: "clickhouse",
    VECTOR_STORE: "vector_store",
    OPENSEARCH: "opensearch",
    DASHVECTOR: "dashvector",
    CHATGPT_RETRIEVAL_PLUGIN: "chatgpt_retrieval_plugin",
    DEEPLAKE: "deeplake",
    EPSILLA: "epsilla",
    MULTIMODAL_VECTOR_STORE: "multimodal",
    SQL: "sql",
    KG: "kg",
    SIMPLE_KG: "simple_kg",
    SIMPLE_LPG: "simple_lpg",
    NEBULAGRAPH: "nebulagraph",
    FALKORDB: "falkordb",
    EMPTY: "empty",
    COMPOSITE: "composite",
    PANDAS: "pandas",
    DOCUMENT_SUMMARY: "document_summary",
    VECTARA: "vectara",
    ZILLIZ_CLOUD_PIPELINE: "zilliz_cloud_pipeline",
    POSTGRESML: "postgresml"
};

class IndexStruct {
    constructor(indexId = env.randomUUID(), summary = undefined){
        this.indexId = indexId;
        this.summary = summary;
    }
    toJson() {
        return {
            indexId: this.indexId,
            summary: this.summary
        };
    }
    getSummary() {
        if (this.summary === undefined) {
            throw new Error("summary field of the index struct is not set");
        }
        return this.summary;
    }
}
// A table of keywords mapping keywords to text chunks.
class KeywordTable extends IndexStruct {
    addNode(keywords, nodeId) {
        keywords.forEach((keyword)=>{
            if (!this.table.has(keyword)) {
                this.table.set(keyword, new Set());
            }
            this.table.get(keyword).add(nodeId);
        });
    }
    deleteNode(keywords, nodeId) {
        keywords.forEach((keyword)=>{
            if (this.table.has(keyword)) {
                this.table.get(keyword).delete(nodeId);
            }
        });
    }
    toJson() {
        return {
            ...super.toJson(),
            table: Array.from(this.table.entries()).reduce((acc, [keyword, nodeIds])=>{
                acc[keyword] = Array.from(nodeIds);
                return acc;
            }, {}),
            type: this.type
        };
    }
    constructor(...args){
        super(...args), this.table = new Map(), this.type = IndexStructType.KEYWORD_TABLE;
    }
}

exports.IndexStruct = IndexStruct;
exports.IndexStructType = IndexStructType;
exports.KeywordTable = KeywordTable;
