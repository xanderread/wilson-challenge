import { JSONValue } from '../../global/dist/index.cjs';
import { MessageContent, MessageContentDetail, ChatMessage, ToolMetadata } from '../../llms/dist/index.cjs';
import { QueryType } from '../../query-engine/dist/index.cjs';
import { ImageType } from '../../schema/dist/index.cjs';

/**
 * Extracts just the text whether from
 *  a multi-modal message
 *  a single text message
 *  or a query
 *
 * @param message The message to extract text from.
 * @returns The extracted text
 */
declare function extractText(message: MessageContent | QueryType): string;
/**
 * Extracts a single text from a multi-modal message content
 *
 * @param message The message to extract images from.
 * @returns The extracted images
 */
declare function extractSingleText(message: MessageContentDetail): string | null;
/**
 * Extracts an image from a multi-modal message content
 *
 * @param message The message to extract images from.
 * @returns The extracted images
 */
declare function extractImage(message: MessageContentDetail): ImageType | null;
declare const extractDataUrlComponents: (dataUrl: string) => {
    mimeType: string;
    base64: string;
};
declare function messagesToHistory(messages: ChatMessage[]): string;
declare function toToolDescriptions(tools: ToolMetadata[]): string;
declare function imageToDataUrl(input: ImageType | Uint8Array): Promise<string>;

type ObjectEntries<T extends Record<string, any>> = {
    [K in keyof T]: [K, T[K]];
}[keyof T][];
/**
 * Type safe version of `Object.entries`
 */
declare function objectEntries<T extends Record<string, any>>(obj: T): ObjectEntries<{
    [K in keyof T]-?: NonNullable<T[K]>;
}>;

declare const isAsyncIterable: (obj: unknown) => obj is AsyncIterable<unknown>;
declare const isIterable: (obj: unknown) => obj is Iterable<unknown>;
declare function streamConverter<S, D>(stream: AsyncIterable<S>, converter: (s: S) => D | null): AsyncIterable<D>;
declare function streamCallbacks<S>(stream: AsyncIterable<S>, callbacks: {
    finished?: (value?: S) => void;
}): AsyncIterable<S>;
declare function streamReducer<S, D>(params: {
    stream: AsyncIterable<S>;
    reducer: (previousValue: D, currentValue: S) => D;
    initialValue: D;
    finished?: (value: D) => void;
}): AsyncIterable<S>;
/**
 * Prettify an error for AI to read
 */
declare function prettifyError(error: unknown): string;
declare function stringifyJSONToMessageContent(value: JSONValue): string;

export { extractDataUrlComponents, extractImage, extractSingleText, extractText, imageToDataUrl, isAsyncIterable, isIterable, messagesToHistory, objectEntries, prettifyError, streamCallbacks, streamConverter, streamReducer, stringifyJSONToMessageContent, toToolDescriptions };
