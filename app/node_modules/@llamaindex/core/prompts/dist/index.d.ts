import { ChatMessage } from '../../llms/dist/index.js';
import { Metadata, BaseOutputParser } from '../../schema/dist/index.js';
import { z } from 'zod';

declare const promptTypeSchema: z.ZodEnum<["summary", "insert", "tree_select", "tree_select_multiple", "text_qa", "refine", "keyword_extract", "query_keyword_extract", "schema_extract", "text_to_sql", "text_to_graph_query", "table_context", "knowledge_triplet_extract", "simple_input", "pandas", "json_path", "single_select", "multi_select", "vector_store_query", "sub_question", "sql_response_synthesis", "sql_response_synthesis_v2", "conversation", "decompose", "choice_select", "custom", "rankgpt_rerank"]>;
declare const PromptType: z.Values<["summary", "insert", "tree_select", "tree_select_multiple", "text_qa", "refine", "keyword_extract", "query_keyword_extract", "schema_extract", "text_to_sql", "text_to_graph_query", "table_context", "knowledge_triplet_extract", "simple_input", "pandas", "json_path", "single_select", "multi_select", "vector_store_query", "sub_question", "sql_response_synthesis", "sql_response_synthesis_v2", "conversation", "decompose", "choice_select", "custom", "rankgpt_rerank"]>;
type PromptType = z.infer<typeof promptTypeSchema>;

type MappingFn<TemplatesVar extends string[] = string[]> = (options: Record<TemplatesVar[number], string>) => string;
type BasePromptTemplateOptions<TemplatesVar extends readonly string[], Vars extends readonly string[]> = {
    metadata?: Metadata;
    templateVars?: TemplatesVar | readonly string[];
    options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>;
    outputParser?: BaseOutputParser | undefined;
    templateVarMappings?: Partial<Record<Vars[number] | (string & {}), TemplatesVar[number] | (string & {})>>;
    functionMappings?: Partial<Record<TemplatesVar[number] | (string & {}), MappingFn>>;
};
declare abstract class BasePromptTemplate<const TemplatesVar extends readonly string[] = string[], const Vars extends readonly string[] = string[]> {
    metadata: Metadata;
    templateVars: Set<string>;
    options: Partial<Record<TemplatesVar[number] | (string & {}), string>>;
    outputParser: BaseOutputParser | undefined;
    templateVarMappings: Partial<Record<Vars[number] | (string & {}), TemplatesVar[number] | (string & {})>>;
    functionMappings: Partial<Record<TemplatesVar[number] | (string & {}), MappingFn>>;
    protected constructor(options: BasePromptTemplateOptions<TemplatesVar, Vars>);
    protected mapTemplateVars(options: Record<TemplatesVar[number] | (string & {}), string>): {
        [k: string]: (Record<(string & {}) | TemplatesVar[number], string> extends infer T extends Record<string, any> ? { [K in keyof T]-?: Record<(string & {}) | TemplatesVar[number], string>[K]; } : never)[string & {}] | (Record<(string & {}) | TemplatesVar[number], string> extends infer T extends Record<string, any> ? { [K in keyof T]-?: Record<(string & {}) | TemplatesVar[number], string>[K]; } : never)[TemplatesVar[number]];
    };
    protected mapFunctionVars(options: Record<TemplatesVar[number] | (string & {}), string>): Record<TemplatesVar[number], string>;
    protected mapAllVars(options: Record<TemplatesVar[number] | (string & {}), string>): Record<string, string>;
    abstract partialFormat(options: Partial<Record<TemplatesVar[number] | (string & {}), string>>): BasePromptTemplate<TemplatesVar, Vars>;
    abstract format(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): string;
    abstract formatMessages(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): ChatMessage[];
    abstract get template(): string;
}
type Permutation<T, K = T> = [T] extends [never] ? [] : K extends K ? [K, ...Permutation<Exclude<T, K>>] : never;
type Join<T extends any[], U extends string> = T extends [infer F, ...infer R] ? R["length"] extends 0 ? `${F & string}` : `${F & string}${U}${Join<R, U>}` : never;
type WrapStringWithBracket<T extends string> = `{${T}}`;
type StringTemplate<Var extends readonly string[]> = Var["length"] extends 0 ? string : Var["length"] extends number ? number extends Var["length"] ? string : `${string}${Join<Permutation<WrapStringWithBracket<Var[number]>>, `${string}`>}${string}` : never;
type PromptTemplateOptions<TemplatesVar extends readonly string[], Vars extends readonly string[], Template extends StringTemplate<TemplatesVar>> = BasePromptTemplateOptions<TemplatesVar, Vars> & {
    template: Template;
    promptType?: PromptType;
};
declare class PromptTemplate<const TemplatesVar extends readonly string[] = string[], const Vars extends readonly string[] = string[], const Template extends StringTemplate<TemplatesVar> = StringTemplate<TemplatesVar>> extends BasePromptTemplate<TemplatesVar, Vars> {
    #private;
    promptType: PromptType;
    constructor(options: PromptTemplateOptions<TemplatesVar, Vars, Template>);
    partialFormat(options: Partial<Record<TemplatesVar[number] | (string & {}), string>>): PromptTemplate<TemplatesVar, Vars, Template>;
    format(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): string;
    formatMessages(options?: Partial<Record<TemplatesVar[number] | (string & {}), string>>): ChatMessage[];
    get template(): Template;
}

type PromptsRecord = Record<string, BasePromptTemplate>;
type ModuleRecord = Record<string, PromptMixin>;
declare abstract class PromptMixin {
    validatePrompts(promptsDict: PromptsRecord, moduleDict: ModuleRecord): void;
    getPrompts(): PromptsRecord;
    updatePrompts(prompts: PromptsRecord): void;
    protected abstract _getPrompts(): PromptsRecord;
    protected abstract _updatePrompts(prompts: PromptsRecord): void;
    /**
     *
     * Return a dictionary of sub-modules within the current module
     * that also implement PromptMixin (so that their prompts can also be get/set).
     *
     * Can be blank if no sub-modules.
     */
    protected abstract _getPromptModules(): ModuleRecord;
}

type TextQAPrompt = PromptTemplate<["context", "query"]>;
type SummaryPrompt = PromptTemplate<["context"]>;
type RefinePrompt = PromptTemplate<[
    "query",
    "existingAnswer",
    "context"
]>;
type TreeSummarizePrompt = PromptTemplate<["context", "query"]>;
type ChoiceSelectPrompt = PromptTemplate<["context", "query"]>;
type SubQuestionPrompt = PromptTemplate<["toolsStr", "queryStr"]>;
type CondenseQuestionPrompt = PromptTemplate<[
    "chatHistory",
    "question"
]>;
type ContextSystemPrompt = PromptTemplate<["context"]>;
type KeywordExtractPrompt = PromptTemplate<["context", "maxKeywords"]>;
type QueryKeywordExtractPrompt = PromptTemplate<["question"]>;
type QuestionExtractPrompt = PromptTemplate<["context", "numQuestions"]>;
type TitleExtractorPrompt = PromptTemplate<["context"]>;
type TitleCombinePrompt = PromptTemplate<["context"]>;
declare const defaultTextQAPrompt: TextQAPrompt;
declare const anthropicTextQaPrompt: TextQAPrompt;
declare const defaultSummaryPrompt: SummaryPrompt;
declare const anthropicSummaryPrompt: SummaryPrompt;
declare const defaultRefinePrompt: RefinePrompt;
declare const defaultTreeSummarizePrompt: PromptTemplate<readonly ["context", "query"], string[], "Context information from multiple sources is below.\n---------------------\n{context}\n---------------------\nGiven the information from multiple sources and not prior knowledge, answer the query.\nQuery: {query}\nAnswer:">;
declare const defaultChoiceSelectPrompt: PromptTemplate<readonly ["context", "query"], string[], "A list of documents is shown below. Each document has a number next to it along \nwith a summary of the document. A question is also provided.\nRespond with the numbers of the documents\nyou should consult to answer the question, in order of relevance, as well\nas the relevance score. The relevance score is a number from 1-10 based on\nhow relevant you think the document is to the question.\nDo not include any documents that are not relevant to the question.\nExample format:\nDocument 1:\n<summary of document 1>\n\nDocument 2:\n<summary of document 2>\n\n...\n\nDocument 10:\n<summary of document 10>\n\nQuestion: <question>\nAnswer:\nDoc: 9, Relevance: 7\nDoc: 3, Relevance: 4\nDoc: 7, Relevance: 3\n\nLet's try this now:\n\n{context}\nQuestion: {query}\nAnswer:">;
declare const defaultSubQuestionPrompt: SubQuestionPrompt;
declare const defaultCondenseQuestionPrompt: PromptTemplate<readonly ["chatHistory", "question"], string[], "Given a conversation (between Human and Assistant) and a follow up message from Human, rewrite the message to be a standalone question that captures all relevant context from the conversation.\n\n<Chat History>\n{chatHistory}\n\n<Follow Up Message>\n{question}\n\n<Standalone question>\n">;
declare const defaultContextSystemPrompt: ContextSystemPrompt;
declare const defaultKeywordExtractPrompt: KeywordExtractPrompt;
declare const defaultQueryKeywordExtractPrompt: PromptTemplate<readonly ["maxKeywords", "question"], string[], "(\n  \"A question is provided below. Given the question, extract up to {maxKeywords} \"\n  \"keywords from the text. Focus on extracting the keywords that we can use \"\n  \"to best lookup answers to the question. Avoid stopwords.\"\n  \"---------------------\"\n  \"{question}\"\n  \"---------------------\"\n  \"Provide keywords in the following comma-separated format: 'KEYWORDS: <keywords>'\"\n)">;
declare const defaultQuestionExtractPrompt: PromptTemplate<readonly ["numQuestions", "context"], string[], "(\n  \"Given the contextual informations below, generate {numQuestions} questions this context can provides specific answers to which are unlikely to be found else where. Higher-level summaries of surrounding context may be provided as well. \"\n  \"Try using these summaries to generate better questions that this context can answer.\"\n  \"---------------------\"\n  \"{context}\"\n  \"---------------------\"\n  \"Provide questions in the following format: 'QUESTIONS: <questions>'\"\n)">;
declare const defaultTitleExtractorPromptTemplate: PromptTemplate<readonly ["context"], string[], "{context}\nGive a title that summarizes all of the unique entities, titles or themes found in the context. \nTitle: ">;
declare const defaultTitleCombinePromptTemplate: PromptTemplate<readonly ["context"], string[], "{context} \nBased on the above candidate titles and contents, what is the comprehensive title for this document? \nTitle: ">;
declare const defaultNodeTextTemplate: PromptTemplate<readonly ["metadataStr", "content"], string[], "[Excerpt from document]\n{metadataStr}\nExcerpt:\n-----\n{content}\n-----\n">;

export { BasePromptTemplate, type BasePromptTemplateOptions, type ChoiceSelectPrompt, type CondenseQuestionPrompt, type ContextSystemPrompt, type KeywordExtractPrompt, type ModuleRecord, PromptMixin, PromptTemplate, type PromptTemplateOptions, type PromptsRecord, type QueryKeywordExtractPrompt, type QuestionExtractPrompt, type RefinePrompt, type StringTemplate, type SubQuestionPrompt, type SummaryPrompt, type TextQAPrompt, type TitleCombinePrompt, type TitleExtractorPrompt, type TreeSummarizePrompt, anthropicSummaryPrompt, anthropicTextQaPrompt, defaultChoiceSelectPrompt, defaultCondenseQuestionPrompt, defaultContextSystemPrompt, defaultKeywordExtractPrompt, defaultNodeTextTemplate, defaultQueryKeywordExtractPrompt, defaultQuestionExtractPrompt, defaultRefinePrompt, defaultSubQuestionPrompt, defaultSummaryPrompt, defaultTextQAPrompt, defaultTitleCombinePromptTemplate, defaultTitleExtractorPromptTemplate, defaultTreeSummarizePrompt };
