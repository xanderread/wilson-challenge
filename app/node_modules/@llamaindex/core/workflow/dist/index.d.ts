declare class WorkflowEvent<T extends Record<string, any> = any> {
    data: T;
    constructor(data: T);
    toString(): string;
}
type EventTypes<T extends Record<string, any> = any> = new (data: T) => WorkflowEvent<T>;
declare class StartEvent<T = string> extends WorkflowEvent<{
    input: T;
}> {
}
declare class StopEvent<T = string> extends WorkflowEvent<{
    result: T;
}> {
}

type StepFunction<T extends WorkflowEvent = WorkflowEvent> = (context: Context, ev: T) => Promise<WorkflowEvent | void>;
type EventTypeParam = EventTypes | EventTypes[];
declare class Workflow {
    #private;
    constructor(params?: {
        verbose?: boolean;
        timeout?: number;
        validate?: boolean;
    });
    addStep<T extends WorkflowEvent>(eventType: EventTypeParam, method: StepFunction<T>, params?: {
        outputs?: EventTypeParam;
    }): void;
    hasStep(step: StepFunction<any>): boolean;
    streamEvents(): AsyncGenerator<WorkflowEvent, void>;
    validate(): void;
    run<T = string>(event: StartEvent<T> | string): Promise<StopEvent>;
}

declare class Context {
    #private;
    running: boolean;
    constructor(params: {
        workflow: Workflow;
        verbose?: boolean;
    });
    set(key: string, value: any): void;
    get(key: string, defaultValue?: any): any;
    collectEvents(event: WorkflowEvent, expected: EventTypes[]): WorkflowEvent[] | null;
    sendEvent(message: WorkflowEvent, step?: StepFunction): void;
    getNextEvent(step: StepFunction): WorkflowEvent | undefined;
    writeEventToStream(event: WorkflowEvent): void;
    streamEvents(): AsyncGenerator<WorkflowEvent, void, void>;
}

export { Context, type EventTypes, StartEvent, type StepFunction, StopEvent, Workflow, WorkflowEvent };
