import * as _hey_api_client_fetch from '@hey-api/client-fetch';
import { Options } from '@hey-api/client-fetch';

declare const APIKeySchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
        };
        readonly redacted_api_key: {
            readonly type: "string";
            readonly title: "Redacted Api Key";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "user_id", "redacted_api_key"];
    readonly title: "APIKey";
    readonly description: "Schema for an API Key.";
};
declare const APIKeyCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly title: "APIKeyCreate";
    readonly description: "Schema for creating an API key.";
};
declare const APIKeyUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly title: "APIKeyUpdate";
    readonly description: "Schema for updating an API key.";
};
declare const AdvancedModeTransformConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["advanced"];
            readonly const: "advanced";
            readonly title: "Mode";
            readonly default: "advanced";
        };
        readonly segmentation_config: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/NoneSegmentationConfig";
            }, {
                readonly $ref: "#/components/schemas/PageSegmentationConfig";
            }, {
                readonly $ref: "#/components/schemas/ElementSegmentationConfig";
            }];
            readonly title: "Segmentation Config";
            readonly description: "Configuration for the segmentation.";
        };
        readonly chunking_config: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/NoneChunkingConfig";
            }, {
                readonly $ref: "#/components/schemas/CharacterChunkingConfig";
            }, {
                readonly $ref: "#/components/schemas/TokenChunkingConfig";
            }, {
                readonly $ref: "#/components/schemas/SentenceChunkingConfig";
            }, {
                readonly $ref: "#/components/schemas/SemanticChunkingConfig";
            }];
            readonly title: "Chunking Config";
            readonly description: "Configuration for the chunking.";
        };
    };
    readonly type: "object";
    readonly title: "AdvancedModeTransformConfig";
};
declare const AutoTransformConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["auto"];
            readonly const: "auto";
            readonly title: "Mode";
            readonly default: "auto";
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "Chunk size for the transformation.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly description: "Chunk overlap for the transformation.";
            readonly default: 200;
            readonly gte: 0;
        };
    };
    readonly type: "object";
    readonly title: "AutoTransformConfig";
};
declare const AzureOpenAIEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the OpenAI embedding model.";
            readonly default: "text-embedding-ada-002";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the OpenAI API.";
        };
        readonly api_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Key";
            readonly description: "The OpenAI API key.";
        };
        readonly api_base: {
            readonly type: "string";
            readonly title: "Api Base";
            readonly description: "The base URL for Azure deployment.";
            readonly default: "";
        };
        readonly api_version: {
            readonly type: "string";
            readonly title: "Api Version";
            readonly description: "The version for Azure OpenAI API.";
            readonly default: "";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly description: "Maximum number of retries.";
            readonly default: 10;
            readonly gte: 0;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "Timeout for each request.";
            readonly default: 60;
            readonly gte: 0;
        };
        readonly default_headers: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Default Headers";
            readonly description: "The default headers for API requests.";
        };
        readonly reuse_client: {
            readonly type: "boolean";
            readonly title: "Reuse Client";
            readonly description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.";
            readonly default: true;
        };
        readonly dimensions: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Dimensions";
            readonly description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.";
        };
        readonly azure_endpoint: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Endpoint";
            readonly description: "The Azure endpoint to use.";
        };
        readonly azure_deployment: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Deployment";
            readonly description: "The Azure deployment to use.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "AzureOpenAIEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "AzureOpenAIEmbedding";
};
declare const AzureOpenAIEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["AZURE_EMBEDDING"];
            readonly const: "AZURE_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "AZURE_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/AzureOpenAIEmbedding";
            readonly description: "Configuration for the Azure OpenAI embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "AzureOpenAIEmbeddingConfig";
};
declare const BaseSchema: {
    readonly properties: {};
    readonly type: "object";
    readonly title: "Base";
};
declare const BaseConnectionValidationSchema: {
    readonly properties: {
        readonly success: {
            readonly type: "boolean";
            readonly title: "Success";
        };
        readonly message: {
            readonly type: "string";
            readonly title: "Message";
        };
    };
    readonly type: "object";
    readonly required: readonly ["success", "message"];
    readonly title: "BaseConnectionValidation";
    readonly description: "Base response model for connection validation.";
};
declare const BasePromptTemplateSchema: {
    readonly properties: {
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly template_vars: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Template Vars";
        };
        readonly kwargs: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Kwargs";
        };
        readonly output_parser: {
            readonly anyOf: readonly [{}, {
                readonly type: "null";
            }];
            readonly title: "Output Parser";
        };
        readonly template_var_mappings: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Template Var Mappings";
            readonly description: "Template variable mappings (Optional).";
        };
        readonly function_mappings: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Function Mappings";
            readonly description: "Function mappings (Optional). This is a mapping from template variable names to functions that take in the current kwargs and return a string.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["metadata", "template_vars", "kwargs", "output_parser"];
    readonly title: "BasePromptTemplate";
};
declare const BedrockEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The modelId of the Bedrock model to use.";
            readonly default: "amazon.titan-embed-text-v1";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly profile_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Profile Name";
            readonly description: "The name of aws profile to use. If not given, then the default profile is used.";
        };
        readonly aws_access_key_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Aws Access Key Id";
            readonly description: "AWS Access Key ID to use";
        };
        readonly aws_secret_access_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Aws Secret Access Key";
            readonly description: "AWS Secret Access Key to use";
        };
        readonly aws_session_token: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Aws Session Token";
            readonly description: "AWS Session Token to use";
        };
        readonly region_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Region Name";
            readonly description: "AWS region name to use. Uses region configured in AWS CLI if not passed";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Max Retries";
            readonly description: "The maximum number of API retries.";
            readonly default: 10;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.";
            readonly default: 60;
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the bedrock client.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "BedrockEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "BedrockEmbedding";
};
declare const BedrockEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["BEDROCK_EMBEDDING"];
            readonly const: "BEDROCK_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "BEDROCK_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/BedrockEmbedding";
            readonly description: "Configuration for the Bedrock embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "BedrockEmbeddingConfig";
};
declare const Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema: {
    readonly properties: {
        readonly upload_file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "Upload File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["upload_file"];
    readonly title: "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put";
};
declare const Body_upload_file_api_parsing_upload_postSchema: {
    readonly properties: {
        readonly language: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly title: "Language";
            readonly default: readonly ["en"];
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: false;
        };
        readonly premium_mode: {
            readonly type: "boolean";
            readonly title: "Premium Mode";
            readonly default: false;
        };
        readonly continuous_mode: {
            readonly type: "boolean";
            readonly title: "Continuous Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "boolean";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
        readonly webhook_url: {
            readonly type: "string";
            readonly title: "Webhook Url";
            readonly default: "";
        };
        readonly take_screenshot: {
            readonly type: "boolean";
            readonly title: "Take Screenshot";
            readonly default: false;
        };
        readonly is_formatting_instruction: {
            readonly type: "boolean";
            readonly title: "Is Formatting Instruction";
            readonly default: true;
        };
        readonly disable_ocr: {
            readonly type: "boolean";
            readonly title: "Disable Ocr";
            readonly default: false;
        };
        readonly annotate_links: {
            readonly type: "boolean";
            readonly title: "Annotate Links";
            readonly default: false;
        };
        readonly disable_reconstruction: {
            readonly type: "boolean";
            readonly title: "Disable Reconstruction";
            readonly default: false;
        };
        readonly input_s3_path: {
            readonly type: "string";
            readonly title: "Input S3 Path";
            readonly default: "";
        };
        readonly output_s3_path_prefix: {
            readonly type: "string";
            readonly title: "Output S3 Path Prefix";
            readonly default: "";
        };
        readonly azure_openai_deployment_name: {
            readonly type: "string";
            readonly title: "Azure Openai Deployment Name";
        };
        readonly azure_openai_endpoint: {
            readonly type: "string";
            readonly title: "Azure Openai Endpoint";
        };
        readonly azure_openai_api_version: {
            readonly type: "string";
            readonly title: "Azure Openai Api Version";
        };
        readonly azure_openai_key: {
            readonly type: "string";
            readonly title: "Azure Openai Key";
        };
        readonly file: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "binary";
            }, {
                readonly type: "null";
            }];
            readonly title: "File";
        };
    };
    readonly type: "object";
    readonly title: "Body_upload_file_api_parsing_upload_post";
};
declare const Body_upload_file_api_v1_files_postSchema: {
    readonly properties: {
        readonly upload_file: {
            readonly type: "string";
            readonly format: "binary";
            readonly title: "Upload File";
        };
    };
    readonly type: "object";
    readonly required: readonly ["upload_file"];
    readonly title: "Body_upload_file_api_v1_files_post";
};
declare const Body_upload_file_api_v1_parsing_upload_postSchema: {
    readonly properties: {
        readonly language: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly title: "Language";
            readonly default: readonly ["en"];
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: false;
        };
        readonly premium_mode: {
            readonly type: "boolean";
            readonly title: "Premium Mode";
            readonly default: false;
        };
        readonly continuous_mode: {
            readonly type: "boolean";
            readonly title: "Continuous Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "boolean";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
        readonly webhook_url: {
            readonly type: "string";
            readonly title: "Webhook Url";
            readonly default: "";
        };
        readonly take_screenshot: {
            readonly type: "boolean";
            readonly title: "Take Screenshot";
            readonly default: false;
        };
        readonly is_formatting_instruction: {
            readonly type: "boolean";
            readonly title: "Is Formatting Instruction";
            readonly default: true;
        };
        readonly disable_ocr: {
            readonly type: "boolean";
            readonly title: "Disable Ocr";
            readonly default: false;
        };
        readonly annotate_links: {
            readonly type: "boolean";
            readonly title: "Annotate Links";
            readonly default: false;
        };
        readonly disable_reconstruction: {
            readonly type: "boolean";
            readonly title: "Disable Reconstruction";
            readonly default: false;
        };
        readonly input_s3_path: {
            readonly type: "string";
            readonly title: "Input S3 Path";
            readonly default: "";
        };
        readonly output_s3_path_prefix: {
            readonly type: "string";
            readonly title: "Output S3 Path Prefix";
            readonly default: "";
        };
        readonly azure_openai_deployment_name: {
            readonly type: "string";
            readonly title: "Azure Openai Deployment Name";
        };
        readonly azure_openai_endpoint: {
            readonly type: "string";
            readonly title: "Azure Openai Endpoint";
        };
        readonly azure_openai_api_version: {
            readonly type: "string";
            readonly title: "Azure Openai Api Version";
        };
        readonly azure_openai_key: {
            readonly type: "string";
            readonly title: "Azure Openai Key";
        };
        readonly file: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "binary";
            }, {
                readonly type: "null";
            }];
            readonly title: "File";
        };
    };
    readonly type: "object";
    readonly title: "Body_upload_file_api_v1_parsing_upload_post";
};
declare const BoxAuthMechanismSchema: {
    readonly type: "string";
    readonly enum: readonly ["developer_token", "ccg"];
    readonly title: "BoxAuthMechanism";
};
declare const CharacterChunkingConfigSchema: {
    readonly properties: {
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly default: 200;
            readonly gte: 0;
        };
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["character"];
            readonly const: "character";
            readonly title: "Mode";
            readonly default: "character";
        };
    };
    readonly type: "object";
    readonly title: "CharacterChunkingConfig";
};
declare const CharacterSplitterSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "The token chunk size for each chunk.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "Chunk Overlap";
            readonly description: "The token overlap of each chunk when splitting.";
            readonly default: 200;
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly description: "Default separator for splitting into words";
            readonly default: " ";
        };
        readonly paragraph_separator: {
            readonly type: "string";
            readonly title: "Paragraph Separator";
            readonly description: "Separator between paragraphs.";
            readonly default: "\n\n\n";
        };
        readonly secondary_chunking_regex: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Secondary Chunking Regex";
            readonly description: "Backup regex for splitting into sentences.";
            readonly default: "[^,.;。？！]+[,.;。？！]?";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "SentenceSplitter";
        };
    };
    readonly type: "object";
    readonly title: "CharacterSplitter";
    readonly description: "A splitter that splits text into characters.";
};
declare const ChatDataSchema: {
    readonly properties: {
        readonly retrieval_parameters: {
            readonly $ref: "#/components/schemas/PresetRetrievalParams";
        };
        readonly llm_parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/LLMParameters";
            }, {
                readonly type: "null";
            }];
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "ChatData";
};
declare const ChatInputParamsSchema: {
    readonly properties: {
        readonly messages: {
            readonly items: {
                readonly $ref: "#/components/schemas/InputMessage";
            };
            readonly type: "array";
            readonly title: "Messages";
        };
        readonly data: {
            readonly $ref: "#/components/schemas/ChatData";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "ChatInputParams";
};
declare const ChatMessageSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
        };
        readonly index: {
            readonly type: "integer";
            readonly title: "Index";
            readonly description: "The index of the message in the chat.";
        };
        readonly annotations: {
            readonly items: {
                readonly $ref: "#/components/schemas/MessageAnnotation";
            };
            readonly type: "array";
            readonly title: "Annotations";
            readonly description: "Retrieval annotations for the message.";
        };
        readonly role: {
            readonly $ref: "#/components/schemas/MessageRole";
        };
        readonly content: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Content";
            readonly description: "Text content of the generation";
        };
        readonly additional_kwargs: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional arguments passed to the model";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "index", "role"];
    readonly title: "ChatMessage";
};
declare const CheckoutSessionCreatePayloadSchema: {
    readonly properties: {
        readonly success_url: {
            readonly type: "string";
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Success Url";
        };
        readonly cancel_url: {
            readonly type: "string";
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Cancel Url";
        };
    };
    readonly type: "object";
    readonly required: readonly ["success_url", "cancel_url"];
    readonly title: "CheckoutSessionCreatePayload";
};
declare const CloudAzStorageBlobDataSourceSchema: {
    readonly properties: {
        readonly container_name: {
            readonly type: "string";
            readonly title: "Container Name";
            readonly description: "The name of the Azure Storage Blob container to read from.";
        };
        readonly account_url: {
            readonly type: "string";
            readonly title: "Account Url";
            readonly description: "The Azure Storage Blob account URL to use for authentication.";
        };
        readonly blob: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Blob";
            readonly description: "The blob name to read from.";
        };
        readonly prefix: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Prefix";
            readonly description: "The prefix of the Azure Storage Blob objects to read from.";
        };
        readonly account_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Account Name";
            readonly description: "The Azure Storage Blob account name to use for authentication.";
        };
        readonly account_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Account Key";
            readonly description: "The Azure Storage Blob account key to use for authentication.";
        };
        readonly tenant_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Tenant Id";
            readonly description: "The Azure AD tenant ID to use for authentication.";
        };
        readonly client_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Id";
            readonly description: "The Azure AD client ID to use for authentication.";
        };
        readonly client_secret: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Secret";
            readonly description: "The Azure AD client secret to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudAzStorageBlobDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["container_name", "account_url"];
    readonly title: "CloudAzStorageBlobDataSource";
};
declare const CloudAzureAISearchVectorStoreSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [true];
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly search_service_api_key: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Search Service Api Key";
            readonly writeOnly: true;
        };
        readonly search_service_endpoint: {
            readonly type: "string";
            readonly title: "Search Service Endpoint";
        };
        readonly search_service_api_version: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Search Service Api Version";
        };
        readonly index_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Index Name";
        };
        readonly filterable_metadata_field_keys: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Filterable Metadata Field Keys";
        };
        readonly embedding_dimension: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding Dimension";
        };
        readonly client_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Id";
        };
        readonly client_secret: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Secret";
        };
        readonly tenant_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Tenant Id";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudAzureAISearchVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["search_service_api_key", "search_service_endpoint"];
    readonly title: "CloudAzureAISearchVectorStore";
    readonly description: "Cloud Azure AI Search Vector Store.";
};
declare const CloudBoxDataSourceSchema: {
    readonly properties: {
        readonly folder_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Folder Id";
            readonly description: "The ID of the Box folder to read from.";
        };
        readonly authentication_mechanism: {
            readonly $ref: "#/components/schemas/BoxAuthMechanism";
            readonly description: "The type of authentication to use (Developer Token or CCG)";
        };
        readonly developer_token: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Developer Token";
            readonly description: "Developer token for authentication if authentication_mechanism is 'developer_token'.";
        };
        readonly client_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Id";
            readonly description: "Box API key used for identifying the application the user is authenticating with";
        };
        readonly client_secret: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Secret";
            readonly description: "Box API secret used for making auth requests.";
        };
        readonly user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Id";
            readonly description: "Box User ID, if provided authenticates as user.";
        };
        readonly enterprise_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Enterprise Id";
            readonly description: "Box Enterprise ID, if provided authenticates as service.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudBoxDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["authentication_mechanism"];
    readonly title: "CloudBoxDataSource";
};
declare const CloudConfluenceDataSourceSchema: {
    readonly properties: {
        readonly server_url: {
            readonly type: "string";
            readonly title: "Server Url";
            readonly description: "The server URL of the Confluence instance.";
        };
        readonly authentication_mechanism: {
            readonly type: "string";
            readonly title: "Authentication Mechanism";
            readonly description: "Type of Authentication for connecting to Confluence APIs.";
        };
        readonly user_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Name";
            readonly description: "The username to use for authentication.";
        };
        readonly api_token: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Token";
            readonly description: "The API token to use for authentication.";
        };
        readonly space_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Space Key";
            readonly description: "The space key to read from.";
        };
        readonly page_ids: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Ids";
            readonly description: "The page IDs of the Confluence to read from.";
        };
        readonly cql: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Cql";
            readonly description: "The CQL query to use for fetching pages.";
        };
        readonly label: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Label";
            readonly description: "The label to use for fetching pages.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudConfluenceDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["server_url", "authentication_mechanism"];
    readonly title: "CloudConfluenceDataSource";
};
declare const CloudDocumentSchema: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly default: readonly [];
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly default: readonly [];
        };
        readonly page_positions: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly type: "integer";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Positions";
            readonly description: "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].";
        };
        readonly id: {
            readonly type: "string";
            readonly title: "Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text", "metadata", "id"];
    readonly title: "CloudDocument";
    readonly description: "Cloud document stored in S3.";
};
declare const CloudDocumentCreateSchema: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly default: readonly [];
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly default: readonly [];
        };
        readonly page_positions: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly type: "integer";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Positions";
            readonly description: "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].";
        };
        readonly id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text", "metadata"];
    readonly title: "CloudDocumentCreate";
    readonly description: "Create a new cloud document.";
};
declare const CloudGoogleDriveDataSourceSchema: {
    readonly properties: {
        readonly folder_id: {
            readonly type: "string";
            readonly title: "Folder Id";
            readonly description: "The ID of the Google Drive folder to read from.";
        };
        readonly service_account_key: {
            readonly type: "object";
            readonly title: "Service Account Key";
            readonly description: "The service account key JSON to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudGoogleDriveDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["folder_id", "service_account_key"];
    readonly title: "CloudGoogleDriveDataSource";
};
declare const CloudJiraDataSourceSchema: {
    readonly properties: {
        readonly email: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Email";
            readonly description: "The email address to use for authentication.";
        };
        readonly api_token: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Token";
            readonly description: "The API/ Access Token used for Basic, PAT and OAuth2 authentication.";
        };
        readonly server_url: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Server Url";
            readonly description: "The server url for Jira Cloud.";
        };
        readonly cloud_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Cloud Id";
            readonly description: "The cloud ID, used in case of OAuth2.";
        };
        readonly authentication_mechanism: {
            readonly type: "string";
            readonly title: "Authentication Mechanism";
            readonly description: "Type of Authentication for connecting to Jira APIs.";
        };
        readonly query: {
            readonly type: "string";
            readonly title: "Query";
            readonly description: "JQL (Jira Query Language) query to search.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudJiraDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["authentication_mechanism", "query"];
    readonly title: "CloudJiraDataSource";
    readonly description: "Cloud Jira Data Source integrating JiraReader.";
};
declare const CloudMilvusVectorStoreSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [false];
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly uri: {
            readonly type: "string";
            readonly title: "Uri";
        };
        readonly collection_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Collection Name";
        };
        readonly token: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Token";
        };
        readonly embedding_dimension: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding Dimension";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudMilvusVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["uri"];
    readonly title: "CloudMilvusVectorStore";
    readonly description: "Cloud Milvus Vector Store.";
};
declare const CloudMongoDBAtlasVectorSearchSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [false];
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly mongodb_uri: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Mongodb Uri";
            readonly writeOnly: true;
        };
        readonly db_name: {
            readonly type: "string";
            readonly title: "Db Name";
        };
        readonly collection_name: {
            readonly type: "string";
            readonly title: "Collection Name";
        };
        readonly vector_index_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Vector Index Name";
        };
        readonly fulltext_index_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Fulltext Index Name";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudMongoDBAtlasVectorSearch";
        };
    };
    readonly type: "object";
    readonly required: readonly ["mongodb_uri", "db_name", "collection_name"];
    readonly title: "CloudMongoDBAtlasVectorSearch";
    readonly description: "Cloud MongoDB Atlas Vector Store.\n\nThis class is used to store the configuration for a MongoDB Atlas vector store,\nso that it can be created and used in LlamaCloud.\n\nArgs:\n    mongodb_uri (str): URI for connecting to MongoDB Atlas\n    db_name (str): name of the MongoDB database\n    collection_name (str): name of the MongoDB collection\n    vector_index_name (str): name of the MongoDB Atlas vector index\n    fulltext_index_name (str): name of the MongoDB Atlas full-text index";
};
declare const CloudNotionPageDataSourceSchema: {
    readonly properties: {
        readonly integration_token: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Integration Token";
            readonly description: "The integration token to use for authentication.";
            readonly writeOnly: true;
        };
        readonly database_ids: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Database Ids";
            readonly description: "The Notion Database Id to read content from.";
        };
        readonly page_ids: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Ids";
            readonly description: "The Page ID's of the Notion to read from.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudNotionPageDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["integration_token"];
    readonly title: "CloudNotionPageDataSource";
};
declare const CloudOneDriveDataSourceSchema: {
    readonly properties: {
        readonly user_principal_name: {
            readonly type: "string";
            readonly title: "User Principal Name";
            readonly description: "The user principal name to use for authentication.";
        };
        readonly folder_path: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Folder Path";
            readonly description: "The path of the OneDrive folder to read from.";
        };
        readonly folder_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Folder Id";
            readonly description: "The ID of the OneDrive folder to read from.";
        };
        readonly client_id: {
            readonly type: "string";
            readonly title: "Client Id";
            readonly description: "The client ID to use for authentication.";
        };
        readonly client_secret: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Client Secret";
            readonly description: "The client secret to use for authentication.";
            readonly writeOnly: true;
        };
        readonly tenant_id: {
            readonly type: "string";
            readonly title: "Tenant Id";
            readonly description: "The tenant ID to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudOneDriveDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["user_principal_name", "client_id", "client_secret", "tenant_id"];
    readonly title: "CloudOneDriveDataSource";
};
declare const CloudPineconeVectorStoreSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [true];
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly api_key: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Api Key";
            readonly description: "The API key for authenticating with Pinecone";
            readonly writeOnly: true;
        };
        readonly index_name: {
            readonly type: "string";
            readonly title: "Index Name";
        };
        readonly namespace: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Namespace";
        };
        readonly insert_kwargs: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Insert Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudPineconeVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key", "index_name"];
    readonly title: "CloudPineconeVectorStore";
    readonly description: "Cloud Pinecone Vector Store.\n\nThis class is used to store the configuration for a Pinecone vector store, so that it can be\ncreated and used in LlamaCloud.\n\nArgs:\n    api_key (str): API key for authenticating with Pinecone\n    index_name (str): name of the Pinecone index\n    namespace (optional[str]): namespace to use in the Pinecone index\n    insert_kwargs (optional[dict]): additional kwargs to pass during insertion";
};
declare const CloudPostgresVectorStoreSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [false];
            readonly const: false;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: false;
        };
        readonly database: {
            readonly type: "string";
            readonly title: "Database";
        };
        readonly host: {
            readonly type: "string";
            readonly title: "Host";
        };
        readonly password: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Password";
            readonly writeOnly: true;
        };
        readonly port: {
            readonly type: "string";
            readonly title: "Port";
        };
        readonly user: {
            readonly type: "string";
            readonly title: "User";
        };
        readonly table_name: {
            readonly type: "string";
            readonly title: "Table Name";
        };
        readonly schema_name: {
            readonly type: "string";
            readonly title: "Schema Name";
        };
        readonly embed_dim: {
            readonly type: "integer";
            readonly title: "Embed Dim";
        };
        readonly hybrid_search: {
            readonly anyOf: readonly [{
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Hybrid Search";
            readonly default: true;
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudPostgresVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["database", "host", "password", "port", "user", "table_name", "schema_name", "embed_dim"];
    readonly title: "CloudPostgresVectorStore";
};
declare const CloudQdrantVectorStoreSchema: {
    readonly properties: {
        readonly supports_nested_metadata_filters: {
            readonly type: "boolean";
            readonly enum: readonly [true];
            readonly const: true;
            readonly title: "Supports Nested Metadata Filters";
            readonly default: true;
        };
        readonly collection_name: {
            readonly type: "string";
            readonly title: "Collection Name";
        };
        readonly url: {
            readonly type: "string";
            readonly title: "Url";
        };
        readonly api_key: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Api Key";
            readonly writeOnly: true;
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly default: 3;
        };
        readonly client_kwargs: {
            readonly type: "object";
            readonly title: "Client Kwargs";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudQdrantVectorStore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["collection_name", "url", "api_key"];
    readonly title: "CloudQdrantVectorStore";
    readonly description: "Cloud Qdrant Vector Store.\n\nThis class is used to store the configuration for a Qdrant vector store, so that it can be\ncreated and used in LlamaCloud.\n\nArgs:\n    collection_name (str): name of the Qdrant collection\n    url (str): url of the Qdrant instance\n    api_key (str): API key for authenticating with Qdrant\n    max_retries (int): maximum number of retries in case of a failure. Defaults to 3\n    client_kwargs (dict): additional kwargs to pass to the Qdrant client";
};
declare const CloudS3DataSourceSchema: {
    readonly properties: {
        readonly bucket: {
            readonly type: "string";
            readonly title: "Bucket";
            readonly description: "The name of the S3 bucket to read from.";
        };
        readonly prefix: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Prefix";
            readonly description: "The prefix of the S3 objects to read from.";
        };
        readonly aws_access_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Aws Access Id";
            readonly description: "The AWS access ID to use for authentication.";
        };
        readonly aws_access_secret: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "password";
                readonly writeOnly: true;
            }, {
                readonly type: "null";
            }];
            readonly title: "Aws Access Secret";
            readonly description: "The AWS access secret to use for authentication.";
        };
        readonly s3_endpoint_url: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "S3 Endpoint Url";
            readonly description: "The S3 endpoint URL to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudS3DataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["bucket"];
    readonly title: "CloudS3DataSource";
};
declare const CloudSharepointDataSourceSchema: {
    readonly properties: {
        readonly site_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Site Name";
            readonly description: "The name of the SharePoint site to download from.";
        };
        readonly site_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Site Id";
            readonly description: "The ID of the SharePoint site to download from.";
        };
        readonly folder_path: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Folder Path";
            readonly description: "The path of the Sharepoint folder to read from.";
        };
        readonly folder_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Folder Id";
            readonly description: "The ID of the Sharepoint folder to read from.";
        };
        readonly drive_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Drive Name";
            readonly description: "The name of the Sharepoint drive to read from.";
        };
        readonly client_id: {
            readonly type: "string";
            readonly title: "Client Id";
            readonly description: "The client ID to use for authentication.";
        };
        readonly client_secret: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Client Secret";
            readonly description: "The client secret to use for authentication.";
            readonly writeOnly: true;
        };
        readonly tenant_id: {
            readonly type: "string";
            readonly title: "Tenant Id";
            readonly description: "The tenant ID to use for authentication.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudSharepointDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["client_id", "client_secret", "tenant_id"];
    readonly title: "CloudSharepointDataSource";
};
declare const CloudSlackDataSourceSchema: {
    readonly properties: {
        readonly slack_token: {
            readonly type: "string";
            readonly format: "password";
            readonly title: "Slack Token";
            readonly description: "Slack Bot Token.";
            readonly writeOnly: true;
        };
        readonly channel_ids: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Channel Ids";
            readonly description: "Slack Channel.";
        };
        readonly latest_date: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Latest Date";
            readonly description: "Latest date.";
        };
        readonly earliest_date: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Earliest Date";
            readonly description: "Earliest date.";
        };
        readonly earliest_date_timestamp: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Earliest Date Timestamp";
            readonly description: "Earliest date timestamp.";
        };
        readonly latest_date_timestamp: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Latest Date Timestamp";
            readonly description: "Latest date timestamp.";
        };
        readonly channel_patterns: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Channel Patterns";
            readonly description: "Slack Channel name pattern.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CloudSlackDataSource";
        };
    };
    readonly type: "object";
    readonly required: readonly ["slack_token"];
    readonly title: "CloudSlackDataSource";
};
declare const CodeSplitterSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly language: {
            readonly type: "string";
            readonly title: "Language";
            readonly description: "The programming language of the code being split.";
        };
        readonly chunk_lines: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Lines";
            readonly description: "The number of lines to include in each chunk.";
            readonly default: 40;
        };
        readonly chunk_lines_overlap: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Lines Overlap";
            readonly description: "How many lines of code each chunk overlaps with.";
            readonly default: 15;
        };
        readonly max_chars: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Max Chars";
            readonly description: "Maximum number of characters per chunk.";
            readonly default: 1500;
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CodeSplitter";
        };
    };
    readonly type: "object";
    readonly required: readonly ["language"];
    readonly title: "CodeSplitter";
    readonly description: "Split code using a AST parser.\n\nThank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.\nhttps://docs.sweep.dev/blogs/chunking-2m-files";
};
declare const CohereEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The modelId of the Cohere model to use.";
            readonly default: "embed-english-v3.0";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly api_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Key";
            readonly description: "The Cohere API key.";
        };
        readonly truncate: {
            readonly type: "string";
            readonly title: "Truncate";
            readonly description: "Truncation type - START/ END/ NONE";
            readonly default: "END";
        };
        readonly input_type: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Input Type";
            readonly description: "Model Input type. If not provided, search_document and search_query are used when needed.";
        };
        readonly embedding_type: {
            readonly type: "string";
            readonly title: "Embedding Type";
            readonly description: "Embedding type. If not provided float embedding_type is used when needed.";
            readonly default: "float";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "CohereEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["api_key"];
    readonly title: "CohereEmbedding";
};
declare const CohereEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["COHERE_EMBEDDING"];
            readonly const: "COHERE_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "COHERE_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/CohereEmbedding";
            readonly description: "Configuration for the Cohere embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "CohereEmbeddingConfig";
};
declare const ConfigurableDataSinkNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["PINECONE", "POSTGRES", "QDRANT", "AZUREAI_SEARCH", "MONGODB_ATLAS", "MILVUS"];
    readonly title: "ConfigurableDataSinkNames";
};
declare const ConfigurableDataSourceNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["S3", "AZURE_STORAGE_BLOB", "GOOGLE_DRIVE", "MICROSOFT_ONEDRIVE", "MICROSOFT_SHAREPOINT", "SLACK", "NOTION_PAGE", "CONFLUENCE", "JIRA", "BOX"];
    readonly title: "ConfigurableDataSourceNames";
};
declare const ConfigurableTransformationDefinitionSchema: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly configurable_transformation_type: {
            readonly $ref: "#/components/schemas/ConfigurableTransformationNames";
            readonly description: "The name field will act as the unique identifier of TransformationDefinition objects";
        };
        readonly transformation_category: {
            readonly $ref: "#/components/schemas/TransformationCategoryNames";
            readonly description: "The transformation_category field will be used to group transformations in the UI";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "configurable_transformation_type", "transformation_category"];
    readonly title: "ConfigurableTransformationDefinition";
    readonly description: "Schema for a transformation definition.";
};
declare const ConfigurableTransformationNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["CHARACTER_SPLITTER", "PAGE_SPLITTER_NODE_PARSER", "CODE_NODE_PARSER", "SENTENCE_AWARE_NODE_PARSER", "TOKEN_AWARE_NODE_PARSER", "MARKDOWN_NODE_PARSER", "MARKDOWN_ELEMENT_NODE_PARSER"];
    readonly title: "ConfigurableTransformationNames";
};
declare const ConfiguredTransformationItemSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
        };
        readonly configurable_transformation_type: {
            readonly $ref: "#/components/schemas/ConfigurableTransformationNames";
            readonly description: "Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames.";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CharacterSplitter";
            }, {
                readonly $ref: "#/components/schemas/PageSplitterNodeParser";
            }, {
                readonly $ref: "#/components/schemas/CodeSplitter";
            }, {
                readonly $ref: "#/components/schemas/SentenceSplitter";
            }, {
                readonly $ref: "#/components/schemas/TokenTextSplitter";
            }, {
                readonly $ref: "#/components/schemas/MarkdownNodeParser";
            }, {
                readonly $ref: "#/components/schemas/MarkdownElementNodeParser";
            }];
            readonly title: "Component";
            readonly description: "Component that implements the transformation";
        };
    };
    readonly type: "object";
    readonly required: readonly ["configurable_transformation_type", "component"];
    readonly title: "ConfiguredTransformationItem";
    readonly description: "Configured transformations for pipelines.\n\nSimilar to ConfigurableTransformation but includes a few\nmore fields that are useful to the platform.";
};
declare const CustomerPortalSessionCreatePayloadSchema: {
    readonly properties: {
        readonly return_url: {
            readonly type: "string";
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Return Url";
        };
    };
    readonly type: "object";
    readonly required: readonly ["return_url"];
    readonly title: "CustomerPortalSessionCreatePayload";
};
declare const DataSinkSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch";
            }, {
                readonly $ref: "#/components/schemas/CloudMilvusVectorStore";
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "sink_type", "component", "project_id"];
    readonly title: "DataSink";
    readonly description: "Schema for a data sink.";
};
declare const DataSinkCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch";
            }, {
                readonly $ref: "#/components/schemas/CloudMilvusVectorStore";
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "sink_type", "component"];
    readonly title: "DataSinkCreate";
    readonly description: "Schema for creating a data sink.";
};
declare const DataSinkDefinitionSchema: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
            readonly description: "The name field will act as the unique identifier of DataSinkDefinition objects";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "sink_type"];
    readonly title: "DataSinkDefinition";
    readonly description: "Schema for a data sink definition.";
};
declare const DataSinkUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
            readonly description: "The name of the data sink.";
        };
        readonly sink_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSinkNames";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudPineconeVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudPostgresVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudQdrantVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudAzureAISearchVectorStore";
            }, {
                readonly $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch";
            }, {
                readonly $ref: "#/components/schemas/CloudMilvusVectorStore";
            }, {
                readonly type: "null";
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["sink_type"];
    readonly title: "DataSinkUpdate";
    readonly description: "Schema for updating a data sink.";
};
declare const DataSourceSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudS3DataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudGoogleDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSharepointDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSlackDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudJiraDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudBoxDataSource";
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "source_type", "component", "project_id"];
    readonly title: "DataSource";
    readonly description: "Schema for a data source.";
};
declare const DataSourceCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudS3DataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudGoogleDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSharepointDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSlackDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudJiraDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudBoxDataSource";
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "source_type", "component"];
    readonly title: "DataSourceCreate";
    readonly description: "Schema for creating a data source.";
};
declare const DataSourceDefinitionSchema: {
    readonly properties: {
        readonly label: {
            readonly type: "string";
            readonly title: "Label";
            readonly description: "The label field will be used to display the name of the component in the UI";
        };
        readonly json_schema: {
            readonly type: "object";
            readonly title: "Json Schema";
            readonly description: "The json_schema field can be used by clients to determine how to construct the component";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
            readonly description: "The name field will act as the unique identifier of DataSourceDefinition objects";
        };
    };
    readonly type: "object";
    readonly required: readonly ["label", "json_schema", "source_type"];
    readonly title: "DataSourceDefinition";
    readonly description: "Schema for a data source definition.";
};
declare const DataSourceUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudS3DataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudGoogleDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSharepointDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSlackDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudJiraDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudBoxDataSource";
            }, {
                readonly type: "null";
            }];
            readonly title: "Component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["source_type"];
    readonly title: "DataSourceUpdate";
    readonly description: "Schema for updating a data source.";
};
declare const DefaultOrganizationUpdateSchema: {
    readonly properties: {
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["organization_id"];
    readonly title: "DefaultOrganizationUpdate";
    readonly description: "Schema for updating the default organization for a user.";
};
declare const ElementSegmentationConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["element"];
            readonly const: "element";
            readonly title: "Mode";
            readonly default: "element";
        };
    };
    readonly type: "object";
    readonly title: "ElementSegmentationConfig";
};
declare const EvalDatasetSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "EvalDataset";
    readonly description: "Schema for an eval dataset.\nIncludes the other DB fields like id, created_at, & updated_at.";
};
declare const EvalDatasetCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "EvalDatasetCreate";
    readonly description: "Schema for creating an eval dataset.";
};
declare const EvalDatasetJobParamsSchema: {
    readonly properties: {
        readonly eval_question_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly title: "Eval Question Ids";
            readonly description: "The IDs for the EvalQuestions this execution ran against.";
        };
        readonly eval_execution_params: {
            readonly $ref: "#/components/schemas/EvalExecutionParams";
            readonly description: "The parameters for the eval execution.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_ids", "eval_execution_params"];
    readonly title: "EvalDatasetJobParams";
    readonly description: "Schema for the parameters of an eval dataset job.";
};
declare const EvalDatasetJobRecordSchema: {
    readonly properties: {
        readonly job_name: {
            readonly type: "string";
            readonly enum: readonly ["eval_dataset_job"];
            readonly const: "eval_dataset_job";
            readonly title: "Job Name";
        };
        readonly partitions: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "string";
                    readonly format: "uuid";
                }, {
                    readonly type: "string";
                }];
            };
            readonly type: "object";
            readonly title: "Partitions";
            readonly description: "The partitions for this execution. Used for determining where to save job output.";
        };
        readonly parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/EvalDatasetJobParams";
            }, {
                readonly type: "null";
            }];
            readonly description: "Additional input parameters for the eval execution.";
        };
        readonly session_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Session Id";
            readonly description: "The upstream request ID that created this job. Used for tracking the job across services.";
        };
        readonly correlation_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Correlation Id";
            readonly description: "The correlation ID for this job. Used for tracking the job across services.";
        };
        readonly parent_job_execution_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Parent Job Execution Id";
            readonly description: "The ID of the parent job execution.";
        };
        readonly user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Id";
            readonly description: "The ID of the user that created this job";
        };
        readonly created_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/StatusEnum";
        };
        readonly error_code: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Error Code";
        };
        readonly error_message: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Error Message";
        };
        readonly attempts: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Attempts";
            readonly description: "The number of times this job has been attempted";
            readonly default: 0;
        };
        readonly started_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Started At";
        };
        readonly ended_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Ended At";
        };
        readonly updated_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly data: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/Base";
            }, {
                readonly type: "null";
            }];
            readonly description: "Additional metadata for the job execution.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["job_name", "partitions", "status"];
    readonly title: "EvalDatasetJobRecord";
    readonly description: "Schema for job that evaluates an EvalDataset against a pipeline.";
};
declare const EvalDatasetUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the EvalDataset.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "EvalDatasetUpdate";
    readonly description: "Schema for updating an eval dataset.\nOnly the name can be updated.";
};
declare const EvalExecutionCreateSchema: {
    readonly properties: {
        readonly eval_question_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly title: "Eval Question Ids";
        };
        readonly params: {
            readonly $ref: "#/components/schemas/EvalExecutionParamsOverride";
            readonly description: "The parameters for the eval execution that will override the ones set in the pipeline.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_ids"];
    readonly title: "EvalExecutionCreate";
    readonly description: "Schema for creating an eval execution for a given set of questions on a pipeline.";
};
declare const EvalExecutionParamsSchema: {
    readonly properties: {
        readonly llm_model: {
            readonly $ref: "#/components/schemas/SupportedLLMModelNames";
            readonly description: "The LLM model to use within eval execution.";
            readonly default: "GPT_4O";
        };
        readonly qa_prompt_tmpl: {
            readonly type: "string";
            readonly title: "Qa Prompt Tmpl";
            readonly description: "The template to use for the question answering prompt.";
            readonly default: "Context information is below.\n---------------------\n{context_str}\n---------------------\nGiven the context information and not prior knowledge, answer the query.\nQuery: {query_str}\nAnswer: ";
        };
    };
    readonly type: "object";
    readonly title: "EvalExecutionParams";
    readonly description: "Schema for the params for an eval execution.";
};
declare const EvalExecutionParamsOverrideSchema: {
    readonly properties: {
        readonly llm_model: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/SupportedLLMModelNames";
            }, {
                readonly type: "null";
            }];
            readonly description: "The LLM model to use within eval execution.";
        };
        readonly qa_prompt_tmpl: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Qa Prompt Tmpl";
            readonly description: "The template to use for the question answering prompt.";
        };
    };
    readonly type: "object";
    readonly title: "EvalExecutionParamsOverride";
    readonly description: "Schema for the params override for an eval execution.";
};
declare const EvalMetricSchema: {
    readonly type: "string";
    readonly enum: readonly ["RELEVANCY", "FAITHFULNESS"];
    readonly title: "EvalMetric";
};
declare const EvalQuestionSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly content: {
            readonly type: "string";
            readonly maxLength: 1000;
            readonly minLength: 1;
            readonly title: "Content";
            readonly description: "The content of the question.";
        };
        readonly eval_dataset_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Dataset Id";
        };
        readonly eval_dataset_index: {
            readonly type: "integer";
            readonly title: "Eval Dataset Index";
            readonly description: "The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.";
            readonly min: 0;
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "content", "eval_dataset_id", "eval_dataset_index"];
    readonly title: "EvalQuestion";
};
declare const EvalQuestionCreateSchema: {
    readonly properties: {
        readonly content: {
            readonly type: "string";
            readonly maxLength: 1000;
            readonly minLength: 1;
            readonly title: "Content";
            readonly description: "The content of the question.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["content"];
    readonly title: "EvalQuestionCreate";
};
declare const EvalQuestionResultSchema: {
    readonly properties: {
        readonly eval_question_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Question Id";
            readonly description: "The ID of the question that was executed.";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the question was executed against.";
        };
        readonly source_nodes: {
            readonly items: {
                readonly $ref: "#/components/schemas/TextNode";
            };
            readonly type: "array";
            readonly title: "Source Nodes";
            readonly description: "The nodes retrieved by the pipeline for the given question.";
        };
        readonly answer: {
            readonly type: "string";
            readonly title: "Answer";
            readonly description: "The answer to the question.";
        };
        readonly eval_metrics: {
            readonly additionalProperties: {
                readonly $ref: "#/components/schemas/MetricResult";
            };
            readonly type: "object";
            readonly title: "Eval Metrics";
            readonly description: "The eval metrics for the question.";
        };
        readonly eval_dataset_execution_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Dataset Execution Id";
            readonly description: "The ID of the EvalDatasetJobRecord that this result was generated from.";
        };
        readonly eval_dataset_execution_params: {
            readonly $ref: "#/components/schemas/EvalExecutionParams";
            readonly description: "The EvalExecutionParams that were used when this result was generated.";
        };
        readonly eval_finished_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Eval Finished At";
            readonly description: "The timestamp when the eval finished.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "EvalQuestionResult";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_question_id", "pipeline_id", "source_nodes", "answer", "eval_metrics", "eval_dataset_execution_id", "eval_dataset_execution_params", "eval_finished_at"];
    readonly title: "EvalQuestionResult";
    readonly description: "Schema for the result of an eval question job.";
};
declare const ExtractionJobSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "The id of the extraction job";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/StatusEnum";
            readonly description: "The status of the extraction job";
        };
        readonly file: {
            readonly $ref: "#/components/schemas/File";
            readonly description: "The file that the extract was extracted from";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status", "file"];
    readonly title: "ExtractionJob";
};
declare const ExtractionJobCreateSchema: {
    readonly properties: {
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The id of the file";
        };
    };
    readonly type: "object";
    readonly required: readonly ["schema_id", "file_id"];
    readonly title: "ExtractionJobCreate";
    readonly description: "Schema for creating an extraction job.";
};
declare const ExtractionJobCreateBatchSchema: {
    readonly properties: {
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly file_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly minItems: 1;
            readonly title: "File Ids";
            readonly description: "The ids of the files";
        };
    };
    readonly type: "object";
    readonly required: readonly ["schema_id", "file_ids"];
    readonly title: "ExtractionJobCreateBatch";
    readonly description: "Schema for creating extraction jobs in batch.";
};
declare const ExtractionResultSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly schema_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Schema Id";
            readonly description: "The id of the schema";
        };
        readonly data: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }, {
                    readonly type: "null";
                }];
            };
            readonly type: "object";
            readonly title: "Data";
            readonly description: "The data extracted from the file";
        };
        readonly file: {
            readonly $ref: "#/components/schemas/File";
            readonly description: "The file that the extract was extracted from";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "schema_id", "data", "file"];
    readonly title: "ExtractionResult";
    readonly description: "Schema for an extraction result.";
};
declare const ExtractionSchemaSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly data_schema: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "ExtractionSchema";
    readonly description: "Schema for extraction schema.";
};
declare const ExtractionSchemaCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly data_schema: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly type: "object";
                }, {
                    readonly items: {};
                    readonly type: "array";
                }, {
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }, {
                    readonly type: "number";
                }, {
                    readonly type: "boolean";
                }, {
                    readonly type: "null";
                }];
            };
            readonly type: "object";
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "data_schema"];
    readonly title: "ExtractionSchemaCreate";
    readonly description: "Schema for creating an extraction schema.";
};
declare const ExtractionSchemaInferSchema: {
    readonly properties: {
        readonly schema_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Schema Id";
            readonly description: "The ID of a schema to update with the new schema";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "The name of the extraction schema";
        };
        readonly project_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Project Id";
            readonly description: "The ID of the project that the extraction schema belongs to";
        };
        readonly file_ids: {
            readonly items: {
                readonly type: "string";
                readonly format: "uuid";
            };
            readonly type: "array";
            readonly minItems: 1;
            readonly title: "File Ids";
            readonly description: "The IDs of the files that the extraction schema contains";
        };
        readonly stream: {
            readonly type: "boolean";
            readonly title: "Stream";
            readonly description: "Whether to stream the results of the extraction schema";
            readonly default: false;
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "file_ids"];
    readonly title: "ExtractionSchemaInfer";
    readonly description: "Schema for inferring an extraction schema.";
};
declare const ExtractionSchemaUpdateSchema: {
    readonly properties: {
        readonly data_schema: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Schema";
            readonly description: "The schema of the data";
        };
    };
    readonly type: "object";
    readonly title: "ExtractionSchemaUpdate";
    readonly description: "Schema for updating an extraction schema.";
};
declare const FileSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly file_size: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly minimum: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly file_type: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "File Type";
            readonly description: "File type (e.g. pdf, docx, etc.)";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the file belongs to";
        };
        readonly last_modified_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id"];
    readonly title: "File";
    readonly description: "Schema for a file.";
};
declare const FileCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly file_size: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly minimum: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly last_modified_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "FileCreate";
};
declare const FilterConditionSchema: {
    readonly type: "string";
    readonly enum: readonly ["and", "or"];
    readonly title: "FilterCondition";
    readonly description: "Vector store filter conditions to combine different filters.";
};
declare const FilterOperatorSchema: {
    readonly type: "string";
    readonly enum: readonly ["==", ">", "<", "!=", ">=", "<=", "in", "nin", "any", "all", "text_match", "contains", "is_empty"];
    readonly title: "FilterOperator";
    readonly description: "Vector store filter operator.";
};
declare const GeminiEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The modelId of the Gemini model to use.";
            readonly default: "models/embedding-001";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly title: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Title";
            readonly description: "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.";
            readonly default: "";
        };
        readonly task_type: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Task Type";
            readonly description: "The task for embedding model.";
            readonly default: "retrieval_document";
        };
        readonly api_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Key";
            readonly description: "API key to access the model. Defaults to None.";
        };
        readonly api_base: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Base";
            readonly description: "API base to access the model. Defaults to None.";
        };
        readonly transport: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Transport";
            readonly description: "Transport to access the model. Defaults to None.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "GeminiEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "GeminiEmbedding";
};
declare const GeminiEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["GEMINI_EMBEDDING"];
            readonly const: "GEMINI_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "GEMINI_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/GeminiEmbedding";
            readonly description: "Configuration for the Gemini embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "GeminiEmbeddingConfig";
};
declare const HTTPValidationErrorSchema: {
    readonly properties: {
        readonly detail: {
            readonly items: {
                readonly $ref: "#/components/schemas/ValidationError";
            };
            readonly type: "array";
            readonly title: "Detail";
        };
    };
    readonly type: "object";
    readonly title: "HTTPValidationError";
};
declare const HuggingFaceInferenceAPIEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Model Name";
            readonly description: "Hugging Face model name. If None, the task will be used.";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly pooling: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/Pooling";
            }, {
                readonly type: "null";
            }];
            readonly description: "Pooling strategy. If None, the model's default pooling is used.";
            readonly default: "cls";
        };
        readonly query_instruction: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Query Instruction";
            readonly description: "Instruction to prepend during query embedding.";
        };
        readonly text_instruction: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Text Instruction";
            readonly description: "Instruction to prepend during text embedding.";
        };
        readonly token: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Token";
            readonly description: "Hugging Face token. Will default to the locally saved token. Pass token=False if you don’t want to send your token to the server.";
        };
        readonly timeout: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Timeout";
            readonly description: "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.";
        };
        readonly headers: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Headers";
            readonly description: "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.";
        };
        readonly cookies: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Cookies";
            readonly description: "Additional cookies to send to the server.";
        };
        readonly task: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Task";
            readonly description: "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "HuggingFaceInferenceAPIEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "HuggingFaceInferenceAPIEmbedding";
};
declare const HuggingFaceInferenceAPIEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["HUGGINGFACE_API_EMBEDDING"];
            readonly const: "HUGGINGFACE_API_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "HUGGINGFACE_API_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding";
            readonly description: "Configuration for the HuggingFace Inference API embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "HuggingFaceInferenceAPIEmbeddingConfig";
};
declare const IngestionErrorResponseSchema: {
    readonly properties: {
        readonly job_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Job Id";
            readonly description: "ID of the job that failed.";
        };
        readonly message: {
            readonly type: "string";
            readonly title: "Message";
            readonly description: "List of errors that occurred during ingestion.";
        };
        readonly step: {
            readonly $ref: "#/components/schemas/JobNameMapping";
            readonly description: "Name of the job that failed.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["job_id", "message", "step"];
    readonly title: "IngestionErrorResponse";
};
declare const InputMessageSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly title: "Id";
            readonly description: "ID of the message, if any. a UUID.";
        };
        readonly role: {
            readonly $ref: "#/components/schemas/MessageRole";
        };
        readonly content: {
            readonly type: "string";
            readonly title: "Content";
        };
        readonly data: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data";
            readonly description: "Additional data to be stored with the message.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "role", "content"];
    readonly title: "InputMessage";
    readonly description: "This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend";
};
declare const JobNameMappingSchema: {
    readonly type: "string";
    readonly enum: readonly ["MANAGED_INGESTION", "DATA_SOURCE", "FILES_UPDATE", "FILE_UPDATER", "PARSE", "TRANSFORM", "INGESTION"];
    readonly title: "JobNameMapping";
    readonly description: "Enum for mapping original job names to readable names.";
};
declare const LLMSchema: {
    readonly properties: {
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly system_prompt: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "System Prompt";
            readonly description: "System prompt for LLM calls.";
        };
        readonly messages_to_prompt: {
            readonly type: "string";
            readonly title: "Messages To Prompt";
            readonly description: "Function to convert a list of messages to an LLM prompt.";
        };
        readonly completion_to_prompt: {
            readonly type: "string";
            readonly title: "Completion To Prompt";
            readonly description: "Function to convert a completion to an LLM prompt.";
        };
        readonly output_parser: {
            readonly anyOf: readonly [{}, {
                readonly type: "null";
            }];
            readonly title: "Output Parser";
            readonly description: "Output parser to parse, validate, and correct errors programmatically.";
        };
        readonly pydantic_program_mode: {
            readonly $ref: "#/components/schemas/PydanticProgramMode";
            readonly default: "default";
        };
        readonly query_wrapper_prompt: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/BasePromptTemplate";
            }, {
                readonly type: "null";
            }];
            readonly description: "Query wrapper prompt for LLM calls.";
        };
    };
    readonly type: "object";
    readonly title: "LLM";
    readonly description: "The LLM class is the main class for interacting with language models.\n\nAttributes:\n    system_prompt (Optional[str]):\n        System prompt for LLM calls.\n    messages_to_prompt (Callable):\n        Function to convert a list of messages to an LLM prompt.\n    completion_to_prompt (Callable):\n        Function to convert a completion to an LLM prompt.\n    output_parser (Optional[BaseOutputParser]):\n        Output parser to parse, validate, and correct errors programmatically.\n    pydantic_program_mode (PydanticProgramMode):\n        Pydantic program mode to use for structured prediction.";
};
declare const LLMModelDataSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the LLM model.";
        };
        readonly description: {
            readonly type: "string";
            readonly title: "Description";
            readonly description: "The description of the LLM model.";
        };
        readonly multi_modal: {
            readonly type: "boolean";
            readonly title: "Multi Modal";
            readonly description: "Whether the model supports multi-modal image input";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "description", "multi_modal"];
    readonly title: "LLMModelData";
    readonly description: "Schema for an eval LLM model.";
};
declare const LLMParametersSchema: {
    readonly properties: {
        readonly model_name: {
            readonly $ref: "#/components/schemas/SupportedLLMModelNames";
            readonly description: "The name of the model to use for LLM completions.";
            readonly default: "GPT_3_5_TURBO";
        };
        readonly system_prompt: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "System Prompt";
            readonly description: "The system prompt to use for the completion.";
        };
        readonly temperature: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Temperature";
            readonly description: "The temperature value for the model.";
            readonly default: 0.1;
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "LLMParameters";
};
declare const LlamaParseParametersSchema: {
    readonly properties: {
        readonly languages: {
            readonly items: {
                readonly $ref: "#/components/schemas/ParserLanguages";
            };
            readonly type: "array";
            readonly minItems: 1;
            readonly title: "Languages";
        };
        readonly parsing_instruction: {
            readonly type: "string";
            readonly title: "Parsing Instruction";
            readonly default: "";
        };
        readonly disable_ocr: {
            readonly type: "boolean";
            readonly title: "Disable Ocr";
            readonly default: false;
        };
        readonly annotate_links: {
            readonly type: "boolean";
            readonly title: "Annotate Links";
            readonly default: false;
        };
        readonly disable_reconstruction: {
            readonly type: "boolean";
            readonly title: "Disable Reconstruction";
            readonly default: false;
        };
        readonly invalidate_cache: {
            readonly type: "boolean";
            readonly title: "Invalidate Cache";
            readonly default: false;
        };
        readonly do_not_cache: {
            readonly type: "boolean";
            readonly title: "Do Not Cache";
            readonly default: false;
        };
        readonly fast_mode: {
            readonly type: "boolean";
            readonly title: "Fast Mode";
            readonly default: false;
        };
        readonly skip_diagonal_text: {
            readonly type: "boolean";
            readonly title: "Skip Diagonal Text";
            readonly default: false;
        };
        readonly gpt4o_mode: {
            readonly type: "boolean";
            readonly title: "Gpt4O Mode";
            readonly default: false;
        };
        readonly gpt4o_api_key: {
            readonly type: "string";
            readonly title: "Gpt4O Api Key";
            readonly default: "";
        };
        readonly do_not_unroll_columns: {
            readonly type: "boolean";
            readonly title: "Do Not Unroll Columns";
            readonly default: false;
        };
        readonly page_separator: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Separator";
        };
        readonly bounding_box: {
            readonly type: "string";
            readonly title: "Bounding Box";
            readonly default: "";
        };
        readonly target_pages: {
            readonly type: "string";
            readonly title: "Target Pages";
            readonly default: "";
        };
        readonly use_vendor_multimodal_model: {
            readonly type: "boolean";
            readonly title: "Use Vendor Multimodal Model";
            readonly default: false;
        };
        readonly vendor_multimodal_model_name: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Model Name";
            readonly default: "";
        };
        readonly vendor_multimodal_api_key: {
            readonly type: "string";
            readonly title: "Vendor Multimodal Api Key";
            readonly default: "";
        };
        readonly page_prefix: {
            readonly type: "string";
            readonly title: "Page Prefix";
            readonly default: "";
        };
        readonly page_suffix: {
            readonly type: "string";
            readonly title: "Page Suffix";
            readonly default: "";
        };
        readonly webhook_url: {
            readonly type: "string";
            readonly title: "Webhook Url";
            readonly default: "";
        };
        readonly take_screenshot: {
            readonly type: "boolean";
            readonly title: "Take Screenshot";
            readonly default: false;
        };
        readonly is_formatting_instruction: {
            readonly type: "boolean";
            readonly title: "Is Formatting Instruction";
            readonly default: true;
        };
        readonly premium_mode: {
            readonly type: "boolean";
            readonly title: "Premium Mode";
            readonly default: false;
        };
        readonly continuous_mode: {
            readonly type: "boolean";
            readonly title: "Continuous Mode";
            readonly default: false;
        };
        readonly s3_input_path: {
            readonly type: "string";
            readonly title: "S3 Input Path";
            readonly default: "";
        };
        readonly s3_output_path_prefix: {
            readonly type: "string";
            readonly title: "S3 Output Path Prefix";
            readonly default: "";
        };
        readonly azure_openai_deployment_name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Openai Deployment Name";
        };
        readonly azure_openai_endpoint: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Openai Endpoint";
        };
        readonly azure_openai_api_version: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Openai Api Version";
        };
        readonly azure_openai_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Azure Openai Key";
        };
    };
    readonly type: "object";
    readonly title: "LlamaParseParameters";
    readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
};
declare const LlamaParseSupportedFileExtensionsSchema: {
    readonly type: "string";
    readonly enum: readonly [".pdf", ".doc", ".docx", ".docm", ".dot", ".dotx", ".dotm", ".rtf", ".wps", ".wpd", ".sxw", ".stw", ".sxg", ".pages", ".mw", ".mcw", ".uot", ".uof", ".uos", ".uop", ".ppt", ".pptx", ".pot", ".pptm", ".potx", ".potm", ".key", ".odp", ".odg", ".otp", ".fopd", ".sxi", ".sti", ".epub", ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".tiff", ".webp", ".html", ".htm", ".xls", ".xlsx", ".xlsm", ".xlsb", ".xlw", ".csv", ".dif", ".sylk", ".slk", ".prn", ".numbers", ".et", ".ods", ".fods", ".uos1", ".uos2", ".dbf", ".wk1", ".wk2", ".wk3", ".wk4", ".wks", ".wq1", ".wq2", ".wb1", ".wb2", ".wb3", ".qpw", ".xlr", ".eth", ".tsv"];
    readonly title: "LlamaParseSupportedFileExtensions";
};
declare const LocalEvalSchema: {
    readonly properties: {
        readonly query: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Query";
            readonly description: "Query string";
        };
        readonly contexts: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly type: "string";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Contexts";
            readonly description: "Context strings";
        };
        readonly response: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Response";
            readonly description: "Response string";
        };
        readonly passing: {
            readonly anyOf: readonly [{
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Passing";
            readonly description: "Binary evaluation result (passing or not)";
        };
        readonly feedback: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Feedback";
            readonly description: "Feedback or reasoning for the response";
        };
        readonly score: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Score";
            readonly description: "Score for the response";
        };
        readonly pairwise_source: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Pairwise Source";
            readonly description: "Used only for pairwise and specifies whether it is from original order of presented answers or flipped order";
        };
        readonly invalid_result: {
            readonly type: "boolean";
            readonly title: "Invalid Result";
            readonly description: "Whether the evaluation result is an invalid one.";
            readonly default: false;
        };
        readonly invalid_reason: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Invalid Reason";
            readonly description: "Reason for invalid evaluation.";
        };
    };
    readonly type: "object";
    readonly title: "LocalEval";
    readonly description: "Evaluation result, EvaluationResult from llama_index.\n\nOutput of an BaseEvaluator.";
};
declare const LocalEvalResultsSchema: {
    readonly properties: {
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project.";
        };
        readonly eval_set_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Eval Set Id";
            readonly description: "The ID of the local eval result set.";
        };
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly eval_name: {
            readonly type: "string";
            readonly title: "Eval Name";
            readonly description: "The name of the eval.";
        };
        readonly result: {
            readonly $ref: "#/components/schemas/LocalEval";
            readonly description: "The eval results.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["project_id", "app_name", "eval_name", "result"];
    readonly title: "LocalEvalResults";
    readonly description: "Schema for the result of a local evaluation.";
};
declare const LocalEvalSetCreateSchema: {
    readonly properties: {
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly results: {
            readonly additionalProperties: {
                readonly items: {
                    readonly $ref: "#/components/schemas/LocalEval";
                };
                readonly type: "array";
            };
            readonly type: "object";
            readonly title: "Results";
            readonly description: "The eval results.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["app_name", "results"];
    readonly title: "LocalEvalSetCreate";
    readonly description: "Schema for creating a local eval set.";
};
declare const LocalEvalSetsSchema: {
    readonly properties: {
        readonly eval_set_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Eval Set Id";
            readonly description: "The ID of the eval set.";
        };
        readonly app_name: {
            readonly type: "string";
            readonly title: "App Name";
            readonly description: "The name of the app.";
        };
        readonly upload_time: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Upload Time";
            readonly description: "The time of the upload.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["eval_set_id", "app_name", "upload_time"];
    readonly title: "LocalEvalSets";
};
declare const ManagedIngestionStatusSchema: {
    readonly type: "string";
    readonly enum: readonly ["NOT_STARTED", "IN_PROGRESS", "SUCCESS", "ERROR", "PARTIAL_SUCCESS"];
    readonly title: "ManagedIngestionStatus";
    readonly description: "Status of managed ingestion with partial Updates.";
};
declare const ManagedIngestionStatusResponseSchema: {
    readonly properties: {
        readonly job_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Job Id";
            readonly description: "ID of the latest job.";
        };
        readonly deployment_date: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Deployment Date";
            readonly description: "Date of the deployment.";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/ManagedIngestionStatus";
            readonly description: "Status of the ingestion.";
        };
        readonly error: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly $ref: "#/components/schemas/IngestionErrorResponse";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Error";
            readonly description: "List of errors that occurred during ingestion.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["status"];
    readonly title: "ManagedIngestionStatusResponse";
};
declare const MarkdownElementNodeParserSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly llm: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/LLM";
            }, {
                readonly type: "null";
            }];
            readonly description: "LLM model to use for summarization.";
        };
        readonly summary_query_str: {
            readonly type: "string";
            readonly title: "Summary Query Str";
            readonly description: "Query string to use for summarization.";
            readonly default: "What is this table about? Give a very concise summary (imagine you are adding a new caption and summary for this table), and output the real/existing table title/caption if context provided.and output the real/existing table id if context provided.and also output whether or not the table should be kept.";
        };
        readonly num_workers: {
            readonly type: "integer";
            readonly title: "Num Workers";
            readonly description: "Num of workers for async jobs.";
            readonly default: 4;
        };
        readonly show_progress: {
            readonly type: "boolean";
            readonly title: "Show Progress";
            readonly description: "Whether to show progress.";
            readonly default: true;
        };
        readonly nested_node_parser: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/NodeParser";
            }, {
                readonly type: "null";
            }];
            readonly description: "Other types of node parsers to handle some types of nodes.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "MarkdownElementNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "MarkdownElementNodeParser";
    readonly description: "Markdown element node parser.\n\nSplits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects\n(e.g. tables).";
};
declare const MarkdownNodeParserSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "MarkdownNodeParser";
        };
    };
    readonly type: "object";
    readonly title: "MarkdownNodeParser";
    readonly description: "Markdown node parser.\n\nSplits a document into Nodes using custom Markdown splitting logic.\n\nArgs:\n    include_metadata (bool): whether to include metadata in nodes\n    include_prev_next_rel (bool): whether to include prev/next relationships";
};
declare const MessageAnnotationSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly title: "Type";
        };
        readonly data: {
            readonly type: "string";
            readonly contentMediaType: "application/json";
            readonly contentSchema: {};
            readonly title: "Data";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["type", "data"];
    readonly title: "MessageAnnotation";
};
declare const MessageRoleSchema: {
    readonly type: "string";
    readonly enum: readonly ["system", "user", "assistant", "function", "tool", "chatbot", "model"];
    readonly title: "MessageRole";
    readonly description: "Message role.";
};
declare const MetadataFilterSchema: {
    readonly properties: {
        readonly key: {
            readonly type: "string";
            readonly title: "Key";
        };
        readonly value: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "number";
            }, {
                readonly type: "string";
            }, {
                readonly items: {
                    readonly type: "string";
                };
                readonly type: "array";
            }, {
                readonly items: {
                    readonly type: "number";
                };
                readonly type: "array";
            }, {
                readonly items: {
                    readonly type: "integer";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Value";
        };
        readonly operator: {
            readonly $ref: "#/components/schemas/FilterOperator";
            readonly default: "==";
        };
    };
    readonly type: "object";
    readonly required: readonly ["key", "value"];
    readonly title: "MetadataFilter";
    readonly description: "Comprehensive metadata filter for vector stores to support more operators.\n\nValue uses Strict* types, as int, float and str are compatible types and were all\nconverted to string before.\n\nSee: https://docs.pydantic.dev/latest/usage/types/#strict-types";
};
declare const MetadataFiltersSchema: {
    readonly properties: {
        readonly filters: {
            readonly items: {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/MetadataFilter";
                }, {
                    readonly $ref: "#/components/schemas/MetadataFilters";
                }];
            };
            readonly type: "array";
            readonly title: "Filters";
        };
        readonly condition: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/FilterCondition";
            }, {
                readonly type: "null";
            }];
            readonly default: "and";
        };
    };
    readonly type: "object";
    readonly required: readonly ["filters"];
    readonly title: "MetadataFilters";
    readonly description: "Metadata filters for vector stores.";
};
declare const MetricResultSchema: {
    readonly properties: {
        readonly passing: {
            readonly anyOf: readonly [{
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Passing";
            readonly description: "Whether the metric passed or not.";
        };
        readonly score: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Score";
            readonly description: "The score for the metric.";
        };
        readonly feedback: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Feedback";
            readonly description: "The reasoning for the metric.";
        };
    };
    readonly type: "object";
    readonly title: "MetricResult";
};
declare const NodeParserSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "NodeParser";
    readonly description: "Base interface for node parser.";
};
declare const NodeRelationshipSchema: {
    readonly type: "string";
    readonly enum: readonly ["1", "2", "3", "4", "5"];
    readonly title: "NodeRelationship";
    readonly description: "Node relationships used in `BaseNode` class.\n\nAttributes:\n    SOURCE: The node is the source document.\n    PREVIOUS: The node is the previous node in the document.\n    NEXT: The node is the next node in the document.\n    PARENT: The node is the parent node in the document.\n    CHILD: The node is a child node in the document.";
};
declare const NoneChunkingConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["none"];
            readonly const: "none";
            readonly title: "Mode";
            readonly default: "none";
        };
    };
    readonly type: "object";
    readonly title: "NoneChunkingConfig";
};
declare const NoneSegmentationConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["none"];
            readonly const: "none";
            readonly title: "Mode";
            readonly default: "none";
        };
    };
    readonly type: "object";
    readonly title: "NoneSegmentationConfig";
};
declare const ObjectTypeSchema: {
    readonly type: "string";
    readonly enum: readonly ["1", "2", "3", "4"];
    readonly title: "ObjectType";
};
declare const OpenAIEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The name of the OpenAI embedding model.";
            readonly default: "text-embedding-ada-002";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the OpenAI API.";
        };
        readonly api_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Key";
            readonly description: "The OpenAI API key.";
        };
        readonly api_base: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Base";
            readonly description: "The base URL for OpenAI API.";
            readonly default: "https://api.openai.com/v1";
        };
        readonly api_version: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Api Version";
            readonly description: "The version for OpenAI API.";
            readonly default: "";
        };
        readonly max_retries: {
            readonly type: "integer";
            readonly title: "Max Retries";
            readonly description: "Maximum number of retries.";
            readonly default: 10;
            readonly gte: 0;
        };
        readonly timeout: {
            readonly type: "number";
            readonly title: "Timeout";
            readonly description: "Timeout for each request.";
            readonly default: 60;
            readonly gte: 0;
        };
        readonly default_headers: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Default Headers";
            readonly description: "The default headers for API requests.";
        };
        readonly reuse_client: {
            readonly type: "boolean";
            readonly title: "Reuse Client";
            readonly description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.";
            readonly default: true;
        };
        readonly dimensions: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Dimensions";
            readonly description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "OpenAIEmbedding";
        };
    };
    readonly type: "object";
    readonly title: "OpenAIEmbedding";
};
declare const OpenAIEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["OPENAI_EMBEDDING"];
            readonly const: "OPENAI_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "OPENAI_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/OpenAIEmbedding";
            readonly description: "Configuration for the OpenAI embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "OpenAIEmbeddingConfig";
};
declare const OrganizationSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name"];
    readonly title: "Organization";
    readonly description: "Schema for an organization.";
};
declare const OrganizationCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "OrganizationCreate";
    readonly description: "Schema for creating an organization.";
};
declare const OrganizationUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
            readonly description: "A name for the organization.";
        };
    };
    readonly type: "object";
    readonly title: "OrganizationUpdate";
    readonly description: "Schema for updating an organization.";
};
declare const PageScreenshotMetadataSchema: {
    readonly properties: {
        readonly page_index: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "Page Index";
            readonly description: "The index of the page for which the screenshot is taken (0-indexed)";
        };
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The ID of the file that the page screenshot was taken from";
        };
        readonly image_size: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "Image Size";
            readonly description: "The size of the image in bytes";
        };
    };
    readonly type: "object";
    readonly required: readonly ["page_index", "file_id", "image_size"];
    readonly title: "PageScreenshotMetadata";
};
declare const PageScreenshotNodeWithScoreSchema: {
    readonly properties: {
        readonly node: {
            readonly $ref: "#/components/schemas/PageScreenshotMetadata";
        };
        readonly score: {
            readonly type: "number";
            readonly title: "Score";
            readonly description: "The score of the screenshot node";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "NodeWithScore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["node", "score"];
    readonly title: "PageScreenshotNodeWithScore";
    readonly description: "Page screenshot metadata with score";
};
declare const PageSegmentationConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["page"];
            readonly const: "page";
            readonly title: "Mode";
            readonly default: "page";
        };
        readonly page_separator: {
            readonly type: "string";
            readonly title: "Page Separator";
            readonly default: "\n---\n";
        };
    };
    readonly type: "object";
    readonly title: "PageSegmentationConfig";
};
declare const PageSplitterNodeParserSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly page_separator: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Page Separator";
            readonly description: "Separator to split text into pages.";
            readonly default: "\n---\n";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "PageSplitterNodeParser";
    readonly description: "Split text into pages.";
};
declare const ParserLanguagesSchema: {
    readonly type: "string";
    readonly enum: readonly ["af", "az", "bs", "cs", "cy", "da", "de", "en", "es", "et", "fr", "ga", "hr", "hu", "id", "is", "it", "ku", "la", "lt", "lv", "mi", "ms", "mt", "nl", "no", "oc", "pi", "pl", "pt", "ro", "rs_latin", "sk", "sl", "sq", "sv", "sw", "tl", "tr", "uz", "vi", "ar", "fa", "ug", "ur", "bn", "as", "mni", "ru", "rs_cyrillic", "be", "bg", "uk", "mn", "abq", "ady", "kbd", "ava", "dar", "inh", "che", "lbe", "lez", "tab", "tjk", "hi", "mr", "ne", "bh", "mai", "ang", "bho", "mah", "sck", "new", "gom", "sa", "bgc", "th", "ch_sim", "ch_tra", "ja", "ko", "ta", "te", "kn"];
    readonly title: "ParserLanguages";
    readonly description: "Enum for representing the languages supported by the parser";
};
declare const ParsingHistoryItemSchema: {
    readonly properties: {
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
        };
        readonly day: {
            readonly type: "string";
            readonly title: "Day";
        };
        readonly job_id: {
            readonly type: "string";
            readonly title: "Job Id";
        };
        readonly file_name: {
            readonly type: "string";
            readonly title: "File Name";
        };
        readonly original_file_name: {
            readonly type: "string";
            readonly title: "Original File Name";
        };
        readonly expired: {
            readonly type: "boolean";
            readonly title: "Expired";
            readonly default: false;
        };
        readonly pages: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Pages";
        };
        readonly images: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Images";
        };
        readonly time: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Time";
        };
    };
    readonly type: "object";
    readonly required: readonly ["user_id", "day", "job_id", "file_name", "original_file_name"];
    readonly title: "ParsingHistoryItem";
};
declare const ParsingJobSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/StatusEnum";
        };
        readonly error_code: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Error Code";
        };
        readonly error_message: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Error Message";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status"];
    readonly title: "ParsingJob";
};
declare const ParsingJobJsonResultSchema: {
    readonly properties: {
        readonly pages: {
            readonly title: "Pages";
            readonly description: "The json result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly required: readonly ["pages", "job_metadata"];
    readonly title: "ParsingJobJsonResult";
};
declare const ParsingJobMarkdownResultSchema: {
    readonly properties: {
        readonly markdown: {
            readonly type: "string";
            readonly title: "Markdown";
            readonly description: "The markdown result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly required: readonly ["markdown", "job_metadata"];
    readonly title: "ParsingJobMarkdownResult";
};
declare const ParsingJobTextResultSchema: {
    readonly properties: {
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
            readonly description: "The text result of the parsing job";
        };
        readonly job_metadata: {
            readonly title: "Job Metadata";
            readonly description: "Parsing job metadata , including usage";
        };
    };
    readonly type: "object";
    readonly required: readonly ["text", "job_metadata"];
    readonly title: "ParsingJobTextResult";
};
declare const ParsingUsageSchema: {
    readonly properties: {
        readonly usage_pdf_pages: {
            readonly type: "integer";
            readonly title: "Usage Pdf Pages";
        };
        readonly max_pdf_pages: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Max Pdf Pages";
        };
    };
    readonly type: "object";
    readonly required: readonly ["usage_pdf_pages"];
    readonly title: "ParsingUsage";
};
declare const PartitionNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["data_source_id_partition", "pipeline_id_partition", "eval_dataset_id_partition", "file_id_partition", "pipeline_file_id_partition", "file_parsing_id_partition", "extraction_schema_id_partition"];
    readonly title: "PartitionNames";
    readonly description: "Enum for dataset partition names.";
};
declare const PermissionSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the permission.";
        };
        readonly description: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Description";
            readonly description: "A description for the permission.";
        };
        readonly access: {
            readonly type: "boolean";
            readonly title: "Access";
            readonly description: "Whether the permission is granted or not.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "description", "access"];
    readonly title: "Permission";
    readonly description: "Schema for a permission.";
};
declare const PipelineSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
        readonly pipeline_type: {
            readonly $ref: "#/components/schemas/PipelineType";
            readonly description: "Type of pipeline. Either PLAYGROUND or MANAGED.";
            readonly default: "MANAGED";
        };
        readonly managed_pipeline_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
        readonly embedding_config: {
            readonly oneOf: readonly [{
                readonly $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/CohereEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/GeminiEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/OpenAIEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/VertexAIEmbeddingConfig";
            }, {
                readonly $ref: "#/components/schemas/BedrockEmbeddingConfig";
            }];
            readonly title: "Embedding Config";
            readonly discriminator: {
                readonly propertyName: "type";
                readonly mapping: {
                    readonly AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig";
                    readonly BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig";
                    readonly COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig";
                    readonly GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig";
                    readonly HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
                    readonly OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig";
                    readonly VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig";
                };
            };
        };
        readonly configured_transformations: {
            readonly items: {
                readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
            };
            readonly type: "array";
            readonly title: "Configured Transformations";
            readonly description: "Deprecated don't use it, List of configured transformations.";
            readonly default: readonly [];
        };
        readonly config_hash: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/PipelineConfigurationHashes";
            }, {
                readonly type: "null";
            }];
            readonly description: "Hashes for the configuration of the pipeline.";
        };
        readonly transform_config: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/AutoTransformConfig";
            }, {
                readonly $ref: "#/components/schemas/AdvancedModeTransformConfig";
            }];
            readonly title: "Transform Config";
            readonly description: "Configuration for the transformation.";
        };
        readonly preset_retrieval_parameters: {
            readonly $ref: "#/components/schemas/PresetRetrievalParams";
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly $ref: "#/components/schemas/EvalExecutionParams";
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/LlamaParseParameters";
            }, {
                readonly type: "null";
            }];
            readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
        };
        readonly data_sink: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/DataSink";
            }, {
                readonly type: "null";
            }];
            readonly description: "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "project_id", "embedding_config"];
    readonly title: "Pipeline";
    readonly description: "Schema for a pipeline.";
};
declare const PipelineConfigurationHashesSchema: {
    readonly properties: {
        readonly embedding_config_hash: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding Config Hash";
            readonly description: "Hash of the embedding config.";
            readonly default: "";
        };
        readonly parsing_config_hash: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Parsing Config Hash";
            readonly description: "Hash of the llama parse parameters.";
            readonly default: "";
        };
        readonly transform_config_hash: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Transform Config Hash";
            readonly description: "Hash of the transform config.";
            readonly default: "";
        };
    };
    readonly type: "object";
    readonly title: "PipelineConfigurationHashes";
    readonly description: "Hashes for the configuration of a pipeline.";
};
declare const PipelineCreateSchema: {
    readonly properties: {
        readonly embedding_config: {
            readonly anyOf: readonly [{
                readonly oneOf: readonly [{
                    readonly $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/CohereEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/GeminiEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/OpenAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/VertexAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/BedrockEmbeddingConfig";
                }];
                readonly discriminator: {
                    readonly propertyName: "type";
                    readonly mapping: {
                        readonly AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig";
                        readonly BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig";
                        readonly COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig";
                        readonly GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig";
                        readonly HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
                        readonly OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig";
                        readonly VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig";
                    };
                };
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding Config";
        };
        readonly transform_config: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/AutoTransformConfig";
            }, {
                readonly $ref: "#/components/schemas/AdvancedModeTransformConfig";
            }, {
                readonly type: "null";
            }];
            readonly title: "Transform Config";
            readonly description: "Configuration for the transformation.";
        };
        readonly configured_transformations: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Configured Transformations";
            readonly description: "Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.";
            readonly default: readonly [];
        };
        readonly data_sink_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Sink Id";
            readonly description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.";
        };
        readonly data_sink: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/DataSinkCreate";
            }, {
                readonly type: "null";
            }];
            readonly description: "Data sink. When provided instead of data_sink_id, the data sink will be created.";
        };
        readonly preset_retrieval_parameters: {
            readonly $ref: "#/components/schemas/PresetRetrievalParams";
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly $ref: "#/components/schemas/EvalExecutionParams";
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly $ref: "#/components/schemas/LlamaParseParameters";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly pipeline_type: {
            readonly $ref: "#/components/schemas/PipelineType";
            readonly description: "Type of pipeline. Either PLAYGROUND or MANAGED.";
            readonly default: "MANAGED";
        };
        readonly managed_pipeline_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "PipelineCreate";
    readonly description: "Schema for creating a pipeline.";
};
declare const PipelineDataSourceSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the data source.";
        };
        readonly source_type: {
            readonly $ref: "#/components/schemas/ConfigurableDataSourceNames";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata that will be present on all data loaded from the data source";
        };
        readonly component: {
            readonly anyOf: readonly [{
                readonly type: "object";
            }, {
                readonly $ref: "#/components/schemas/CloudS3DataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudAzStorageBlobDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudGoogleDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudOneDriveDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSharepointDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudSlackDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudNotionPageDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudConfluenceDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudJiraDataSource";
            }, {
                readonly $ref: "#/components/schemas/CloudBoxDataSource";
            }];
            readonly title: "Component";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
        };
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source.";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline.";
        };
        readonly last_synced_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Last Synced At";
            readonly description: "The last time the data source was automatically synced.";
        };
        readonly sync_interval: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Sync Interval";
            readonly description: "The interval at which the data source should be synced.";
        };
        readonly sync_schedule_set_by: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Sync Schedule Set By";
            readonly description: "The id of the user who set the sync schedule.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "source_type", "component", "project_id", "data_source_id", "pipeline_id", "last_synced_at"];
    readonly title: "PipelineDataSource";
    readonly description: "Schema for a data source in a pipeline.";
};
declare const PipelineDataSourceCreateSchema: {
    readonly properties: {
        readonly data_source_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source.";
        };
        readonly sync_interval: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Sync Interval";
            readonly description: "The interval at which the data source should be synced.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["data_source_id"];
    readonly title: "PipelineDataSourceCreate";
    readonly description: "Schema for creating an association between a data source and a pipeline.";
};
declare const PipelineDataSourceUpdateSchema: {
    readonly properties: {
        readonly sync_interval: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Sync Interval";
            readonly description: "The interval at which the data source should be synced.";
        };
    };
    readonly type: "object";
    readonly title: "PipelineDataSourceUpdate";
    readonly description: "Schema for updating an association between a data source and a pipeline.";
};
declare const PipelineDeploymentSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly status: {
            readonly $ref: "#/components/schemas/ManagedIngestionStatus";
            readonly description: "Status of the pipeline deployment.";
        };
        readonly started_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Started At";
            readonly description: "Time the pipeline deployment started.";
        };
        readonly ended_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Ended At";
            readonly description: "Time the pipeline deployment finished.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "status"];
    readonly title: "PipelineDeployment";
};
declare const PipelineFileSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
        };
        readonly file_size: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly minimum: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "File Size";
            readonly description: "Size of the file in bytes";
        };
        readonly file_type: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly maxLength: 3000;
                readonly minLength: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "File Type";
            readonly description: "File type (e.g. pdf, docx, etc.)";
        };
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project that the file belongs to";
        };
        readonly last_modified_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Last Modified At";
            readonly description: "The last modified time of the file";
        };
        readonly resource_info: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Resource Info";
            readonly description: "Resource information for the file";
        };
        readonly data_source_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Source Id";
            readonly description: "The ID of the data source that the file belongs to";
        };
        readonly file_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "File Id";
            readonly description: "The ID of the file";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the file is associated with";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
        readonly config_hash: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Config Hash";
            readonly description: "Hashes for the configuration of the pipeline.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "project_id", "pipeline_id"];
    readonly title: "PipelineFile";
    readonly description: "Schema for a file that is associated with a pipeline.";
};
declare const PipelineFileCreateSchema: {
    readonly properties: {
        readonly file_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "File Id";
            readonly description: "The ID of the file";
        };
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
    };
    readonly type: "object";
    readonly required: readonly ["file_id"];
    readonly title: "PipelineFileCreate";
    readonly description: "Schema for creating a file that is associated with a pipeline.";
};
declare const PipelineFileUpdateSchema: {
    readonly properties: {
        readonly custom_metadata: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly anyOf: readonly [{
                        readonly type: "object";
                    }, {
                        readonly items: {};
                        readonly type: "array";
                    }, {
                        readonly type: "string";
                    }, {
                        readonly type: "integer";
                    }, {
                        readonly type: "number";
                    }, {
                        readonly type: "boolean";
                    }, {
                        readonly type: "null";
                    }];
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Custom Metadata";
            readonly description: "Custom metadata for the file";
        };
    };
    readonly type: "object";
    readonly title: "PipelineFileUpdate";
    readonly description: "Schema for updating a file that is associated with a pipeline.";
};
declare const PipelineTypeSchema: {
    readonly type: "string";
    readonly enum: readonly ["PLAYGROUND", "MANAGED"];
    readonly title: "PipelineType";
    readonly description: "Enum for representing the type of a pipeline";
};
declare const PipelineUpdateSchema: {
    readonly properties: {
        readonly embedding_config: {
            readonly anyOf: readonly [{
                readonly oneOf: readonly [{
                    readonly $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/CohereEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/GeminiEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/OpenAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/VertexAIEmbeddingConfig";
                }, {
                    readonly $ref: "#/components/schemas/BedrockEmbeddingConfig";
                }];
                readonly discriminator: {
                    readonly propertyName: "type";
                    readonly mapping: {
                        readonly AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig";
                        readonly BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig";
                        readonly COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig";
                        readonly GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig";
                        readonly HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig";
                        readonly OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig";
                        readonly VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig";
                    };
                };
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding Config";
        };
        readonly transform_config: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/AutoTransformConfig";
            }, {
                readonly $ref: "#/components/schemas/AdvancedModeTransformConfig";
            }, {
                readonly type: "null";
            }];
            readonly title: "Transform Config";
            readonly description: "Configuration for the transformation.";
        };
        readonly configured_transformations: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly $ref: "#/components/schemas/ConfiguredTransformationItem";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Configured Transformations";
            readonly description: "Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.";
            readonly default: readonly [];
        };
        readonly data_sink_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Data Sink Id";
            readonly description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.";
        };
        readonly data_sink: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/DataSinkCreate";
            }, {
                readonly type: "null";
            }];
            readonly description: "Data sink. When provided instead of data_sink_id, the data sink will be created.";
        };
        readonly preset_retrieval_parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/PresetRetrievalParams";
            }, {
                readonly type: "null";
            }];
            readonly description: "Preset retrieval parameters for the pipeline.";
        };
        readonly eval_parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/EvalExecutionParams";
            }, {
                readonly type: "null";
            }];
            readonly description: "Eval parameters for the pipeline.";
        };
        readonly llama_parse_parameters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/LlamaParseParameters";
            }, {
                readonly type: "null";
            }];
            readonly description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.";
        };
        readonly name: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Name";
        };
        readonly managed_pipeline_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Managed Pipeline Id";
            readonly description: "The ID of the ManagedPipeline this playground pipeline is linked to.";
        };
    };
    readonly type: "object";
    readonly title: "PipelineUpdate";
    readonly description: "Schema for updating a pipeline.";
};
declare const PlaygroundSessionSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
        };
        readonly llm_params_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Llm Params Id";
        };
        readonly llm_params: {
            readonly $ref: "#/components/schemas/LLMParameters";
            readonly description: "LLM parameters last used in this session.";
        };
        readonly retrieval_params_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Retrieval Params Id";
        };
        readonly retrieval_params: {
            readonly $ref: "#/components/schemas/PresetRetrievalParams";
            readonly description: "Preset retrieval parameters last used in this session.";
        };
        readonly chat_messages: {
            readonly items: {
                readonly $ref: "#/components/schemas/ChatMessage";
            };
            readonly type: "array";
            readonly title: "Chat Messages";
            readonly description: "Chat message history for this session.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "pipeline_id", "user_id", "llm_params_id", "retrieval_params_id"];
    readonly title: "PlaygroundSession";
    readonly description: "A playground session for a user.";
};
declare const PoolingSchema: {
    readonly type: "string";
    readonly enum: readonly ["cls", "mean", "last"];
    readonly title: "Pooling";
    readonly description: "Enum of possible pooling choices with pooling behaviors.";
};
declare const PresetRetrievalParamsSchema: {
    readonly properties: {
        readonly dense_similarity_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Dense Similarity Top K";
            readonly description: "Number of nodes for dense retrieval.";
            readonly default: 30;
        };
        readonly sparse_similarity_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Sparse Similarity Top K";
            readonly description: "Number of nodes for sparse retrieval.";
            readonly default: 30;
        };
        readonly enable_reranking: {
            readonly anyOf: readonly [{
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Enable Reranking";
            readonly description: "Enable reranking for retrieval";
        };
        readonly rerank_top_n: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Rerank Top N";
            readonly description: "Number of reranked nodes for returning.";
            readonly default: 3;
        };
        readonly alpha: {
            readonly anyOf: readonly [{
                readonly type: "number";
                readonly maximum: 1;
                readonly minimum: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "Alpha";
            readonly description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.";
        };
        readonly search_filters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/MetadataFilters";
            }, {
                readonly type: "null";
            }];
            readonly description: "Search filters for retrieval.";
        };
        readonly files_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 5;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Files Top K";
            readonly description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).";
            readonly default: 1;
        };
        readonly retrieval_mode: {
            readonly $ref: "#/components/schemas/RetrievalMode";
            readonly description: "The retrieval mode for the query.";
            readonly default: "auto_routed";
        };
        readonly retrieve_image_nodes: {
            readonly type: "boolean";
            readonly title: "Retrieve Image Nodes";
            readonly description: "Whether to retrieve image nodes.";
            readonly default: false;
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly title: "PresetRetrievalParams";
    readonly description: "Schema for the search params for an retrieval execution that can be preset for a pipeline.";
};
declare const PresignedUrlSchema: {
    readonly properties: {
        readonly url: {
            readonly type: "string";
            readonly minLength: 1;
            readonly format: "uri";
            readonly title: "Url";
            readonly description: "A presigned URL for IO operations against a private file";
        };
        readonly expires_at: {
            readonly type: "string";
            readonly format: "date-time";
            readonly title: "Expires At";
            readonly description: "The time at which the presigned URL expires";
        };
        readonly form_fields: {
            readonly anyOf: readonly [{
                readonly additionalProperties: {
                    readonly type: "string";
                };
                readonly type: "object";
            }, {
                readonly type: "null";
            }];
            readonly title: "Form Fields";
            readonly description: "Form fields for a presigned POST request";
        };
    };
    readonly type: "object";
    readonly required: readonly ["url", "expires_at"];
    readonly title: "PresignedUrl";
    readonly description: "Schema for a presigned URL.";
};
declare const ProjectSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly ad_hoc_eval_dataset_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Ad Hoc Eval Dataset Id";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The Organization ID the project is under.";
        };
        readonly is_default: {
            readonly type: "boolean";
            readonly title: "Is Default";
            readonly description: "Whether this project is the default project for the user.";
            readonly default: false;
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "id", "organization_id"];
    readonly title: "Project";
    readonly description: "Schema for a project.";
};
declare const ProjectCreateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "ProjectCreate";
    readonly description: "Schema for creating a project.";
};
declare const ProjectUpdateSchema: {
    readonly properties: {
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name"];
    readonly title: "ProjectUpdate";
    readonly description: "Schema for updating a project.";
};
declare const PromptMixinPromptsSchema: {
    readonly properties: {
        readonly project_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Project Id";
            readonly description: "The ID of the project.";
        };
        readonly id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id";
            readonly description: "The ID of the prompt set.";
        };
        readonly name: {
            readonly type: "string";
            readonly title: "Name";
            readonly description: "The name of the prompt set.";
        };
        readonly prompts: {
            readonly items: {
                readonly $ref: "#/components/schemas/PromptSpec";
            };
            readonly type: "array";
            readonly title: "Prompts";
            readonly description: "The prompts.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["project_id", "name", "prompts"];
    readonly title: "PromptMixinPrompts";
    readonly description: "Schema for the prompts derived from the PromptMixin.";
};
declare const PromptSpecSchema: {
    readonly properties: {
        readonly prompt_key: {
            readonly type: "string";
            readonly title: "Prompt Key";
            readonly description: "The key of the prompt in the PromptMixin.";
        };
        readonly prompt_class: {
            readonly type: "string";
            readonly title: "Prompt Class";
            readonly description: "The class of the prompt (PromptTemplate or ChatPromptTemplate).";
        };
        readonly prompt_type: {
            readonly type: "string";
            readonly title: "Prompt Type";
            readonly description: "The type of prompt.";
        };
        readonly template: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Template";
            readonly description: "The template of the prompt.";
        };
        readonly message_templates: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly $ref: "#/components/schemas/ChatMessage";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Message Templates";
            readonly description: "The chat message templates of the prompt.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["prompt_key", "prompt_class", "prompt_type"];
    readonly title: "PromptSpec";
};
declare const PydanticProgramModeSchema: {
    readonly type: "string";
    readonly enum: readonly ["default", "openai", "llm", "function", "guidance", "lm-format-enforcer"];
    readonly title: "PydanticProgramMode";
    readonly description: "Pydantic program mode.";
};
declare const RelatedNodeInfoSchema: {
    readonly properties: {
        readonly node_id: {
            readonly type: "string";
            readonly title: "Node Id";
        };
        readonly node_type: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/ObjectType";
            }, {
                readonly type: "null";
            }];
        };
        readonly metadata: {
            readonly type: "object";
            readonly title: "Metadata";
        };
        readonly hash: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Hash";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "RelatedNodeInfo";
        };
    };
    readonly type: "object";
    readonly required: readonly ["node_id"];
    readonly title: "RelatedNodeInfo";
};
declare const RetrievalModeSchema: {
    readonly type: "string";
    readonly enum: readonly ["chunks", "files_via_metadata", "files_via_content", "auto_routed"];
    readonly title: "RetrievalMode";
};
declare const RetrievalParamsSchema: {
    readonly properties: {
        readonly dense_similarity_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Dense Similarity Top K";
            readonly description: "Number of nodes for dense retrieval.";
            readonly default: 30;
        };
        readonly sparse_similarity_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Sparse Similarity Top K";
            readonly description: "Number of nodes for sparse retrieval.";
            readonly default: 30;
        };
        readonly enable_reranking: {
            readonly anyOf: readonly [{
                readonly type: "boolean";
            }, {
                readonly type: "null";
            }];
            readonly title: "Enable Reranking";
            readonly description: "Enable reranking for retrieval";
        };
        readonly rerank_top_n: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 100;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Rerank Top N";
            readonly description: "Number of reranked nodes for returning.";
            readonly default: 3;
        };
        readonly alpha: {
            readonly anyOf: readonly [{
                readonly type: "number";
                readonly maximum: 1;
                readonly minimum: 0;
            }, {
                readonly type: "null";
            }];
            readonly title: "Alpha";
            readonly description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.";
        };
        readonly search_filters: {
            readonly anyOf: readonly [{
                readonly $ref: "#/components/schemas/MetadataFilters";
            }, {
                readonly type: "null";
            }];
            readonly description: "Search filters for retrieval.";
        };
        readonly files_top_k: {
            readonly anyOf: readonly [{
                readonly type: "integer";
                readonly maximum: 5;
                readonly minimum: 1;
            }, {
                readonly type: "null";
            }];
            readonly title: "Files Top K";
            readonly description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).";
            readonly default: 1;
        };
        readonly retrieval_mode: {
            readonly $ref: "#/components/schemas/RetrievalMode";
            readonly description: "The retrieval mode for the query.";
            readonly default: "auto_routed";
        };
        readonly retrieve_image_nodes: {
            readonly type: "boolean";
            readonly title: "Retrieve Image Nodes";
            readonly description: "Whether to retrieve image nodes.";
            readonly default: false;
        };
        readonly query: {
            readonly type: "string";
            readonly title: "Query";
            readonly description: "The query to retrieve against.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "base_component";
        };
    };
    readonly type: "object";
    readonly required: readonly ["query"];
    readonly title: "RetrievalParams";
    readonly description: "Schema for the search params for an retrieval execution.";
};
declare const RetrieveResultsSchema: {
    readonly properties: {
        readonly pipeline_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Pipeline Id";
            readonly description: "The ID of the pipeline that the query was retrieved against.";
        };
        readonly retrieval_nodes: {
            readonly items: {
                readonly $ref: "#/components/schemas/TextNodeWithScore";
            };
            readonly type: "array";
            readonly title: "Retrieval Nodes";
            readonly description: "The nodes retrieved by the pipeline for the given query.";
        };
        readonly image_nodes: {
            readonly items: {
                readonly $ref: "#/components/schemas/PageScreenshotNodeWithScore";
            };
            readonly type: "array";
            readonly title: "Image Nodes";
            readonly description: "The image nodes retrieved by the pipeline for the given query.";
        };
        readonly retrieval_latency: {
            readonly additionalProperties: {
                readonly type: "number";
            };
            readonly type: "object";
            readonly title: "Retrieval Latency";
            readonly description: "The end-to-end latency for retrieval and reranking.";
        };
        readonly metadata: {
            readonly additionalProperties: {
                readonly type: "string";
            };
            readonly type: "object";
            readonly title: "Metadata";
            readonly description: "Metadata associated with the retrieval execution";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "RetrieveResults";
        };
    };
    readonly type: "object";
    readonly required: readonly ["pipeline_id", "retrieval_nodes", "retrieval_latency"];
    readonly title: "RetrieveResults";
    readonly description: "Schema for the result of an retrieval execution.";
};
declare const RoleSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly name: {
            readonly type: "string";
            readonly maxLength: 3000;
            readonly minLength: 1;
            readonly title: "Name";
            readonly description: "A name for the role.";
        };
        readonly organization_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
        readonly permissions: {
            readonly items: {
                readonly $ref: "#/components/schemas/Permission";
            };
            readonly type: "array";
            readonly title: "Permissions";
            readonly description: "The actual permissions of the role.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "name", "organization_id", "permissions"];
    readonly title: "Role";
    readonly description: "Schema for a role.";
};
declare const SemanticChunkingConfigSchema: {
    readonly properties: {
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["semantic"];
            readonly const: "semantic";
            readonly title: "Mode";
            readonly default: "semantic";
        };
        readonly buffer_size: {
            readonly type: "integer";
            readonly title: "Buffer Size";
            readonly default: 1;
        };
        readonly breakpoint_percentile_threshold: {
            readonly type: "integer";
            readonly title: "Breakpoint Percentile Threshold";
            readonly default: 95;
        };
    };
    readonly type: "object";
    readonly title: "SemanticChunkingConfig";
};
declare const SentenceChunkingConfigSchema: {
    readonly properties: {
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly default: 200;
            readonly gte: 0;
        };
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["sentence"];
            readonly const: "sentence";
            readonly title: "Mode";
            readonly default: "sentence";
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly default: " ";
        };
        readonly paragraph_separator: {
            readonly type: "string";
            readonly title: "Paragraph Separator";
            readonly default: "\n\n\n";
        };
    };
    readonly type: "object";
    readonly title: "SentenceChunkingConfig";
};
declare const SentenceSplitterSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "The token chunk size for each chunk.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "Chunk Overlap";
            readonly description: "The token overlap of each chunk when splitting.";
            readonly default: 200;
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly description: "Default separator for splitting into words";
            readonly default: " ";
        };
        readonly paragraph_separator: {
            readonly type: "string";
            readonly title: "Paragraph Separator";
            readonly description: "Separator between paragraphs.";
            readonly default: "\n\n\n";
        };
        readonly secondary_chunking_regex: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Secondary Chunking Regex";
            readonly description: "Backup regex for splitting into sentences.";
            readonly default: "[^,.;。？！]+[,.;。？！]?";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "SentenceSplitter";
        };
    };
    readonly type: "object";
    readonly title: "SentenceSplitter";
    readonly description: "Parse text with a preference for complete sentences.\n\nIn general, this class tries to keep sentences and paragraphs together. Therefore\ncompared to the original TokenTextSplitter, there are less likely to be\nhanging sentences or parts of sentences at the end of the node chunk.";
};
declare const StatusEnumSchema: {
    readonly type: "string";
    readonly enum: readonly ["PENDING", "SUCCESS", "ERROR", "PARTIAL_SUCCESS"];
    readonly title: "StatusEnum";
    readonly description: "Enum for representing the status of a job";
};
declare const SupportedLLMModelSchema: {
    readonly properties: {
        readonly name: {
            readonly $ref: "#/components/schemas/SupportedLLMModelNames";
            readonly description: "The name of the supported LLM model.";
        };
        readonly enabled: {
            readonly type: "boolean";
            readonly title: "Enabled";
            readonly description: "Whether the LLM model is enabled for use in LlamaCloud.";
            readonly default: true;
        };
        readonly details: {
            readonly $ref: "#/components/schemas/LLMModelData";
            readonly description: "The details of the supported LLM model.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["name", "details"];
    readonly title: "SupportedLLMModel";
    readonly description: "Response Schema for a supported eval LLM model.";
};
declare const SupportedLLMModelNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["GPT_3_5_TURBO", "GPT_4", "GPT_4_TURBO", "GPT_4O", "GPT_4O_MINI", "AZURE_OPENAI"];
    readonly title: "SupportedLLMModelNames";
};
declare const TextNodeSchema: {
    readonly properties: {
        readonly id_: {
            readonly type: "string";
            readonly title: "Id ";
            readonly description: "Unique ID of the node.";
        };
        readonly embedding: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly type: "number";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Embedding";
            readonly description: "Embedding of the node.";
        };
        readonly extra_info: {
            readonly type: "object";
            readonly title: "Extra Info";
            readonly description: "A flat dictionary of metadata fields";
        };
        readonly excluded_embed_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Embed Metadata Keys";
            readonly description: "Metadata keys that are excluded from text for the embed model.";
        };
        readonly excluded_llm_metadata_keys: {
            readonly items: {
                readonly type: "string";
            };
            readonly type: "array";
            readonly title: "Excluded Llm Metadata Keys";
            readonly description: "Metadata keys that are excluded from text for the LLM.";
        };
        readonly relationships: {
            readonly additionalProperties: {
                readonly anyOf: readonly [{
                    readonly $ref: "#/components/schemas/RelatedNodeInfo";
                }, {
                    readonly items: {
                        readonly $ref: "#/components/schemas/RelatedNodeInfo";
                    };
                    readonly type: "array";
                }];
            };
            readonly type: "object";
            readonly title: "Relationships";
            readonly description: "A mapping of relationships to other node information.";
        };
        readonly text: {
            readonly type: "string";
            readonly title: "Text";
            readonly description: "Text content of the node.";
            readonly default: "";
        };
        readonly mimetype: {
            readonly type: "string";
            readonly title: "Mimetype";
            readonly description: "MIME type of the node content.";
            readonly default: "text/plain";
        };
        readonly start_char_idx: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Start Char Idx";
            readonly description: "Start char index of the node.";
        };
        readonly end_char_idx: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "End Char Idx";
            readonly description: "End char index of the node.";
        };
        readonly text_template: {
            readonly type: "string";
            readonly title: "Text Template";
            readonly description: "Template for how text is formatted, with {content} and {metadata_str} placeholders.";
            readonly default: "{metadata_str}\n\n{content}";
        };
        readonly metadata_template: {
            readonly type: "string";
            readonly title: "Metadata Template";
            readonly description: "Template for how metadata is formatted, with {key} and {value} placeholders.";
            readonly default: "{key}: {value}";
        };
        readonly metadata_seperator: {
            readonly type: "string";
            readonly title: "Metadata Seperator";
            readonly description: "Separator between metadata fields when converting to string.";
            readonly default: "\n";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "TextNode";
        };
    };
    readonly type: "object";
    readonly title: "TextNode";
};
declare const TextNodeWithScoreSchema: {
    readonly properties: {
        readonly node: {
            readonly $ref: "#/components/schemas/TextNode";
        };
        readonly score: {
            readonly anyOf: readonly [{
                readonly type: "number";
            }, {
                readonly type: "null";
            }];
            readonly title: "Score";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "TextNodeWithScore";
        };
    };
    readonly type: "object";
    readonly required: readonly ["node"];
    readonly title: "TextNodeWithScore";
    readonly description: "Same as NodeWithScore but type for node is a TextNode instead of BaseNode.\nFastAPI doesn't accept abstract classes like BaseNode.";
};
declare const TokenChunkingConfigSchema: {
    readonly properties: {
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly title: "Chunk Overlap";
            readonly default: 200;
            readonly gte: 0;
        };
        readonly mode: {
            readonly type: "string";
            readonly enum: readonly ["token"];
            readonly const: "token";
            readonly title: "Mode";
            readonly default: "token";
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly default: " ";
        };
    };
    readonly type: "object";
    readonly title: "TokenChunkingConfig";
};
declare const TokenTextSplitterSchema: {
    readonly properties: {
        readonly include_metadata: {
            readonly type: "boolean";
            readonly title: "Include Metadata";
            readonly description: "Whether or not to consider metadata when splitting.";
            readonly default: true;
        };
        readonly include_prev_next_rel: {
            readonly type: "boolean";
            readonly title: "Include Prev Next Rel";
            readonly description: "Include prev/next node relationships.";
            readonly default: true;
        };
        readonly callback_manager: {
            readonly title: "Callback Manager";
        };
        readonly id_func: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Id Func";
            readonly description: "Function to generate node IDs.";
        };
        readonly chunk_size: {
            readonly type: "integer";
            readonly exclusiveMinimum: 0;
            readonly title: "Chunk Size";
            readonly description: "The token chunk size for each chunk.";
            readonly default: 1024;
        };
        readonly chunk_overlap: {
            readonly type: "integer";
            readonly minimum: 0;
            readonly title: "Chunk Overlap";
            readonly description: "The token overlap of each chunk when splitting.";
            readonly default: 20;
        };
        readonly separator: {
            readonly type: "string";
            readonly title: "Separator";
            readonly description: "Default separator for splitting into words";
            readonly default: " ";
        };
        readonly backup_separators: {
            readonly items: {};
            readonly type: "array";
            readonly title: "Backup Separators";
            readonly description: "Additional separators for splitting.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "TokenTextSplitter";
        };
    };
    readonly type: "object";
    readonly title: "TokenTextSplitter";
    readonly description: "Implementation of splitting text that looks at word tokens.";
};
declare const TransformationCategoryNamesSchema: {
    readonly type: "string";
    readonly enum: readonly ["NODE_PARSER", "EMBEDDING"];
    readonly title: "TransformationCategoryNames";
};
declare const UserOrganizationSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly email: {
            readonly type: "string";
            readonly format: "email";
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
        readonly user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
        readonly pending: {
            readonly type: "boolean";
            readonly title: "Pending";
            readonly description: "Whether the user's membership is pending account signup.";
            readonly default: true;
        };
        readonly invited_by_user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Invited By User Id";
            readonly description: "The user ID of the user who added the user to the organization.";
        };
        readonly invited_by_user_email: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "email";
            }, {
                readonly type: "null";
            }];
            readonly title: "Invited By User Email";
            readonly description: "The email address of the user who added the user to the organization.";
        };
        readonly roles: {
            readonly items: {
                readonly $ref: "#/components/schemas/UserOrganizationRole";
            };
            readonly type: "array";
            readonly title: "Roles";
            readonly description: "The roles of the user in the organization.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "email", "organization_id", "roles"];
    readonly title: "UserOrganization";
    readonly description: "Schema for a user's membership to an organization.";
};
declare const UserOrganizationCreateSchema: {
    readonly properties: {
        readonly user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly email: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "email";
            }, {
                readonly type: "null";
            }];
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
        readonly project_ids: {
            readonly anyOf: readonly [{
                readonly items: {
                    readonly type: "string";
                    readonly format: "uuid";
                };
                readonly type: "array";
            }, {
                readonly type: "null";
            }];
            readonly title: "Project Ids";
            readonly description: "The project IDs to add the user to.";
        };
        readonly role_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "uuid";
            }, {
                readonly type: "null";
            }];
            readonly title: "Role Id";
            readonly description: "The role ID to assign to the user.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["project_ids"];
    readonly title: "UserOrganizationCreate";
    readonly description: "Schema for creating a user's membership to an organization.";
};
declare const UserOrganizationDeleteSchema: {
    readonly properties: {
        readonly user_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly email: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "email";
            }, {
                readonly type: "null";
            }];
            readonly title: "Email";
            readonly description: "The user's email address.";
        };
    };
    readonly type: "object";
    readonly title: "UserOrganizationDelete";
    readonly description: "Schema for deleting a user's membership to an organization.";
};
declare const UserOrganizationRoleSchema: {
    readonly properties: {
        readonly id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Id";
            readonly description: "Unique identifier";
        };
        readonly created_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Created At";
            readonly description: "Creation datetime";
        };
        readonly updated_at: {
            readonly anyOf: readonly [{
                readonly type: "string";
                readonly format: "date-time";
            }, {
                readonly type: "null";
            }];
            readonly title: "Updated At";
            readonly description: "Update datetime";
        };
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
        readonly role_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Role Id";
            readonly description: "The role's ID.";
        };
        readonly role: {
            readonly $ref: "#/components/schemas/Role";
            readonly description: "The role.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["id", "user_id", "organization_id", "role_id", "role"];
    readonly title: "UserOrganizationRole";
    readonly description: "Schema for a user's role in an organization.";
};
declare const UserOrganizationRoleCreateSchema: {
    readonly properties: {
        readonly user_id: {
            readonly type: "string";
            readonly title: "User Id";
            readonly description: "The user's ID.";
        };
        readonly organization_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Organization Id";
            readonly description: "The organization's ID.";
        };
        readonly role_id: {
            readonly type: "string";
            readonly format: "uuid";
            readonly title: "Role Id";
            readonly description: "The role's ID.";
        };
    };
    readonly type: "object";
    readonly required: readonly ["user_id", "organization_id", "role_id"];
    readonly title: "UserOrganizationRoleCreate";
    readonly description: "Schema for creating a user's role in an organization.";
};
declare const ValidationErrorSchema: {
    readonly properties: {
        readonly loc: {
            readonly items: {
                readonly anyOf: readonly [{
                    readonly type: "string";
                }, {
                    readonly type: "integer";
                }];
            };
            readonly type: "array";
            readonly title: "Location";
        };
        readonly msg: {
            readonly type: "string";
            readonly title: "Message";
        };
        readonly type: {
            readonly type: "string";
            readonly title: "Error Type";
        };
    };
    readonly type: "object";
    readonly required: readonly ["loc", "msg", "type"];
    readonly title: "ValidationError";
};
declare const VertexAIEmbeddingConfigSchema: {
    readonly properties: {
        readonly type: {
            readonly type: "string";
            readonly enum: readonly ["VERTEXAI_EMBEDDING"];
            readonly const: "VERTEXAI_EMBEDDING";
            readonly title: "Type";
            readonly description: "Type of the embedding model.";
            readonly default: "VERTEXAI_EMBEDDING";
        };
        readonly component: {
            readonly $ref: "#/components/schemas/VertexTextEmbedding";
            readonly description: "Configuration for the VertexAI embedding model.";
        };
    };
    readonly type: "object";
    readonly title: "VertexAIEmbeddingConfig";
};
declare const VertexEmbeddingModeSchema: {
    readonly type: "string";
    readonly enum: readonly ["default", "classification", "clustering", "similarity", "retrieval"];
    readonly title: "VertexEmbeddingMode";
    readonly description: "Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode\nsince importing llama_index.embeddings.vertex.base incurs a lot of memory usage.";
};
declare const VertexTextEmbeddingSchema: {
    readonly properties: {
        readonly model_name: {
            readonly type: "string";
            readonly title: "Model Name";
            readonly description: "The modelId of the VertexAI model to use.";
            readonly default: "textembedding-gecko@003";
        };
        readonly embed_batch_size: {
            readonly type: "integer";
            readonly maximum: 2048;
            readonly exclusiveMinimum: 0;
            readonly title: "Embed Batch Size";
            readonly description: "The batch size for embedding calls.";
            readonly default: 10;
        };
        readonly num_workers: {
            readonly anyOf: readonly [{
                readonly type: "integer";
            }, {
                readonly type: "null";
            }];
            readonly title: "Num Workers";
            readonly description: "The number of workers to use for async embedding calls.";
        };
        readonly location: {
            readonly type: "string";
            readonly title: "Location";
            readonly description: "The default location to use when making API calls.";
        };
        readonly project: {
            readonly type: "string";
            readonly title: "Project";
            readonly description: "The default GCP project to use when making Vertex API calls.";
        };
        readonly embed_mode: {
            readonly $ref: "#/components/schemas/VertexEmbeddingMode";
            readonly description: "The embedding mode to use.";
            readonly default: "retrieval";
        };
        readonly additional_kwargs: {
            readonly type: "object";
            readonly title: "Additional Kwargs";
            readonly description: "Additional kwargs for the Vertex.";
        };
        readonly client_email: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Client Email";
            readonly description: "The client email for the VertexAI credentials.";
        };
        readonly token_uri: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Token Uri";
            readonly description: "The token URI for the VertexAI credentials.";
        };
        readonly private_key_id: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Private Key Id";
            readonly description: "The private key ID for the VertexAI credentials.";
        };
        readonly private_key: {
            readonly anyOf: readonly [{
                readonly type: "string";
            }, {
                readonly type: "null";
            }];
            readonly title: "Private Key";
            readonly description: "The private key for the VertexAI credentials.";
        };
        readonly class_name: {
            readonly type: "string";
            readonly title: "Class Name";
            readonly default: "VertexTextEmbedding";
        };
    };
    readonly type: "object";
    readonly required: readonly ["location", "project", "client_email", "token_uri", "private_key_id", "private_key"];
    readonly title: "VertexTextEmbedding";
};

/**
 * Schema for an API Key.
 */
type APIKey = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    name?: string | null;
    user_id: string;
    redacted_api_key: string;
};
/**
 * Schema for creating an API key.
 */
type APIKeyCreate = {
    name?: string | null;
};
/**
 * Schema for updating an API key.
 */
type APIKeyUpdate = {
    name?: string | null;
};
type AdvancedModeTransformConfig = {
    mode?: "advanced";
    /**
     * Configuration for the segmentation.
     */
    segmentation_config?: NoneSegmentationConfig | PageSegmentationConfig | ElementSegmentationConfig;
    /**
     * Configuration for the chunking.
     */
    chunking_config?: NoneChunkingConfig | CharacterChunkingConfig | TokenChunkingConfig | SentenceChunkingConfig | SemanticChunkingConfig;
};
type mode = "advanced";
declare const mode: {
    readonly ADVANCED: "advanced";
};
type AutoTransformConfig = {
    mode?: "auto";
    /**
     * Chunk size for the transformation.
     */
    chunk_size?: number;
    /**
     * Chunk overlap for the transformation.
     */
    chunk_overlap?: number;
};
type mode2 = "auto";
declare const mode2: {
    readonly AUTO: "auto";
};
type AzureOpenAIEmbedding = {
    /**
     * The name of the OpenAI embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * Additional kwargs for the OpenAI API.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    /**
     * The OpenAI API key.
     */
    api_key?: string | null;
    /**
     * The base URL for Azure deployment.
     */
    api_base?: string;
    /**
     * The version for Azure OpenAI API.
     */
    api_version?: string;
    /**
     * Maximum number of retries.
     */
    max_retries?: number;
    /**
     * Timeout for each request.
     */
    timeout?: number;
    /**
     * The default headers for API requests.
     */
    default_headers?: {
        [key: string]: string;
    } | null;
    /**
     * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
     */
    reuse_client?: boolean;
    /**
     * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
     */
    dimensions?: number | null;
    /**
     * The Azure endpoint to use.
     */
    azure_endpoint?: string | null;
    /**
     * The Azure deployment to use.
     */
    azure_deployment?: string | null;
    class_name?: string;
};
type AzureOpenAIEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "AZURE_EMBEDDING";
    /**
     * Configuration for the Azure OpenAI embedding model.
     */
    component?: AzureOpenAIEmbedding;
};
/**
 * Type of the embedding model.
 */
type type = "AZURE_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type: {
    readonly AZURE_EMBEDDING: "AZURE_EMBEDDING";
};
type Base = {
    [key: string]: unknown;
};
/**
 * Base response model for connection validation.
 */
type BaseConnectionValidation = {
    success: boolean;
    message: string;
};
type BasePromptTemplate = {
    metadata: {
        [key: string]: unknown;
    };
    template_vars: Array<string>;
    kwargs: {
        [key: string]: string;
    };
    output_parser: unknown | null;
    /**
     * Template variable mappings (Optional).
     */
    template_var_mappings?: {
        [key: string]: unknown;
    } | null;
    /**
     * Function mappings (Optional). This is a mapping from template variable names to functions that take in the current kwargs and return a string.
     */
    function_mappings?: {
        [key: string]: string;
    } | null;
};
type BedrockEmbedding = {
    /**
     * The modelId of the Bedrock model to use.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * The name of aws profile to use. If not given, then the default profile is used.
     */
    profile_name?: string | null;
    /**
     * AWS Access Key ID to use
     */
    aws_access_key_id?: string | null;
    /**
     * AWS Secret Access Key to use
     */
    aws_secret_access_key?: string | null;
    /**
     * AWS Session Token to use
     */
    aws_session_token?: string | null;
    /**
     * AWS region name to use. Uses region configured in AWS CLI if not passed
     */
    region_name?: string | null;
    /**
     * The maximum number of API retries.
     */
    max_retries?: number;
    /**
     * The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.
     */
    timeout?: number;
    /**
     * Additional kwargs for the bedrock client.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
type BedrockEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "BEDROCK_EMBEDDING";
    /**
     * Configuration for the Bedrock embedding model.
     */
    component?: BedrockEmbedding;
};
/**
 * Type of the embedding model.
 */
type type2 = "BEDROCK_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type2: {
    readonly BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING";
};
type Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put = {
    upload_file: Blob | File;
};
type Body_upload_file_api_parsing_upload_post = {
    language?: Array<ParserLanguages>;
    parsing_instruction?: string;
    skip_diagonal_text?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    gpt4o_mode?: boolean;
    fast_mode?: boolean;
    premium_mode?: boolean;
    continuous_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: boolean;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
    webhook_url?: string;
    take_screenshot?: boolean;
    is_formatting_instruction?: boolean;
    disable_ocr?: boolean;
    annotate_links?: boolean;
    disable_reconstruction?: boolean;
    input_s3_path?: string;
    output_s3_path_prefix?: string;
    azure_openai_deployment_name?: string;
    azure_openai_endpoint?: string;
    azure_openai_api_version?: string;
    azure_openai_key?: string;
    file?: (Blob | File) | null;
};
type Body_upload_file_api_v1_files_post = {
    upload_file: Blob | File;
};
type Body_upload_file_api_v1_parsing_upload_post = {
    language?: Array<ParserLanguages>;
    parsing_instruction?: string;
    skip_diagonal_text?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    gpt4o_mode?: boolean;
    fast_mode?: boolean;
    premium_mode?: boolean;
    continuous_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: boolean;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
    webhook_url?: string;
    take_screenshot?: boolean;
    is_formatting_instruction?: boolean;
    disable_ocr?: boolean;
    annotate_links?: boolean;
    disable_reconstruction?: boolean;
    input_s3_path?: string;
    output_s3_path_prefix?: string;
    azure_openai_deployment_name?: string;
    azure_openai_endpoint?: string;
    azure_openai_api_version?: string;
    azure_openai_key?: string;
    file?: (Blob | File) | null;
};
type BoxAuthMechanism = "developer_token" | "ccg";
declare const BoxAuthMechanism: {
    readonly DEVELOPER_TOKEN: "developer_token";
    readonly CCG: "ccg";
};
type CharacterChunkingConfig = {
    chunk_size?: number;
    chunk_overlap?: number;
    mode?: "character";
};
type mode3 = "character";
declare const mode3: {
    readonly CHARACTER: "character";
};
/**
 * A splitter that splits text into characters.
 */
type CharacterSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * The token chunk size for each chunk.
     */
    chunk_size?: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunk_overlap?: number;
    /**
     * Default separator for splitting into words
     */
    separator?: string;
    /**
     * Separator between paragraphs.
     */
    paragraph_separator?: string;
    /**
     * Backup regex for splitting into sentences.
     */
    secondary_chunking_regex?: string | null;
    class_name?: string;
};
type ChatData = {
    retrieval_parameters?: PresetRetrievalParams;
    llm_parameters?: LLMParameters | null;
    class_name?: string;
};
type ChatInputParams = {
    messages?: Array<InputMessage>;
    data?: ChatData;
    class_name?: string;
};
type ChatMessage = {
    id: string;
    /**
     * The index of the message in the chat.
     */
    index: number;
    /**
     * Retrieval annotations for the message.
     */
    annotations?: Array<MessageAnnotation>;
    role: MessageRole;
    /**
     * Text content of the generation
     */
    content?: string | null;
    /**
     * Additional arguments passed to the model
     */
    additional_kwargs?: {
        [key: string]: string;
    };
    class_name?: string;
};
type CheckoutSessionCreatePayload = {
    success_url: string;
    cancel_url: string;
};
type CloudAzStorageBlobDataSource = {
    /**
     * The name of the Azure Storage Blob container to read from.
     */
    container_name: string;
    /**
     * The Azure Storage Blob account URL to use for authentication.
     */
    account_url: string;
    /**
     * The blob name to read from.
     */
    blob?: string | null;
    /**
     * The prefix of the Azure Storage Blob objects to read from.
     */
    prefix?: string | null;
    /**
     * The Azure Storage Blob account name to use for authentication.
     */
    account_name?: string | null;
    /**
     * The Azure Storage Blob account key to use for authentication.
     */
    account_key?: string | null;
    /**
     * The Azure AD tenant ID to use for authentication.
     */
    tenant_id?: string | null;
    /**
     * The Azure AD client ID to use for authentication.
     */
    client_id?: string | null;
    /**
     * The Azure AD client secret to use for authentication.
     */
    client_secret?: string | null;
    class_name?: string;
};
/**
 * Cloud Azure AI Search Vector Store.
 */
type CloudAzureAISearchVectorStore = {
    supports_nested_metadata_filters?: true;
    search_service_api_key: string;
    search_service_endpoint: string;
    search_service_api_version?: string | null;
    index_name?: string | null;
    filterable_metadata_field_keys?: {
        [key: string]: unknown;
    } | null;
    embedding_dimension?: number | null;
    client_id?: string | null;
    client_secret?: string | null;
    tenant_id?: string | null;
    class_name?: string;
};
type CloudBoxDataSource = {
    /**
     * The ID of the Box folder to read from.
     */
    folder_id?: string | null;
    /**
     * The type of authentication to use (Developer Token or CCG)
     */
    authentication_mechanism: BoxAuthMechanism;
    /**
     * Developer token for authentication if authentication_mechanism is 'developer_token'.
     */
    developer_token?: string | null;
    /**
     * Box API key used for identifying the application the user is authenticating with
     */
    client_id?: string | null;
    /**
     * Box API secret used for making auth requests.
     */
    client_secret?: string | null;
    /**
     * Box User ID, if provided authenticates as user.
     */
    user_id?: string | null;
    /**
     * Box Enterprise ID, if provided authenticates as service.
     */
    enterprise_id?: string | null;
    class_name?: string;
};
type CloudConfluenceDataSource = {
    /**
     * The server URL of the Confluence instance.
     */
    server_url: string;
    /**
     * Type of Authentication for connecting to Confluence APIs.
     */
    authentication_mechanism: string;
    /**
     * The username to use for authentication.
     */
    user_name?: string | null;
    /**
     * The API token to use for authentication.
     */
    api_token?: string | null;
    /**
     * The space key to read from.
     */
    space_key?: string | null;
    /**
     * The page IDs of the Confluence to read from.
     */
    page_ids?: string | null;
    /**
     * The CQL query to use for fetching pages.
     */
    cql?: string | null;
    /**
     * The label to use for fetching pages.
     */
    label?: string | null;
    class_name?: string;
};
/**
 * Cloud document stored in S3.
 */
type CloudDocument = {
    text: string;
    metadata: {
        [key: string]: unknown;
    };
    excluded_embed_metadata_keys?: Array<string>;
    excluded_llm_metadata_keys?: Array<string>;
    /**
     * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
     */
    page_positions?: Array<number> | null;
    id: string;
};
/**
 * Create a new cloud document.
 */
type CloudDocumentCreate = {
    text: string;
    metadata: {
        [key: string]: unknown;
    };
    excluded_embed_metadata_keys?: Array<string>;
    excluded_llm_metadata_keys?: Array<string>;
    /**
     * indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1].
     */
    page_positions?: Array<number> | null;
    id?: string | null;
};
type CloudGoogleDriveDataSource = {
    /**
     * The ID of the Google Drive folder to read from.
     */
    folder_id: string;
    /**
     * The service account key JSON to use for authentication.
     */
    service_account_key: {
        [key: string]: unknown;
    };
    class_name?: string;
};
/**
 * Cloud Jira Data Source integrating JiraReader.
 */
type CloudJiraDataSource = {
    /**
     * The email address to use for authentication.
     */
    email?: string | null;
    /**
     * The API/ Access Token used for Basic, PAT and OAuth2 authentication.
     */
    api_token?: string | null;
    /**
     * The server url for Jira Cloud.
     */
    server_url?: string | null;
    /**
     * The cloud ID, used in case of OAuth2.
     */
    cloud_id?: string | null;
    /**
     * Type of Authentication for connecting to Jira APIs.
     */
    authentication_mechanism: string;
    /**
     * JQL (Jira Query Language) query to search.
     */
    query: string;
    class_name?: string;
};
/**
 * Cloud Milvus Vector Store.
 */
type CloudMilvusVectorStore = {
    supports_nested_metadata_filters?: false;
    uri: string;
    collection_name?: string | null;
    token?: string | null;
    embedding_dimension?: number | null;
    class_name?: string;
};
/**
 * Cloud MongoDB Atlas Vector Store.
 *
 * This class is used to store the configuration for a MongoDB Atlas vector store,
 * so that it can be created and used in LlamaCloud.
 *
 * Args:
 * mongodb_uri (str): URI for connecting to MongoDB Atlas
 * db_name (str): name of the MongoDB database
 * collection_name (str): name of the MongoDB collection
 * vector_index_name (str): name of the MongoDB Atlas vector index
 * fulltext_index_name (str): name of the MongoDB Atlas full-text index
 */
type CloudMongoDBAtlasVectorSearch = {
    supports_nested_metadata_filters?: false;
    mongodb_uri: string;
    db_name: string;
    collection_name: string;
    vector_index_name?: string | null;
    fulltext_index_name?: string | null;
    class_name?: string;
};
type CloudNotionPageDataSource = {
    /**
     * The integration token to use for authentication.
     */
    integration_token: string;
    /**
     * The Notion Database Id to read content from.
     */
    database_ids?: string | null;
    /**
     * The Page ID's of the Notion to read from.
     */
    page_ids?: string | null;
    class_name?: string;
};
type CloudOneDriveDataSource = {
    /**
     * The user principal name to use for authentication.
     */
    user_principal_name: string;
    /**
     * The path of the OneDrive folder to read from.
     */
    folder_path?: string | null;
    /**
     * The ID of the OneDrive folder to read from.
     */
    folder_id?: string | null;
    /**
     * The client ID to use for authentication.
     */
    client_id: string;
    /**
     * The client secret to use for authentication.
     */
    client_secret: string;
    /**
     * The tenant ID to use for authentication.
     */
    tenant_id: string;
    class_name?: string;
};
/**
 * Cloud Pinecone Vector Store.
 *
 * This class is used to store the configuration for a Pinecone vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * api_key (str): API key for authenticating with Pinecone
 * index_name (str): name of the Pinecone index
 * namespace (optional[str]): namespace to use in the Pinecone index
 * insert_kwargs (optional[dict]): additional kwargs to pass during insertion
 */
type CloudPineconeVectorStore = {
    supports_nested_metadata_filters?: true;
    /**
     * The API key for authenticating with Pinecone
     */
    api_key: string;
    index_name: string;
    namespace?: string | null;
    insert_kwargs?: {
        [key: string]: unknown;
    } | null;
    class_name?: string;
};
type CloudPostgresVectorStore = {
    supports_nested_metadata_filters?: false;
    database: string;
    host: string;
    password: string;
    port: string;
    user: string;
    table_name: string;
    schema_name: string;
    embed_dim: number;
    hybrid_search?: boolean | null;
    class_name?: string;
};
/**
 * Cloud Qdrant Vector Store.
 *
 * This class is used to store the configuration for a Qdrant vector store, so that it can be
 * created and used in LlamaCloud.
 *
 * Args:
 * collection_name (str): name of the Qdrant collection
 * url (str): url of the Qdrant instance
 * api_key (str): API key for authenticating with Qdrant
 * max_retries (int): maximum number of retries in case of a failure. Defaults to 3
 * client_kwargs (dict): additional kwargs to pass to the Qdrant client
 */
type CloudQdrantVectorStore = {
    supports_nested_metadata_filters?: true;
    collection_name: string;
    url: string;
    api_key: string;
    max_retries?: number;
    client_kwargs?: {
        [key: string]: unknown;
    };
    class_name?: string;
};
type CloudS3DataSource = {
    /**
     * The name of the S3 bucket to read from.
     */
    bucket: string;
    /**
     * The prefix of the S3 objects to read from.
     */
    prefix?: string | null;
    /**
     * The AWS access ID to use for authentication.
     */
    aws_access_id?: string | null;
    /**
     * The AWS access secret to use for authentication.
     */
    aws_access_secret?: string | null;
    /**
     * The S3 endpoint URL to use for authentication.
     */
    s3_endpoint_url?: string | null;
    class_name?: string;
};
type CloudSharepointDataSource = {
    /**
     * The name of the SharePoint site to download from.
     */
    site_name?: string | null;
    /**
     * The ID of the SharePoint site to download from.
     */
    site_id?: string | null;
    /**
     * The path of the Sharepoint folder to read from.
     */
    folder_path?: string | null;
    /**
     * The ID of the Sharepoint folder to read from.
     */
    folder_id?: string | null;
    /**
     * The name of the Sharepoint drive to read from.
     */
    drive_name?: string | null;
    /**
     * The client ID to use for authentication.
     */
    client_id: string;
    /**
     * The client secret to use for authentication.
     */
    client_secret: string;
    /**
     * The tenant ID to use for authentication.
     */
    tenant_id: string;
    class_name?: string;
};
type CloudSlackDataSource = {
    /**
     * Slack Bot Token.
     */
    slack_token: string;
    /**
     * Slack Channel.
     */
    channel_ids?: string | null;
    /**
     * Latest date.
     */
    latest_date?: string | null;
    /**
     * Earliest date.
     */
    earliest_date?: string | null;
    /**
     * Earliest date timestamp.
     */
    earliest_date_timestamp?: number | null;
    /**
     * Latest date timestamp.
     */
    latest_date_timestamp?: number | null;
    /**
     * Slack Channel name pattern.
     */
    channel_patterns?: string | null;
    class_name?: string;
};
/**
 * Split code using a AST parser.
 *
 * Thank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.
 * https://docs.sweep.dev/blogs/chunking-2m-files
 */
type CodeSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * The programming language of the code being split.
     */
    language: string;
    /**
     * The number of lines to include in each chunk.
     */
    chunk_lines?: number;
    /**
     * How many lines of code each chunk overlaps with.
     */
    chunk_lines_overlap?: number;
    /**
     * Maximum number of characters per chunk.
     */
    max_chars?: number;
    class_name?: string;
};
type CohereEmbedding = {
    /**
     * The modelId of the Cohere model to use.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * The Cohere API key.
     */
    api_key: string | null;
    /**
     * Truncation type - START/ END/ NONE
     */
    truncate?: string;
    /**
     * Model Input type. If not provided, search_document and search_query are used when needed.
     */
    input_type?: string | null;
    /**
     * Embedding type. If not provided float embedding_type is used when needed.
     */
    embedding_type?: string;
    class_name?: string;
};
type CohereEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "COHERE_EMBEDDING";
    /**
     * Configuration for the Cohere embedding model.
     */
    component?: CohereEmbedding;
};
/**
 * Type of the embedding model.
 */
type type3 = "COHERE_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type3: {
    readonly COHERE_EMBEDDING: "COHERE_EMBEDDING";
};
type ConfigurableDataSinkNames = "PINECONE" | "POSTGRES" | "QDRANT" | "AZUREAI_SEARCH" | "MONGODB_ATLAS" | "MILVUS";
declare const ConfigurableDataSinkNames: {
    readonly PINECONE: "PINECONE";
    readonly POSTGRES: "POSTGRES";
    readonly QDRANT: "QDRANT";
    readonly AZUREAI_SEARCH: "AZUREAI_SEARCH";
    readonly MONGODB_ATLAS: "MONGODB_ATLAS";
    readonly MILVUS: "MILVUS";
};
type ConfigurableDataSourceNames = "S3" | "AZURE_STORAGE_BLOB" | "GOOGLE_DRIVE" | "MICROSOFT_ONEDRIVE" | "MICROSOFT_SHAREPOINT" | "SLACK" | "NOTION_PAGE" | "CONFLUENCE" | "JIRA" | "BOX";
declare const ConfigurableDataSourceNames: {
    readonly S3: "S3";
    readonly AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB";
    readonly GOOGLE_DRIVE: "GOOGLE_DRIVE";
    readonly MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE";
    readonly MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT";
    readonly SLACK: "SLACK";
    readonly NOTION_PAGE: "NOTION_PAGE";
    readonly CONFLUENCE: "CONFLUENCE";
    readonly JIRA: "JIRA";
    readonly BOX: "BOX";
};
/**
 * Schema for a transformation definition.
 */
type ConfigurableTransformationDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of TransformationDefinition objects
     */
    configurable_transformation_type: ConfigurableTransformationNames;
    /**
     * The transformation_category field will be used to group transformations in the UI
     */
    transformation_category: TransformationCategoryNames;
};
type ConfigurableTransformationNames = "CHARACTER_SPLITTER" | "PAGE_SPLITTER_NODE_PARSER" | "CODE_NODE_PARSER" | "SENTENCE_AWARE_NODE_PARSER" | "TOKEN_AWARE_NODE_PARSER" | "MARKDOWN_NODE_PARSER" | "MARKDOWN_ELEMENT_NODE_PARSER";
declare const ConfigurableTransformationNames: {
    readonly CHARACTER_SPLITTER: "CHARACTER_SPLITTER";
    readonly PAGE_SPLITTER_NODE_PARSER: "PAGE_SPLITTER_NODE_PARSER";
    readonly CODE_NODE_PARSER: "CODE_NODE_PARSER";
    readonly SENTENCE_AWARE_NODE_PARSER: "SENTENCE_AWARE_NODE_PARSER";
    readonly TOKEN_AWARE_NODE_PARSER: "TOKEN_AWARE_NODE_PARSER";
    readonly MARKDOWN_NODE_PARSER: "MARKDOWN_NODE_PARSER";
    readonly MARKDOWN_ELEMENT_NODE_PARSER: "MARKDOWN_ELEMENT_NODE_PARSER";
};
/**
 * Configured transformations for pipelines.
 *
 * Similar to ConfigurableTransformation but includes a few
 * more fields that are useful to the platform.
 */
type ConfiguredTransformationItem = {
    id?: string;
    /**
     * Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames.
     */
    configurable_transformation_type: ConfigurableTransformationNames;
    /**
     * Component that implements the transformation
     */
    component: {
        [key: string]: unknown;
    } | CharacterSplitter | PageSplitterNodeParser | CodeSplitter | SentenceSplitter | TokenTextSplitter | MarkdownNodeParser | MarkdownElementNodeParser;
};
type CustomerPortalSessionCreatePayload = {
    return_url: string;
};
/**
 * Schema for a data sink.
 */
type DataSink = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The name of the data sink.
     */
    name: string;
    sink_type: ConfigurableDataSinkNames;
    component: {
        [key: string]: unknown;
    } | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudAzureAISearchVectorStore | CloudMongoDBAtlasVectorSearch | CloudMilvusVectorStore;
    project_id: string;
};
/**
 * Schema for creating a data sink.
 */
type DataSinkCreate = {
    /**
     * The name of the data sink.
     */
    name: string;
    sink_type: ConfigurableDataSinkNames;
    component: {
        [key: string]: unknown;
    } | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudAzureAISearchVectorStore | CloudMongoDBAtlasVectorSearch | CloudMilvusVectorStore;
};
/**
 * Schema for a data sink definition.
 */
type DataSinkDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of DataSinkDefinition objects
     */
    sink_type: ConfigurableDataSinkNames;
};
/**
 * Schema for updating a data sink.
 */
type DataSinkUpdate = {
    /**
     * The name of the data sink.
     */
    name?: string | null;
    sink_type: ConfigurableDataSinkNames;
    component?: {
        [key: string]: unknown;
    } | CloudPineconeVectorStore | CloudPostgresVectorStore | CloudQdrantVectorStore | CloudAzureAISearchVectorStore | CloudMongoDBAtlasVectorSearch | CloudMilvusVectorStore | null;
};
/**
 * Schema for a data source.
 */
type DataSource = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudGoogleDriveDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource | CloudBoxDataSource;
    project_id: string;
};
/**
 * Schema for creating a data source.
 */
type DataSourceCreate = {
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudGoogleDriveDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource | CloudBoxDataSource;
};
/**
 * Schema for a data source definition.
 */
type DataSourceDefinition = {
    /**
     * The label field will be used to display the name of the component in the UI
     */
    label: string;
    /**
     * The json_schema field can be used by clients to determine how to construct the component
     */
    json_schema: {
        [key: string]: unknown;
    };
    /**
     * The name field will act as the unique identifier of DataSourceDefinition objects
     */
    source_type: ConfigurableDataSourceNames;
};
/**
 * Schema for updating a data source.
 */
type DataSourceUpdate = {
    /**
     * The name of the data source.
     */
    name?: string | null;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    component?: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudGoogleDriveDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource | CloudBoxDataSource | null;
};
/**
 * Schema for updating the default organization for a user.
 */
type DefaultOrganizationUpdate = {
    /**
     * The organization's ID.
     */
    organization_id: string;
};
type ElementSegmentationConfig = {
    mode?: "element";
};
type mode4 = "element";
declare const mode4: {
    readonly ELEMENT: "element";
};
/**
 * Schema for an eval dataset.
 * Includes the other DB fields like id, created_at, & updated_at.
 */
type EvalDataset = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The name of the EvalDataset.
     */
    name: string;
    project_id: string;
};
/**
 * Schema for creating an eval dataset.
 */
type EvalDatasetCreate = {
    /**
     * The name of the EvalDataset.
     */
    name: string;
};
/**
 * Schema for the parameters of an eval dataset job.
 */
type EvalDatasetJobParams = {
    /**
     * The IDs for the EvalQuestions this execution ran against.
     */
    eval_question_ids: Array<string>;
    /**
     * The parameters for the eval execution.
     */
    eval_execution_params: EvalExecutionParams;
};
/**
 * Schema for job that evaluates an EvalDataset against a pipeline.
 */
type EvalDatasetJobRecord = {
    job_name: "eval_dataset_job";
    /**
     * The partitions for this execution. Used for determining where to save job output.
     */
    partitions: {
        [key: string]: string;
    };
    /**
     * Additional input parameters for the eval execution.
     */
    parameters?: EvalDatasetJobParams | null;
    /**
     * The upstream request ID that created this job. Used for tracking the job across services.
     */
    session_id?: string | null;
    /**
     * The correlation ID for this job. Used for tracking the job across services.
     */
    correlation_id?: string | null;
    /**
     * The ID of the parent job execution.
     */
    parent_job_execution_id?: string | null;
    /**
     * The ID of the user that created this job
     */
    user_id?: string | null;
    /**
     * Creation datetime
     */
    created_at?: string;
    /**
     * Unique identifier
     */
    id?: string;
    status: StatusEnum;
    error_code?: string | null;
    error_message?: string | null;
    /**
     * The number of times this job has been attempted
     */
    attempts?: number | null;
    started_at?: string | null;
    ended_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string;
    /**
     * Additional metadata for the job execution.
     */
    data?: Base | null;
};
type job_name = "eval_dataset_job";
declare const job_name: {
    readonly EVAL_DATASET_JOB: "eval_dataset_job";
};
/**
 * Schema for updating an eval dataset.
 * Only the name can be updated.
 */
type EvalDatasetUpdate = {
    /**
     * The name of the EvalDataset.
     */
    name: string;
};
/**
 * Schema for creating an eval execution for a given set of questions on a pipeline.
 */
type EvalExecutionCreate = {
    eval_question_ids: Array<string>;
    /**
     * The parameters for the eval execution that will override the ones set in the pipeline.
     */
    params?: EvalExecutionParamsOverride;
};
/**
 * Schema for the params for an eval execution.
 */
type EvalExecutionParams = {
    /**
     * The LLM model to use within eval execution.
     */
    llm_model?: SupportedLLMModelNames;
    /**
     * The template to use for the question answering prompt.
     */
    qa_prompt_tmpl?: string;
};
/**
 * Schema for the params override for an eval execution.
 */
type EvalExecutionParamsOverride = {
    /**
     * The LLM model to use within eval execution.
     */
    llm_model?: SupportedLLMModelNames | null;
    /**
     * The template to use for the question answering prompt.
     */
    qa_prompt_tmpl?: string | null;
};
type EvalMetric = "RELEVANCY" | "FAITHFULNESS";
declare const EvalMetric: {
    readonly RELEVANCY: "RELEVANCY";
    readonly FAITHFULNESS: "FAITHFULNESS";
};
type EvalQuestion = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The content of the question.
     */
    content: string;
    eval_dataset_id: string;
    /**
     * The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.
     */
    eval_dataset_index: number;
};
type EvalQuestionCreate = {
    /**
     * The content of the question.
     */
    content: string;
};
/**
 * Schema for the result of an eval question job.
 */
type EvalQuestionResult = {
    /**
     * The ID of the question that was executed.
     */
    eval_question_id: string;
    /**
     * The ID of the pipeline that the question was executed against.
     */
    pipeline_id: string;
    /**
     * The nodes retrieved by the pipeline for the given question.
     */
    source_nodes: Array<TextNode>;
    /**
     * The answer to the question.
     */
    answer: string;
    /**
     * The eval metrics for the question.
     */
    eval_metrics: {
        [key: string]: MetricResult;
    };
    /**
     * The ID of the EvalDatasetJobRecord that this result was generated from.
     */
    eval_dataset_execution_id: string;
    /**
     * The EvalExecutionParams that were used when this result was generated.
     */
    eval_dataset_execution_params: EvalExecutionParams;
    /**
     * The timestamp when the eval finished.
     */
    eval_finished_at: string;
    class_name?: string;
};
type ExtractionJob = {
    /**
     * The id of the extraction job
     */
    id: string;
    /**
     * The status of the extraction job
     */
    status: StatusEnum;
    /**
     * The file that the extract was extracted from
     */
    file: File;
};
/**
 * Schema for creating an extraction job.
 */
type ExtractionJobCreate = {
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The id of the file
     */
    file_id: string;
};
/**
 * Schema for creating extraction jobs in batch.
 */
type ExtractionJobCreateBatch = {
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The ids of the files
     */
    file_ids: Array<string>;
};
/**
 * Schema for an extraction result.
 */
type ExtractionResult = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The id of the schema
     */
    schema_id: string;
    /**
     * The data extracted from the file
     */
    data: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    };
    /**
     * The file that the extract was extracted from
     */
    file: File;
};
/**
 * Schema for extraction schema.
 */
type ExtractionSchema = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id: string;
    /**
     * The schema of the data
     */
    data_schema?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
};
/**
 * Schema for creating an extraction schema.
 */
type ExtractionSchemaCreate = {
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id?: string | null;
    /**
     * The schema of the data
     */
    data_schema: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    };
};
/**
 * Schema for inferring an extraction schema.
 */
type ExtractionSchemaInfer = {
    /**
     * The ID of a schema to update with the new schema
     */
    schema_id?: string | null;
    /**
     * The name of the extraction schema
     */
    name: string;
    /**
     * The ID of the project that the extraction schema belongs to
     */
    project_id?: string | null;
    /**
     * The IDs of the files that the extraction schema contains
     */
    file_ids: Array<string>;
    /**
     * Whether to stream the results of the extraction schema
     */
    stream?: boolean;
};
/**
 * Schema for updating an extraction schema.
 */
type ExtractionSchemaUpdate = {
    /**
     * The schema of the data
     */
    data_schema?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
};
/**
 * Schema for a file.
 */
type File = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    name: string;
    /**
     * Size of the file in bytes
     */
    file_size?: number | null;
    /**
     * File type (e.g. pdf, docx, etc.)
     */
    file_type?: string | null;
    /**
     * The ID of the project that the file belongs to
     */
    project_id: string;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string | null;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string | null;
};
type FileCreate = {
    name: string;
    /**
     * Size of the file in bytes
     */
    file_size?: number | null;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string | null;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string | null;
};
/**
 * Vector store filter conditions to combine different filters.
 */
type FilterCondition = "and" | "or";
/**
 * Vector store filter conditions to combine different filters.
 */
declare const FilterCondition: {
    readonly AND: "and";
    readonly OR: "or";
};
/**
 * Vector store filter operator.
 */
type FilterOperator = "==" | ">" | "<" | "!=" | ">=" | "<=" | "in" | "nin" | "any" | "all" | "text_match" | "contains" | "is_empty";
/**
 * Vector store filter operator.
 */
declare const FilterOperator: {
    readonly __: "<=";
    readonly _: "<";
    readonly IN: "in";
    readonly NIN: "nin";
    readonly ANY: "any";
    readonly ALL: "all";
    readonly TEXT_MATCH: "text_match";
    readonly CONTAINS: "contains";
    readonly IS_EMPTY: "is_empty";
};
type GeminiEmbedding = {
    /**
     * The modelId of the Gemini model to use.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.
     */
    title?: string | null;
    /**
     * The task for embedding model.
     */
    task_type?: string | null;
    /**
     * API key to access the model. Defaults to None.
     */
    api_key?: string | null;
    /**
     * API base to access the model. Defaults to None.
     */
    api_base?: string | null;
    /**
     * Transport to access the model. Defaults to None.
     */
    transport?: string | null;
    class_name?: string;
};
type GeminiEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "GEMINI_EMBEDDING";
    /**
     * Configuration for the Gemini embedding model.
     */
    component?: GeminiEmbedding;
};
/**
 * Type of the embedding model.
 */
type type4 = "GEMINI_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type4: {
    readonly GEMINI_EMBEDDING: "GEMINI_EMBEDDING";
};
type HTTPValidationError = {
    detail?: Array<ValidationError>;
};
type HuggingFaceInferenceAPIEmbedding = {
    /**
     * Hugging Face model name. If None, the task will be used.
     */
    model_name?: string | null;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * Pooling strategy. If None, the model's default pooling is used.
     */
    pooling?: Pooling | null;
    /**
     * Instruction to prepend during query embedding.
     */
    query_instruction?: string | null;
    /**
     * Instruction to prepend during text embedding.
     */
    text_instruction?: string | null;
    /**
     * Hugging Face token. Will default to the locally saved token. Pass token=False if you don’t want to send your token to the server.
     */
    token?: string | boolean | null;
    /**
     * The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available.
     */
    timeout?: number | null;
    /**
     * Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values.
     */
    headers?: {
        [key: string]: string;
    } | null;
    /**
     * Additional cookies to send to the server.
     */
    cookies?: {
        [key: string]: string;
    } | null;
    /**
     * Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None.
     */
    task?: string | null;
    class_name?: string;
};
type HuggingFaceInferenceAPIEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "HUGGINGFACE_API_EMBEDDING";
    /**
     * Configuration for the HuggingFace Inference API embedding model.
     */
    component?: HuggingFaceInferenceAPIEmbedding;
};
/**
 * Type of the embedding model.
 */
type type5 = "HUGGINGFACE_API_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type5: {
    readonly HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING";
};
type IngestionErrorResponse = {
    /**
     * ID of the job that failed.
     */
    job_id: string;
    /**
     * List of errors that occurred during ingestion.
     */
    message: string;
    /**
     * Name of the job that failed.
     */
    step: JobNameMapping;
};
/**
 * This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend
 */
type InputMessage = {
    /**
     * ID of the message, if any. a UUID.
     */
    id: string;
    role: MessageRole;
    content: string;
    /**
     * Additional data to be stored with the message.
     */
    data?: {
        [key: string]: unknown;
    } | null;
    class_name?: string;
};
/**
 * Enum for mapping original job names to readable names.
 */
type JobNameMapping = "MANAGED_INGESTION" | "DATA_SOURCE" | "FILES_UPDATE" | "FILE_UPDATER" | "PARSE" | "TRANSFORM" | "INGESTION";
/**
 * Enum for mapping original job names to readable names.
 */
declare const JobNameMapping: {
    readonly MANAGED_INGESTION: "MANAGED_INGESTION";
    readonly DATA_SOURCE: "DATA_SOURCE";
    readonly FILES_UPDATE: "FILES_UPDATE";
    readonly FILE_UPDATER: "FILE_UPDATER";
    readonly PARSE: "PARSE";
    readonly TRANSFORM: "TRANSFORM";
    readonly INGESTION: "INGESTION";
};
/**
 * The LLM class is the main class for interacting with language models.
 *
 * Attributes:
 * system_prompt (Optional[str]):
 * System prompt for LLM calls.
 * messages_to_prompt (Callable):
 * Function to convert a list of messages to an LLM prompt.
 * completion_to_prompt (Callable):
 * Function to convert a completion to an LLM prompt.
 * output_parser (Optional[BaseOutputParser]):
 * Output parser to parse, validate, and correct errors programmatically.
 * pydantic_program_mode (PydanticProgramMode):
 * Pydantic program mode to use for structured prediction.
 */
type LLM = {
    callback_manager?: unknown;
    /**
     * System prompt for LLM calls.
     */
    system_prompt?: string | null;
    /**
     * Function to convert a list of messages to an LLM prompt.
     */
    messages_to_prompt?: string;
    /**
     * Function to convert a completion to an LLM prompt.
     */
    completion_to_prompt?: string;
    /**
     * Output parser to parse, validate, and correct errors programmatically.
     */
    output_parser?: unknown | null;
    pydantic_program_mode?: PydanticProgramMode;
    /**
     * Query wrapper prompt for LLM calls.
     */
    query_wrapper_prompt?: BasePromptTemplate | null;
};
/**
 * Schema for an eval LLM model.
 */
type LLMModelData = {
    /**
     * The name of the LLM model.
     */
    name: string;
    /**
     * The description of the LLM model.
     */
    description: string;
    /**
     * Whether the model supports multi-modal image input
     */
    multi_modal: boolean;
};
type LLMParameters = {
    /**
     * The name of the model to use for LLM completions.
     */
    model_name?: SupportedLLMModelNames;
    /**
     * The system prompt to use for the completion.
     */
    system_prompt?: string | null;
    /**
     * The temperature value for the model.
     */
    temperature?: number | null;
    class_name?: string;
};
/**
 * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
 */
type LlamaParseParameters = {
    languages?: Array<ParserLanguages>;
    parsing_instruction?: string;
    disable_ocr?: boolean;
    annotate_links?: boolean;
    disable_reconstruction?: boolean;
    invalidate_cache?: boolean;
    do_not_cache?: boolean;
    fast_mode?: boolean;
    skip_diagonal_text?: boolean;
    gpt4o_mode?: boolean;
    gpt4o_api_key?: string;
    do_not_unroll_columns?: boolean;
    page_separator?: string | null;
    bounding_box?: string;
    target_pages?: string;
    use_vendor_multimodal_model?: boolean;
    vendor_multimodal_model_name?: string;
    vendor_multimodal_api_key?: string;
    page_prefix?: string;
    page_suffix?: string;
    webhook_url?: string;
    take_screenshot?: boolean;
    is_formatting_instruction?: boolean;
    premium_mode?: boolean;
    continuous_mode?: boolean;
    s3_input_path?: string;
    s3_output_path_prefix?: string;
    azure_openai_deployment_name?: string | null;
    azure_openai_endpoint?: string | null;
    azure_openai_api_version?: string | null;
    azure_openai_key?: string | null;
};
type LlamaParseSupportedFileExtensions = ".pdf" | ".doc" | ".docx" | ".docm" | ".dot" | ".dotx" | ".dotm" | ".rtf" | ".wps" | ".wpd" | ".sxw" | ".stw" | ".sxg" | ".pages" | ".mw" | ".mcw" | ".uot" | ".uof" | ".uos" | ".uop" | ".ppt" | ".pptx" | ".pot" | ".pptm" | ".potx" | ".potm" | ".key" | ".odp" | ".odg" | ".otp" | ".fopd" | ".sxi" | ".sti" | ".epub" | ".jpg" | ".jpeg" | ".png" | ".gif" | ".bmp" | ".svg" | ".tiff" | ".webp" | ".html" | ".htm" | ".xls" | ".xlsx" | ".xlsm" | ".xlsb" | ".xlw" | ".csv" | ".dif" | ".sylk" | ".slk" | ".prn" | ".numbers" | ".et" | ".ods" | ".fods" | ".uos1" | ".uos2" | ".dbf" | ".wk1" | ".wk2" | ".wk3" | ".wk4" | ".wks" | ".wq1" | ".wq2" | ".wb1" | ".wb2" | ".wb3" | ".qpw" | ".xlr" | ".eth" | ".tsv";
declare const LlamaParseSupportedFileExtensions: {
    readonly _PDF: ".pdf";
    readonly _DOC: ".doc";
    readonly _DOCX: ".docx";
    readonly _DOCM: ".docm";
    readonly _DOT: ".dot";
    readonly _DOTX: ".dotx";
    readonly _DOTM: ".dotm";
    readonly _RTF: ".rtf";
    readonly _WPS: ".wps";
    readonly _WPD: ".wpd";
    readonly _SXW: ".sxw";
    readonly _STW: ".stw";
    readonly _SXG: ".sxg";
    readonly _PAGES: ".pages";
    readonly _MW: ".mw";
    readonly _MCW: ".mcw";
    readonly _UOT: ".uot";
    readonly _UOF: ".uof";
    readonly _UOS: ".uos";
    readonly _UOP: ".uop";
    readonly _PPT: ".ppt";
    readonly _PPTX: ".pptx";
    readonly _POT: ".pot";
    readonly _PPTM: ".pptm";
    readonly _POTX: ".potx";
    readonly _POTM: ".potm";
    readonly _KEY: ".key";
    readonly _ODP: ".odp";
    readonly _ODG: ".odg";
    readonly _OTP: ".otp";
    readonly _FOPD: ".fopd";
    readonly _SXI: ".sxi";
    readonly _STI: ".sti";
    readonly _EPUB: ".epub";
    readonly _JPG: ".jpg";
    readonly _JPEG: ".jpeg";
    readonly _PNG: ".png";
    readonly _GIF: ".gif";
    readonly _BMP: ".bmp";
    readonly _SVG: ".svg";
    readonly _TIFF: ".tiff";
    readonly _WEBP: ".webp";
    readonly _HTML: ".html";
    readonly _HTM: ".htm";
    readonly _XLS: ".xls";
    readonly _XLSX: ".xlsx";
    readonly _XLSM: ".xlsm";
    readonly _XLSB: ".xlsb";
    readonly _XLW: ".xlw";
    readonly _CSV: ".csv";
    readonly _DIF: ".dif";
    readonly _SYLK: ".sylk";
    readonly _SLK: ".slk";
    readonly _PRN: ".prn";
    readonly _NUMBERS: ".numbers";
    readonly _ET: ".et";
    readonly _ODS: ".ods";
    readonly _FODS: ".fods";
    readonly _UOS1: ".uos1";
    readonly _UOS2: ".uos2";
    readonly _DBF: ".dbf";
    readonly _WK1: ".wk1";
    readonly _WK2: ".wk2";
    readonly _WK3: ".wk3";
    readonly _WK4: ".wk4";
    readonly _WKS: ".wks";
    readonly _WQ1: ".wq1";
    readonly _WQ2: ".wq2";
    readonly _WB1: ".wb1";
    readonly _WB2: ".wb2";
    readonly _WB3: ".wb3";
    readonly _QPW: ".qpw";
    readonly _XLR: ".xlr";
    readonly _ETH: ".eth";
    readonly _TSV: ".tsv";
};
/**
 * Evaluation result, EvaluationResult from llama_index.
 *
 * Output of an BaseEvaluator.
 */
type LocalEval = {
    /**
     * Query string
     */
    query?: string | null;
    /**
     * Context strings
     */
    contexts?: Array<string> | null;
    /**
     * Response string
     */
    response?: string | null;
    /**
     * Binary evaluation result (passing or not)
     */
    passing?: boolean | null;
    /**
     * Feedback or reasoning for the response
     */
    feedback?: string | null;
    /**
     * Score for the response
     */
    score?: number | null;
    /**
     * Used only for pairwise and specifies whether it is from original order of presented answers or flipped order
     */
    pairwise_source?: string | null;
    /**
     * Whether the evaluation result is an invalid one.
     */
    invalid_result?: boolean;
    /**
     * Reason for invalid evaluation.
     */
    invalid_reason?: string | null;
};
/**
 * Schema for the result of a local evaluation.
 */
type LocalEvalResults = {
    /**
     * The ID of the project.
     */
    project_id: string;
    /**
     * The ID of the local eval result set.
     */
    eval_set_id?: string | null;
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The name of the eval.
     */
    eval_name: string;
    /**
     * The eval results.
     */
    result: LocalEval;
};
/**
 * Schema for creating a local eval set.
 */
type LocalEvalSetCreate = {
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The eval results.
     */
    results: {
        [key: string]: Array<LocalEval>;
    };
};
type LocalEvalSets = {
    /**
     * The ID of the eval set.
     */
    eval_set_id: string;
    /**
     * The name of the app.
     */
    app_name: string;
    /**
     * The time of the upload.
     */
    upload_time: string;
};
/**
 * Status of managed ingestion with partial Updates.
 */
type ManagedIngestionStatus = "NOT_STARTED" | "IN_PROGRESS" | "SUCCESS" | "ERROR" | "PARTIAL_SUCCESS";
/**
 * Status of managed ingestion with partial Updates.
 */
declare const ManagedIngestionStatus: {
    readonly NOT_STARTED: "NOT_STARTED";
    readonly IN_PROGRESS: "IN_PROGRESS";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
    readonly PARTIAL_SUCCESS: "PARTIAL_SUCCESS";
};
type ManagedIngestionStatusResponse = {
    /**
     * ID of the latest job.
     */
    job_id?: string | null;
    /**
     * Date of the deployment.
     */
    deployment_date?: string | null;
    /**
     * Status of the ingestion.
     */
    status: ManagedIngestionStatus;
    /**
     * List of errors that occurred during ingestion.
     */
    error?: Array<IngestionErrorResponse> | null;
};
/**
 * Markdown element node parser.
 *
 * Splits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects
 * (e.g. tables).
 */
type MarkdownElementNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * LLM model to use for summarization.
     */
    llm?: LLM | null;
    /**
     * Query string to use for summarization.
     */
    summary_query_str?: string;
    /**
     * Num of workers for async jobs.
     */
    num_workers?: number;
    /**
     * Whether to show progress.
     */
    show_progress?: boolean;
    /**
     * Other types of node parsers to handle some types of nodes.
     */
    nested_node_parser?: NodeParser | null;
    class_name?: string;
};
/**
 * Markdown node parser.
 *
 * Splits a document into Nodes using custom Markdown splitting logic.
 *
 * Args:
 * include_metadata (bool): whether to include metadata in nodes
 * include_prev_next_rel (bool): whether to include prev/next relationships
 */
type MarkdownNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    class_name?: string;
};
type MessageAnnotation = {
    type: string;
    data: string;
    class_name?: string;
};
/**
 * Message role.
 */
type MessageRole = "system" | "user" | "assistant" | "function" | "tool" | "chatbot" | "model";
/**
 * Message role.
 */
declare const MessageRole: {
    readonly SYSTEM: "system";
    readonly USER: "user";
    readonly ASSISTANT: "assistant";
    readonly FUNCTION: "function";
    readonly TOOL: "tool";
    readonly CHATBOT: "chatbot";
    readonly MODEL: "model";
};
/**
 * Comprehensive metadata filter for vector stores to support more operators.
 *
 * Value uses Strict* types, as int, float and str are compatible types and were all
 * converted to string before.
 *
 * See: https://docs.pydantic.dev/latest/usage/types/#strict-types
 */
type MetadataFilter = {
    key: string;
    value: number | string | Array<string> | Array<number> | null;
    operator?: FilterOperator;
};
/**
 * Metadata filters for vector stores.
 */
type MetadataFilters = {
    filters: Array<MetadataFilter | MetadataFilters>;
    condition?: FilterCondition | null;
};
type MetricResult = {
    /**
     * Whether the metric passed or not.
     */
    passing?: boolean | null;
    /**
     * The score for the metric.
     */
    score?: number | null;
    /**
     * The reasoning for the metric.
     */
    feedback?: string | null;
};
/**
 * Base interface for node parser.
 */
type NodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    class_name?: string;
};
/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
type NodeRelationship = "1" | "2" | "3" | "4" | "5";
/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */
declare const NodeRelationship: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
    readonly _4: "4";
    readonly _5: "5";
};
type NoneChunkingConfig = {
    mode?: "none";
};
type mode5 = "none";
declare const mode5: {
    readonly NONE: "none";
};
type NoneSegmentationConfig = {
    mode?: "none";
};
type ObjectType = "1" | "2" | "3" | "4";
declare const ObjectType: {
    readonly _1: "1";
    readonly _2: "2";
    readonly _3: "3";
    readonly _4: "4";
};
type OpenAIEmbedding = {
    /**
     * The name of the OpenAI embedding model.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * Additional kwargs for the OpenAI API.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    /**
     * The OpenAI API key.
     */
    api_key?: string | null;
    /**
     * The base URL for OpenAI API.
     */
    api_base?: string | null;
    /**
     * The version for OpenAI API.
     */
    api_version?: string | null;
    /**
     * Maximum number of retries.
     */
    max_retries?: number;
    /**
     * Timeout for each request.
     */
    timeout?: number;
    /**
     * The default headers for API requests.
     */
    default_headers?: {
        [key: string]: string;
    } | null;
    /**
     * Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.
     */
    reuse_client?: boolean;
    /**
     * The number of dimensions on the output embedding vectors. Works only with v3 embedding models.
     */
    dimensions?: number | null;
    class_name?: string;
};
type OpenAIEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "OPENAI_EMBEDDING";
    /**
     * Configuration for the OpenAI embedding model.
     */
    component?: OpenAIEmbedding;
};
/**
 * Type of the embedding model.
 */
type type6 = "OPENAI_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type6: {
    readonly OPENAI_EMBEDDING: "OPENAI_EMBEDDING";
};
/**
 * Schema for an organization.
 */
type Organization = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * A name for the organization.
     */
    name: string;
};
/**
 * Schema for creating an organization.
 */
type OrganizationCreate = {
    /**
     * A name for the organization.
     */
    name: string;
};
/**
 * Schema for updating an organization.
 */
type OrganizationUpdate = {
    /**
     * A name for the organization.
     */
    name?: string | null;
};
type PageScreenshotMetadata = {
    /**
     * The index of the page for which the screenshot is taken (0-indexed)
     */
    page_index: number;
    /**
     * The ID of the file that the page screenshot was taken from
     */
    file_id: string;
    /**
     * The size of the image in bytes
     */
    image_size: number;
};
/**
 * Page screenshot metadata with score
 */
type PageScreenshotNodeWithScore = {
    node: PageScreenshotMetadata;
    /**
     * The score of the screenshot node
     */
    score: number;
    class_name?: string;
};
type PageSegmentationConfig = {
    mode?: "page";
    page_separator?: string;
};
type mode6 = "page";
declare const mode6: {
    readonly PAGE: "page";
};
/**
 * Split text into pages.
 */
type PageSplitterNodeParser = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * Separator to split text into pages.
     */
    page_separator?: string | null;
    class_name?: string;
};
/**
 * Enum for representing the languages supported by the parser
 */
type ParserLanguages = "af" | "az" | "bs" | "cs" | "cy" | "da" | "de" | "en" | "es" | "et" | "fr" | "ga" | "hr" | "hu" | "id" | "is" | "it" | "ku" | "la" | "lt" | "lv" | "mi" | "ms" | "mt" | "nl" | "no" | "oc" | "pi" | "pl" | "pt" | "ro" | "rs_latin" | "sk" | "sl" | "sq" | "sv" | "sw" | "tl" | "tr" | "uz" | "vi" | "ar" | "fa" | "ug" | "ur" | "bn" | "as" | "mni" | "ru" | "rs_cyrillic" | "be" | "bg" | "uk" | "mn" | "abq" | "ady" | "kbd" | "ava" | "dar" | "inh" | "che" | "lbe" | "lez" | "tab" | "tjk" | "hi" | "mr" | "ne" | "bh" | "mai" | "ang" | "bho" | "mah" | "sck" | "new" | "gom" | "sa" | "bgc" | "th" | "ch_sim" | "ch_tra" | "ja" | "ko" | "ta" | "te" | "kn";
/**
 * Enum for representing the languages supported by the parser
 */
declare const ParserLanguages: {
    readonly AF: "af";
    readonly AZ: "az";
    readonly BS: "bs";
    readonly CS: "cs";
    readonly CY: "cy";
    readonly DA: "da";
    readonly DE: "de";
    readonly EN: "en";
    readonly ES: "es";
    readonly ET: "et";
    readonly FR: "fr";
    readonly GA: "ga";
    readonly HR: "hr";
    readonly HU: "hu";
    readonly ID: "id";
    readonly IS: "is";
    readonly IT: "it";
    readonly KU: "ku";
    readonly LA: "la";
    readonly LT: "lt";
    readonly LV: "lv";
    readonly MI: "mi";
    readonly MS: "ms";
    readonly MT: "mt";
    readonly NL: "nl";
    readonly NO: "no";
    readonly OC: "oc";
    readonly PI: "pi";
    readonly PL: "pl";
    readonly PT: "pt";
    readonly RO: "ro";
    readonly RS_LATIN: "rs_latin";
    readonly SK: "sk";
    readonly SL: "sl";
    readonly SQ: "sq";
    readonly SV: "sv";
    readonly SW: "sw";
    readonly TL: "tl";
    readonly TR: "tr";
    readonly UZ: "uz";
    readonly VI: "vi";
    readonly AR: "ar";
    readonly FA: "fa";
    readonly UG: "ug";
    readonly UR: "ur";
    readonly BN: "bn";
    readonly AS: "as";
    readonly MNI: "mni";
    readonly RU: "ru";
    readonly RS_CYRILLIC: "rs_cyrillic";
    readonly BE: "be";
    readonly BG: "bg";
    readonly UK: "uk";
    readonly MN: "mn";
    readonly ABQ: "abq";
    readonly ADY: "ady";
    readonly KBD: "kbd";
    readonly AVA: "ava";
    readonly DAR: "dar";
    readonly INH: "inh";
    readonly CHE: "che";
    readonly LBE: "lbe";
    readonly LEZ: "lez";
    readonly TAB: "tab";
    readonly TJK: "tjk";
    readonly HI: "hi";
    readonly MR: "mr";
    readonly NE: "ne";
    readonly BH: "bh";
    readonly MAI: "mai";
    readonly ANG: "ang";
    readonly BHO: "bho";
    readonly MAH: "mah";
    readonly SCK: "sck";
    readonly NEW: "new";
    readonly GOM: "gom";
    readonly SA: "sa";
    readonly BGC: "bgc";
    readonly TH: "th";
    readonly CH_SIM: "ch_sim";
    readonly CH_TRA: "ch_tra";
    readonly JA: "ja";
    readonly KO: "ko";
    readonly TA: "ta";
    readonly TE: "te";
    readonly KN: "kn";
};
type ParsingHistoryItem = {
    user_id: string;
    day: string;
    job_id: string;
    file_name: string;
    original_file_name: string;
    expired?: boolean;
    pages?: number | null;
    images?: number | null;
    time?: number | null;
};
type ParsingJob = {
    id: string;
    status: StatusEnum;
    error_code?: string | null;
    error_message?: string | null;
};
type ParsingJobJsonResult = {
    /**
     * The json result of the parsing job
     */
    pages: unknown;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata: unknown;
};
type ParsingJobMarkdownResult = {
    /**
     * The markdown result of the parsing job
     */
    markdown: string;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata: unknown;
};
type ParsingJobTextResult = {
    /**
     * The text result of the parsing job
     */
    text: string;
    /**
     * Parsing job metadata , including usage
     */
    job_metadata: unknown;
};
type ParsingUsage = {
    usage_pdf_pages: number;
    max_pdf_pages?: number | null;
};
/**
 * Enum for dataset partition names.
 */
type PartitionNames = "data_source_id_partition" | "pipeline_id_partition" | "eval_dataset_id_partition" | "file_id_partition" | "pipeline_file_id_partition" | "file_parsing_id_partition" | "extraction_schema_id_partition";
/**
 * Enum for dataset partition names.
 */
declare const PartitionNames: {
    readonly DATA_SOURCE_ID_PARTITION: "data_source_id_partition";
    readonly PIPELINE_ID_PARTITION: "pipeline_id_partition";
    readonly EVAL_DATASET_ID_PARTITION: "eval_dataset_id_partition";
    readonly FILE_ID_PARTITION: "file_id_partition";
    readonly PIPELINE_FILE_ID_PARTITION: "pipeline_file_id_partition";
    readonly FILE_PARSING_ID_PARTITION: "file_parsing_id_partition";
    readonly EXTRACTION_SCHEMA_ID_PARTITION: "extraction_schema_id_partition";
};
/**
 * Schema for a permission.
 */
type Permission = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * A name for the permission.
     */
    name: string;
    /**
     * A description for the permission.
     */
    description: string | null;
    /**
     * Whether the permission is granted or not.
     */
    access: boolean;
};
/**
 * Schema for a pipeline.
 */
type Pipeline = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    name: string;
    project_id: string;
    /**
     * Type of pipeline. Either PLAYGROUND or MANAGED.
     */
    pipeline_type?: PipelineType;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string | null;
    embedding_config: AzureOpenAIEmbeddingConfig | CohereEmbeddingConfig | GeminiEmbeddingConfig | HuggingFaceInferenceAPIEmbeddingConfig | OpenAIEmbeddingConfig | VertexAIEmbeddingConfig | BedrockEmbeddingConfig;
    /**
     * Deprecated don't use it, List of configured transformations.
     */
    configured_transformations?: Array<ConfiguredTransformationItem>;
    /**
     * Hashes for the configuration of the pipeline.
     */
    config_hash?: PipelineConfigurationHashes | null;
    /**
     * Configuration for the transformation.
     */
    transform_config?: AutoTransformConfig | AdvancedModeTransformConfig;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams;
    /**
     * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
     */
    llama_parse_parameters?: LlamaParseParameters | null;
    /**
     * The data sink for the pipeline. If None, the pipeline will use the fully managed data sink.
     */
    data_sink?: DataSink | null;
};
/**
 * Hashes for the configuration of a pipeline.
 */
type PipelineConfigurationHashes = {
    /**
     * Hash of the embedding config.
     */
    embedding_config_hash?: string | null;
    /**
     * Hash of the llama parse parameters.
     */
    parsing_config_hash?: string | null;
    /**
     * Hash of the transform config.
     */
    transform_config_hash?: string | null;
};
/**
 * Schema for creating a pipeline.
 */
type PipelineCreate = {
    embedding_config?: (AzureOpenAIEmbeddingConfig | CohereEmbeddingConfig | GeminiEmbeddingConfig | HuggingFaceInferenceAPIEmbeddingConfig | OpenAIEmbeddingConfig | VertexAIEmbeddingConfig | BedrockEmbeddingConfig) | null;
    /**
     * Configuration for the transformation.
     */
    transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
    /**
     * Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.
     */
    configured_transformations?: Array<ConfiguredTransformationItem> | null;
    /**
     * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
     */
    data_sink_id?: string | null;
    /**
     * Data sink. When provided instead of data_sink_id, the data sink will be created.
     */
    data_sink?: DataSinkCreate | null;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams;
    llama_parse_parameters?: LlamaParseParameters;
    name: string;
    /**
     * Type of pipeline. Either PLAYGROUND or MANAGED.
     */
    pipeline_type?: PipelineType;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string | null;
};
/**
 * Schema for a data source in a pipeline.
 */
type PipelineDataSource = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The name of the data source.
     */
    name: string;
    source_type: ConfigurableDataSourceNames;
    /**
     * Custom metadata that will be present on all data loaded from the data source
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    component: {
        [key: string]: unknown;
    } | CloudS3DataSource | CloudAzStorageBlobDataSource | CloudGoogleDriveDataSource | CloudOneDriveDataSource | CloudSharepointDataSource | CloudSlackDataSource | CloudNotionPageDataSource | CloudConfluenceDataSource | CloudJiraDataSource | CloudBoxDataSource;
    project_id: string;
    /**
     * The ID of the data source.
     */
    data_source_id: string;
    /**
     * The ID of the pipeline.
     */
    pipeline_id: string;
    /**
     * The last time the data source was automatically synced.
     */
    last_synced_at: string;
    /**
     * The interval at which the data source should be synced.
     */
    sync_interval?: number | null;
    /**
     * The id of the user who set the sync schedule.
     */
    sync_schedule_set_by?: string | null;
};
/**
 * Schema for creating an association between a data source and a pipeline.
 */
type PipelineDataSourceCreate = {
    /**
     * The ID of the data source.
     */
    data_source_id: string;
    /**
     * The interval at which the data source should be synced.
     */
    sync_interval?: number | null;
};
/**
 * Schema for updating an association between a data source and a pipeline.
 */
type PipelineDataSourceUpdate = {
    /**
     * The interval at which the data source should be synced.
     */
    sync_interval?: number | null;
};
type PipelineDeployment = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * Status of the pipeline deployment.
     */
    status: ManagedIngestionStatus;
    /**
     * Time the pipeline deployment started.
     */
    started_at?: string | null;
    /**
     * Time the pipeline deployment finished.
     */
    ended_at?: string | null;
};
/**
 * Schema for a file that is associated with a pipeline.
 */
type PipelineFile = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    name?: string | null;
    /**
     * Size of the file in bytes
     */
    file_size?: number | null;
    /**
     * File type (e.g. pdf, docx, etc.)
     */
    file_type?: string | null;
    /**
     * The ID of the project that the file belongs to
     */
    project_id: string;
    /**
     * The last modified time of the file
     */
    last_modified_at?: string | null;
    /**
     * Resource information for the file
     */
    resource_info?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    /**
     * The ID of the data source that the file belongs to
     */
    data_source_id?: string | null;
    /**
     * The ID of the file
     */
    file_id?: string | null;
    /**
     * The ID of the pipeline that the file is associated with
     */
    pipeline_id: string;
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
    /**
     * Hashes for the configuration of the pipeline.
     */
    config_hash?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
};
/**
 * Schema for creating a file that is associated with a pipeline.
 */
type PipelineFileCreate = {
    /**
     * The ID of the file
     */
    file_id: string;
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
};
/**
 * Schema for updating a file that is associated with a pipeline.
 */
type PipelineFileUpdate = {
    /**
     * Custom metadata for the file
     */
    custom_metadata?: {
        [key: string]: {
            [key: string]: unknown;
        } | Array<unknown> | string | number | boolean | null;
    } | null;
};
/**
 * Enum for representing the type of a pipeline
 */
type PipelineType = "PLAYGROUND" | "MANAGED";
/**
 * Enum for representing the type of a pipeline
 */
declare const PipelineType: {
    readonly PLAYGROUND: "PLAYGROUND";
    readonly MANAGED: "MANAGED";
};
/**
 * Schema for updating a pipeline.
 */
type PipelineUpdate = {
    embedding_config?: (AzureOpenAIEmbeddingConfig | CohereEmbeddingConfig | GeminiEmbeddingConfig | HuggingFaceInferenceAPIEmbeddingConfig | OpenAIEmbeddingConfig | VertexAIEmbeddingConfig | BedrockEmbeddingConfig) | null;
    /**
     * Configuration for the transformation.
     */
    transform_config?: AutoTransformConfig | AdvancedModeTransformConfig | null;
    /**
     * Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.
     */
    configured_transformations?: Array<ConfiguredTransformationItem> | null;
    /**
     * Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID.
     */
    data_sink_id?: string | null;
    /**
     * Data sink. When provided instead of data_sink_id, the data sink will be created.
     */
    data_sink?: DataSinkCreate | null;
    /**
     * Preset retrieval parameters for the pipeline.
     */
    preset_retrieval_parameters?: PresetRetrievalParams | null;
    /**
     * Eval parameters for the pipeline.
     */
    eval_parameters?: EvalExecutionParams | null;
    /**
     * Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline.
     */
    llama_parse_parameters?: LlamaParseParameters | null;
    name?: string | null;
    /**
     * The ID of the ManagedPipeline this playground pipeline is linked to.
     */
    managed_pipeline_id?: string | null;
};
/**
 * A playground session for a user.
 */
type PlaygroundSession = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    pipeline_id: string;
    user_id: string;
    llm_params_id: string;
    /**
     * LLM parameters last used in this session.
     */
    llm_params?: LLMParameters;
    retrieval_params_id: string;
    /**
     * Preset retrieval parameters last used in this session.
     */
    retrieval_params?: PresetRetrievalParams;
    /**
     * Chat message history for this session.
     */
    chat_messages?: Array<ChatMessage>;
};
/**
 * Enum of possible pooling choices with pooling behaviors.
 */
type Pooling = "cls" | "mean" | "last";
/**
 * Enum of possible pooling choices with pooling behaviors.
 */
declare const Pooling: {
    readonly CLS: "cls";
    readonly MEAN: "mean";
    readonly LAST: "last";
};
/**
 * Schema for the search params for an retrieval execution that can be preset for a pipeline.
 */
type PresetRetrievalParams = {
    /**
     * Number of nodes for dense retrieval.
     */
    dense_similarity_top_k?: number | null;
    /**
     * Number of nodes for sparse retrieval.
     */
    sparse_similarity_top_k?: number | null;
    /**
     * Enable reranking for retrieval
     */
    enable_reranking?: boolean | null;
    /**
     * Number of reranked nodes for returning.
     */
    rerank_top_n?: number | null;
    /**
     * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
     */
    alpha?: number | null;
    /**
     * Search filters for retrieval.
     */
    search_filters?: MetadataFilters | null;
    /**
     * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
     */
    files_top_k?: number | null;
    /**
     * The retrieval mode for the query.
     */
    retrieval_mode?: RetrievalMode;
    /**
     * Whether to retrieve image nodes.
     */
    retrieve_image_nodes?: boolean;
    class_name?: string;
};
/**
 * Schema for a presigned URL.
 */
type PresignedUrl = {
    /**
     * A presigned URL for IO operations against a private file
     */
    url: string;
    /**
     * The time at which the presigned URL expires
     */
    expires_at: string;
    /**
     * Form fields for a presigned POST request
     */
    form_fields?: {
        [key: string]: string;
    } | null;
};
/**
 * Schema for a project.
 */
type Project = {
    name: string;
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    ad_hoc_eval_dataset_id?: string | null;
    /**
     * The Organization ID the project is under.
     */
    organization_id: string;
    /**
     * Whether this project is the default project for the user.
     */
    is_default?: boolean;
};
/**
 * Schema for creating a project.
 */
type ProjectCreate = {
    name: string;
};
/**
 * Schema for updating a project.
 */
type ProjectUpdate = {
    name: string;
};
/**
 * Schema for the prompts derived from the PromptMixin.
 */
type PromptMixinPrompts = {
    /**
     * The ID of the project.
     */
    project_id: string;
    /**
     * The ID of the prompt set.
     */
    id?: string | null;
    /**
     * The name of the prompt set.
     */
    name: string;
    /**
     * The prompts.
     */
    prompts: Array<PromptSpec>;
};
type PromptSpec = {
    /**
     * The key of the prompt in the PromptMixin.
     */
    prompt_key: string;
    /**
     * The class of the prompt (PromptTemplate or ChatPromptTemplate).
     */
    prompt_class: string;
    /**
     * The type of prompt.
     */
    prompt_type: string;
    /**
     * The template of the prompt.
     */
    template?: string | null;
    /**
     * The chat message templates of the prompt.
     */
    message_templates?: Array<ChatMessage> | null;
};
/**
 * Pydantic program mode.
 */
type PydanticProgramMode = "default" | "openai" | "llm" | "function" | "guidance" | "lm-format-enforcer";
/**
 * Pydantic program mode.
 */
declare const PydanticProgramMode: {
    readonly DEFAULT: "default";
    readonly OPENAI: "openai";
    readonly LLM: "llm";
    readonly FUNCTION: "function";
    readonly GUIDANCE: "guidance";
    readonly LM_FORMAT_ENFORCER: "lm-format-enforcer";
};
type RelatedNodeInfo = {
    node_id: string;
    node_type?: ObjectType | null;
    metadata?: {
        [key: string]: unknown;
    };
    hash?: string | null;
    class_name?: string;
};
type RetrievalMode = "chunks" | "files_via_metadata" | "files_via_content" | "auto_routed";
declare const RetrievalMode: {
    readonly CHUNKS: "chunks";
    readonly FILES_VIA_METADATA: "files_via_metadata";
    readonly FILES_VIA_CONTENT: "files_via_content";
    readonly AUTO_ROUTED: "auto_routed";
};
/**
 * Schema for the search params for an retrieval execution.
 */
type RetrievalParams = {
    /**
     * Number of nodes for dense retrieval.
     */
    dense_similarity_top_k?: number | null;
    /**
     * Number of nodes for sparse retrieval.
     */
    sparse_similarity_top_k?: number | null;
    /**
     * Enable reranking for retrieval
     */
    enable_reranking?: boolean | null;
    /**
     * Number of reranked nodes for returning.
     */
    rerank_top_n?: number | null;
    /**
     * Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval.
     */
    alpha?: number | null;
    /**
     * Search filters for retrieval.
     */
    search_filters?: MetadataFilters | null;
    /**
     * Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).
     */
    files_top_k?: number | null;
    /**
     * The retrieval mode for the query.
     */
    retrieval_mode?: RetrievalMode;
    /**
     * Whether to retrieve image nodes.
     */
    retrieve_image_nodes?: boolean;
    /**
     * The query to retrieve against.
     */
    query: string;
    class_name?: string;
};
/**
 * Schema for the result of an retrieval execution.
 */
type RetrieveResults = {
    /**
     * The ID of the pipeline that the query was retrieved against.
     */
    pipeline_id: string;
    /**
     * The nodes retrieved by the pipeline for the given query.
     */
    retrieval_nodes: Array<TextNodeWithScore>;
    /**
     * The image nodes retrieved by the pipeline for the given query.
     */
    image_nodes?: Array<PageScreenshotNodeWithScore>;
    /**
     * The end-to-end latency for retrieval and reranking.
     */
    retrieval_latency: {
        [key: string]: number;
    };
    /**
     * Metadata associated with the retrieval execution
     */
    metadata?: {
        [key: string]: string;
    };
    class_name?: string;
};
/**
 * Schema for a role.
 */
type Role = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * A name for the role.
     */
    name: string;
    /**
     * The organization's ID.
     */
    organization_id: string | null;
    /**
     * The actual permissions of the role.
     */
    permissions: Array<Permission>;
};
type SemanticChunkingConfig = {
    mode?: "semantic";
    buffer_size?: number;
    breakpoint_percentile_threshold?: number;
};
type mode7 = "semantic";
declare const mode7: {
    readonly SEMANTIC: "semantic";
};
type SentenceChunkingConfig = {
    chunk_size?: number;
    chunk_overlap?: number;
    mode?: "sentence";
    separator?: string;
    paragraph_separator?: string;
};
type mode8 = "sentence";
declare const mode8: {
    readonly SENTENCE: "sentence";
};
/**
 * Parse text with a preference for complete sentences.
 *
 * In general, this class tries to keep sentences and paragraphs together. Therefore
 * compared to the original TokenTextSplitter, there are less likely to be
 * hanging sentences or parts of sentences at the end of the node chunk.
 */
type SentenceSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * The token chunk size for each chunk.
     */
    chunk_size?: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunk_overlap?: number;
    /**
     * Default separator for splitting into words
     */
    separator?: string;
    /**
     * Separator between paragraphs.
     */
    paragraph_separator?: string;
    /**
     * Backup regex for splitting into sentences.
     */
    secondary_chunking_regex?: string | null;
    class_name?: string;
};
/**
 * Enum for representing the status of a job
 */
type StatusEnum = "PENDING" | "SUCCESS" | "ERROR" | "PARTIAL_SUCCESS";
/**
 * Enum for representing the status of a job
 */
declare const StatusEnum: {
    readonly PENDING: "PENDING";
    readonly SUCCESS: "SUCCESS";
    readonly ERROR: "ERROR";
    readonly PARTIAL_SUCCESS: "PARTIAL_SUCCESS";
};
/**
 * Response Schema for a supported eval LLM model.
 */
type SupportedLLMModel = {
    /**
     * The name of the supported LLM model.
     */
    name: SupportedLLMModelNames;
    /**
     * Whether the LLM model is enabled for use in LlamaCloud.
     */
    enabled?: boolean;
    /**
     * The details of the supported LLM model.
     */
    details: LLMModelData;
};
type SupportedLLMModelNames = "GPT_3_5_TURBO" | "GPT_4" | "GPT_4_TURBO" | "GPT_4O" | "GPT_4O_MINI" | "AZURE_OPENAI";
declare const SupportedLLMModelNames: {
    readonly GPT_3_5_TURBO: "GPT_3_5_TURBO";
    readonly GPT_4: "GPT_4";
    readonly GPT_4_TURBO: "GPT_4_TURBO";
    readonly GPT_4O: "GPT_4O";
    readonly GPT_4O_MINI: "GPT_4O_MINI";
    readonly AZURE_OPENAI: "AZURE_OPENAI";
};
type TextNode = {
    /**
     * Unique ID of the node.
     */
    id_?: string;
    /**
     * Embedding of the node.
     */
    embedding?: Array<number> | null;
    /**
     * A flat dictionary of metadata fields
     */
    extra_info?: {
        [key: string]: unknown;
    };
    /**
     * Metadata keys that are excluded from text for the embed model.
     */
    excluded_embed_metadata_keys?: Array<string>;
    /**
     * Metadata keys that are excluded from text for the LLM.
     */
    excluded_llm_metadata_keys?: Array<string>;
    /**
     * A mapping of relationships to other node information.
     */
    relationships?: {
        [key: string]: RelatedNodeInfo | Array<RelatedNodeInfo>;
    };
    /**
     * Text content of the node.
     */
    text?: string;
    /**
     * MIME type of the node content.
     */
    mimetype?: string;
    /**
     * Start char index of the node.
     */
    start_char_idx?: number | null;
    /**
     * End char index of the node.
     */
    end_char_idx?: number | null;
    /**
     * Template for how text is formatted, with {content} and {metadata_str} placeholders.
     */
    text_template?: string;
    /**
     * Template for how metadata is formatted, with {key} and {value} placeholders.
     */
    metadata_template?: string;
    /**
     * Separator between metadata fields when converting to string.
     */
    metadata_seperator?: string;
    class_name?: string;
};
/**
 * Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
 * FastAPI doesn't accept abstract classes like BaseNode.
 */
type TextNodeWithScore = {
    node: TextNode;
    score?: number | null;
    class_name?: string;
};
type TokenChunkingConfig = {
    chunk_size?: number;
    chunk_overlap?: number;
    mode?: "token";
    separator?: string;
};
type mode9 = "token";
declare const mode9: {
    readonly TOKEN: "token";
};
/**
 * Implementation of splitting text that looks at word tokens.
 */
type TokenTextSplitter = {
    /**
     * Whether or not to consider metadata when splitting.
     */
    include_metadata?: boolean;
    /**
     * Include prev/next node relationships.
     */
    include_prev_next_rel?: boolean;
    callback_manager?: unknown;
    /**
     * Function to generate node IDs.
     */
    id_func?: string | null;
    /**
     * The token chunk size for each chunk.
     */
    chunk_size?: number;
    /**
     * The token overlap of each chunk when splitting.
     */
    chunk_overlap?: number;
    /**
     * Default separator for splitting into words
     */
    separator?: string;
    /**
     * Additional separators for splitting.
     */
    backup_separators?: Array<unknown>;
    class_name?: string;
};
type TransformationCategoryNames = "NODE_PARSER" | "EMBEDDING";
declare const TransformationCategoryNames: {
    readonly NODE_PARSER: "NODE_PARSER";
    readonly EMBEDDING: "EMBEDDING";
};
/**
 * Schema for a user's membership to an organization.
 */
type UserOrganization = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The user's email address.
     */
    email: string;
    /**
     * The user's ID.
     */
    user_id?: string | null;
    /**
     * The organization's ID.
     */
    organization_id: string;
    /**
     * Whether the user's membership is pending account signup.
     */
    pending?: boolean;
    /**
     * The user ID of the user who added the user to the organization.
     */
    invited_by_user_id?: string | null;
    /**
     * The email address of the user who added the user to the organization.
     */
    invited_by_user_email?: string | null;
    /**
     * The roles of the user in the organization.
     */
    roles: Array<UserOrganizationRole>;
};
/**
 * Schema for creating a user's membership to an organization.
 */
type UserOrganizationCreate = {
    /**
     * The user's ID.
     */
    user_id?: string | null;
    /**
     * The user's email address.
     */
    email?: string | null;
    /**
     * The project IDs to add the user to.
     */
    project_ids: Array<string> | null;
    /**
     * The role ID to assign to the user.
     */
    role_id?: string | null;
};
/**
 * Schema for deleting a user's membership to an organization.
 */
type UserOrganizationDelete = {
    /**
     * The user's ID.
     */
    user_id?: string | null;
    /**
     * The user's email address.
     */
    email?: string | null;
};
/**
 * Schema for a user's role in an organization.
 */
type UserOrganizationRole = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Creation datetime
     */
    created_at?: string | null;
    /**
     * Update datetime
     */
    updated_at?: string | null;
    /**
     * The user's ID.
     */
    user_id: string;
    /**
     * The organization's ID.
     */
    organization_id: string;
    /**
     * The role's ID.
     */
    role_id: string;
    /**
     * The role.
     */
    role: Role;
};
/**
 * Schema for creating a user's role in an organization.
 */
type UserOrganizationRoleCreate = {
    /**
     * The user's ID.
     */
    user_id: string;
    /**
     * The organization's ID.
     */
    organization_id: string;
    /**
     * The role's ID.
     */
    role_id: string;
};
type ValidationError = {
    loc: Array<string | number>;
    msg: string;
    type: string;
};
type VertexAIEmbeddingConfig = {
    /**
     * Type of the embedding model.
     */
    type?: "VERTEXAI_EMBEDDING";
    /**
     * Configuration for the VertexAI embedding model.
     */
    component?: VertexTextEmbedding;
};
/**
 * Type of the embedding model.
 */
type type7 = "VERTEXAI_EMBEDDING";
/**
 * Type of the embedding model.
 */
declare const type7: {
    readonly VERTEXAI_EMBEDDING: "VERTEXAI_EMBEDDING";
};
/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
type VertexEmbeddingMode = "default" | "classification" | "clustering" | "similarity" | "retrieval";
/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */
declare const VertexEmbeddingMode: {
    readonly DEFAULT: "default";
    readonly CLASSIFICATION: "classification";
    readonly CLUSTERING: "clustering";
    readonly SIMILARITY: "similarity";
    readonly RETRIEVAL: "retrieval";
};
type VertexTextEmbedding = {
    /**
     * The modelId of the VertexAI model to use.
     */
    model_name?: string;
    /**
     * The batch size for embedding calls.
     */
    embed_batch_size?: number;
    /**
     * The number of workers to use for async embedding calls.
     */
    num_workers?: number | null;
    /**
     * The default location to use when making API calls.
     */
    location: string;
    /**
     * The default GCP project to use when making Vertex API calls.
     */
    project: string;
    /**
     * The embedding mode to use.
     */
    embed_mode?: VertexEmbeddingMode;
    /**
     * Additional kwargs for the Vertex.
     */
    additional_kwargs?: {
        [key: string]: unknown;
    };
    /**
     * The client email for the VertexAI credentials.
     */
    client_email: string | null;
    /**
     * The token URI for the VertexAI credentials.
     */
    token_uri: string | null;
    /**
     * The private key ID for the VertexAI credentials.
     */
    private_key_id: string | null;
    /**
     * The private key for the VertexAI credentials.
     */
    private_key: string | null;
    class_name?: string;
};
type GenerateKeyApiV1ApiKeysPostData = {
    body: APIKeyCreate;
};
type GenerateKeyApiV1ApiKeysPostResponse = APIKey;
type GenerateKeyApiV1ApiKeysPostError = HTTPValidationError;
type ListKeysApiV1ApiKeysGetData = unknown;
type ListKeysApiV1ApiKeysGetResponse = Array<APIKey>;
type ListKeysApiV1ApiKeysGetError = HTTPValidationError;
type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData = {
    path: {
        api_key_id: string;
    };
};
type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse = void;
type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteError = HTTPValidationError;
type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData = {
    body: APIKeyUpdate;
    path: {
        api_key_id: string;
    };
};
type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutResponse = APIKey;
type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutError = HTTPValidationError;
type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostData = {
    body: AzureOpenAIEmbeddingConfig | CohereEmbeddingConfig | GeminiEmbeddingConfig | HuggingFaceInferenceAPIEmbeddingConfig | OpenAIEmbeddingConfig | VertexAIEmbeddingConfig | BedrockEmbeddingConfig;
    query?: {
        pipeline_id?: string | null;
    };
};
type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponse = BaseConnectionValidation;
type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostError = HTTPValidationError;
type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostData = {
    body: DataSourceCreate;
};
type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponse = BaseConnectionValidation;
type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostError = HTTPValidationError;
type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostData = {
    body: DataSinkCreate;
};
type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponse = BaseConnectionValidation;
type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostError = HTTPValidationError;
type ListDataSinksApiV1DataSinksGetData = {
    query?: {
        project_id?: string | null;
    };
};
type ListDataSinksApiV1DataSinksGetResponse = Array<DataSink>;
type ListDataSinksApiV1DataSinksGetError = HTTPValidationError;
type CreateDataSinkApiV1DataSinksPostData = {
    body: DataSinkCreate;
    query?: {
        organization_id?: string | null;
        project_id?: string | null;
    };
};
type CreateDataSinkApiV1DataSinksPostResponse = DataSink;
type CreateDataSinkApiV1DataSinksPostError = HTTPValidationError;
type UpsertDataSinkApiV1DataSinksPutData = {
    body: DataSinkCreate;
    query?: {
        organization_id?: string | null;
        project_id?: string | null;
    };
};
type UpsertDataSinkApiV1DataSinksPutResponse = DataSink;
type UpsertDataSinkApiV1DataSinksPutError = HTTPValidationError;
type GetDataSinkApiV1DataSinksDataSinkIdGetData = {
    path: {
        data_sink_id: string;
    };
};
type GetDataSinkApiV1DataSinksDataSinkIdGetResponse = DataSink;
type GetDataSinkApiV1DataSinksDataSinkIdGetError = HTTPValidationError;
type UpdateDataSinkApiV1DataSinksDataSinkIdPutData = {
    body: DataSinkUpdate;
    path: {
        data_sink_id: string;
    };
};
type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse = DataSink;
type UpdateDataSinkApiV1DataSinksDataSinkIdPutError = HTTPValidationError;
type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData = {
    path: {
        data_sink_id: string;
    };
};
type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse = void;
type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteError = HTTPValidationError;
type ListDataSourcesApiV1DataSourcesGetData = {
    query?: {
        organization_id?: string | null;
        project_id?: string | null;
    };
};
type ListDataSourcesApiV1DataSourcesGetResponse = Array<DataSource>;
type ListDataSourcesApiV1DataSourcesGetError = HTTPValidationError;
type CreateDataSourceApiV1DataSourcesPostData = {
    body: DataSourceCreate;
    query?: {
        organization_id?: string | null;
        project_id?: string | null;
    };
};
type CreateDataSourceApiV1DataSourcesPostResponse = DataSource;
type CreateDataSourceApiV1DataSourcesPostError = HTTPValidationError;
type UpsertDataSourceApiV1DataSourcesPutData = {
    body: DataSourceCreate;
    query?: {
        organization_id?: string | null;
        project_id?: string | null;
    };
};
type UpsertDataSourceApiV1DataSourcesPutResponse = DataSource;
type UpsertDataSourceApiV1DataSourcesPutError = HTTPValidationError;
type GetDataSourceApiV1DataSourcesDataSourceIdGetData = {
    path: {
        data_source_id: string;
    };
};
type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse = DataSource;
type GetDataSourceApiV1DataSourcesDataSourceIdGetError = HTTPValidationError;
type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData = {
    body: DataSourceUpdate;
    path: {
        data_source_id: string;
    };
};
type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse = DataSource;
type UpdateDataSourceApiV1DataSourcesDataSourceIdPutError = HTTPValidationError;
type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData = {
    path: {
        data_source_id: string;
    };
};
type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse = void;
type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteError = HTTPValidationError;
type CreateOrganizationApiV1OrganizationsPostData = {
    body: OrganizationCreate;
};
type CreateOrganizationApiV1OrganizationsPostResponse = Organization;
type CreateOrganizationApiV1OrganizationsPostError = HTTPValidationError;
type UpsertOrganizationApiV1OrganizationsPutData = {
    body: OrganizationCreate;
};
type UpsertOrganizationApiV1OrganizationsPutResponse = Organization;
type UpsertOrganizationApiV1OrganizationsPutError = HTTPValidationError;
type ListOrganizationsApiV1OrganizationsGetData = unknown;
type ListOrganizationsApiV1OrganizationsGetResponse = Array<Organization>;
type ListOrganizationsApiV1OrganizationsGetError = HTTPValidationError;
type SetDefaultOrganizationApiV1OrganizationsDefaultPutData = {
    body: DefaultOrganizationUpdate;
};
type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse = Organization;
type SetDefaultOrganizationApiV1OrganizationsDefaultPutError = HTTPValidationError;
type GetDefaultOrganizationApiV1OrganizationsDefaultGetData = unknown;
type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse = Organization;
type GetDefaultOrganizationApiV1OrganizationsDefaultGetError = HTTPValidationError;
type GetOrganizationApiV1OrganizationsOrganizationIdGetData = {
    path: {
        organization_id: string;
    };
};
type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse = Organization;
type GetOrganizationApiV1OrganizationsOrganizationIdGetError = HTTPValidationError;
type UpdateOrganizationApiV1OrganizationsOrganizationIdPutData = {
    body: OrganizationUpdate;
    path: {
        organization_id: string;
    };
};
type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse = Organization;
type UpdateOrganizationApiV1OrganizationsOrganizationIdPutError = HTTPValidationError;
type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData = {
    path: {
        organization_id: string;
    };
};
type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse = void;
type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteError = HTTPValidationError;
type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData = {
    path: {
        organization_id: string;
    };
};
type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse = Array<UserOrganization>;
type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetError = HTTPValidationError;
type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData = {
    body: Array<UserOrganizationCreate>;
    path: {
        organization_id: string;
    };
};
type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse = Array<UserOrganization>;
type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutError = HTTPValidationError;
type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData = {
    path: {
        member_user_id: string;
        organization_id: string;
    };
};
type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse = void;
type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteError = HTTPValidationError;
type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData = {
    body: Array<UserOrganizationDelete>;
    path: {
        organization_id: string;
    };
};
type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse = void;
type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutError = HTTPValidationError;
type ListRolesApiV1OrganizationsOrganizationIdRolesGetData = {
    path: {
        organization_id: string;
    };
};
type ListRolesApiV1OrganizationsOrganizationIdRolesGetResponse = Array<Role>;
type ListRolesApiV1OrganizationsOrganizationIdRolesGetError = HTTPValidationError;
type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutData = {
    body: UserOrganizationRoleCreate;
    path: {
        organization_id: string;
    };
};
type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponse = UserOrganizationRole;
type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutError = HTTPValidationError;
type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetData = {
    path: {
        organization_id: string;
    };
};
type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponse = UserOrganizationRole;
type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetError = HTTPValidationError;
type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetData = {
    path: {
        organization_id: string;
        user_id: string;
    };
};
type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponse = Array<Project>;
type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetError = HTTPValidationError;
type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutData = {
    path: {
        organization_id: string;
        user_id: string;
    };
    query: {
        project_id: string;
    };
};
type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutResponse = unknown;
type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutError = HTTPValidationError;
type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteData = {
    path: {
        organization_id: string;
        project_id: string;
        user_id: string;
    };
};
type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteResponse = unknown;
type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteError = HTTPValidationError;
type ListProjectsApiV1ProjectsGetData = {
    query?: {
        organization_id?: string | null;
        project_name?: string | null;
    };
};
type ListProjectsApiV1ProjectsGetResponse = Array<Project>;
type ListProjectsApiV1ProjectsGetError = HTTPValidationError;
type CreateProjectApiV1ProjectsPostData = {
    body: ProjectCreate;
    query?: {
        organization_id?: string | null;
    };
};
type CreateProjectApiV1ProjectsPostResponse = Project;
type CreateProjectApiV1ProjectsPostError = HTTPValidationError;
type UpsertProjectApiV1ProjectsPutData = {
    body: ProjectCreate;
    query?: {
        organization_id?: string | null;
    };
};
type UpsertProjectApiV1ProjectsPutResponse = Project;
type UpsertProjectApiV1ProjectsPutError = HTTPValidationError;
type DeleteProjectApiV1ProjectsProjectIdDeleteData = {
    path: {
        project_id: string;
    };
};
type DeleteProjectApiV1ProjectsProjectIdDeleteResponse = void;
type DeleteProjectApiV1ProjectsProjectIdDeleteError = HTTPValidationError;
type GetProjectApiV1ProjectsProjectIdGetData = {
    path: {
        project_id: string;
    };
};
type GetProjectApiV1ProjectsProjectIdGetResponse = Project;
type GetProjectApiV1ProjectsProjectIdGetError = HTTPValidationError;
type UpdateExistingProjectApiV1ProjectsProjectIdPutData = {
    body: ProjectUpdate;
    path: {
        project_id: string;
    };
};
type UpdateExistingProjectApiV1ProjectsProjectIdPutResponse = Project;
type UpdateExistingProjectApiV1ProjectsProjectIdPutError = HTTPValidationError;
type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData = {
    body: EvalDatasetCreate;
    path: {
        project_id: string;
    };
};
type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostResponse = EvalDataset;
type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostError = HTTPValidationError;
type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData = {
    path: {
        project_id: string;
    };
};
type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse = Array<EvalDataset>;
type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetError = HTTPValidationError;
type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData = {
    body: LocalEvalSetCreate;
    path: {
        project_id: string;
    };
};
type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse = Array<LocalEvalResults>;
type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostError = HTTPValidationError;
type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData = {
    path: {
        project_id: string;
    };
};
type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse = Array<LocalEvalResults>;
type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetError = HTTPValidationError;
type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData = {
    path: {
        project_id: string;
    };
};
type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse = Array<LocalEvalSets>;
type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetError = HTTPValidationError;
type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData = {
    path: {
        local_eval_set_id: string;
        project_id: string;
    };
};
type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteResponse = unknown;
type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteError = HTTPValidationError;
type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData = {
    body: PromptMixinPrompts;
    path: {
        project_id: string;
    };
};
type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostResponse = PromptMixinPrompts;
type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostError = HTTPValidationError;
type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData = {
    path: {
        project_id: string;
    };
};
type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse = Array<PromptMixinPrompts>;
type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetError = HTTPValidationError;
type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData = {
    body: PromptMixinPrompts;
    path: {
        project_id: string;
        prompt_set_id: string;
    };
};
type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutResponse = PromptMixinPrompts;
type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutError = HTTPValidationError;
type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData = {
    path: {
        project_id: string;
        prompt_set_id: string;
    };
};
type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteResponse = unknown;
type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteError = HTTPValidationError;
type GetFileApiV1FilesIdGetData = {
    path: {
        id: string;
    };
    query?: {
        project_id?: string | null;
    };
};
type GetFileApiV1FilesIdGetResponse = File;
type GetFileApiV1FilesIdGetError = HTTPValidationError;
type DeleteFileApiV1FilesIdDeleteData = {
    path: {
        id: string;
    };
    query?: {
        project_id?: string | null;
    };
};
type DeleteFileApiV1FilesIdDeleteResponse = void;
type DeleteFileApiV1FilesIdDeleteError = HTTPValidationError;
type ListFilesApiV1FilesGetData = {
    query?: {
        project_id?: string | null;
    };
};
type ListFilesApiV1FilesGetResponse = Array<File>;
type ListFilesApiV1FilesGetError = HTTPValidationError;
type GeneratePresignedUrlApiV1FilesPutData = {
    body: FileCreate;
    query?: {
        project_id?: string | null;
    };
};
type GeneratePresignedUrlApiV1FilesPutResponse = PresignedUrl;
type GeneratePresignedUrlApiV1FilesPutError = HTTPValidationError;
type UploadFileApiV1FilesPostData = {
    body: Body_upload_file_api_v1_files_post;
    query?: {
        project_id?: string | null;
    };
};
type UploadFileApiV1FilesPostResponse = File;
type UploadFileApiV1FilesPostError = HTTPValidationError;
type SyncFilesApiV1FilesSyncPutData = {
    query?: {
        project_id?: string | null;
    };
};
type SyncFilesApiV1FilesSyncPutResponse = Array<File>;
type SyncFilesApiV1FilesSyncPutError = HTTPValidationError;
type ReadFileContentApiV1FilesIdContentGetData = {
    path: {
        id: string;
    };
    query?: {
        project_id?: string | null;
    };
};
type ReadFileContentApiV1FilesIdContentGetResponse = PresignedUrl;
type ReadFileContentApiV1FilesIdContentGetError = HTTPValidationError;
type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetData = {
    path: {
        id: string;
    };
    query?: {
        project_id?: string | null;
    };
};
type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse = Array<PageScreenshotMetadata>;
type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetError = HTTPValidationError;
type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetData = {
    path: {
        id: string;
        page_index: number;
    };
    query?: {
        project_id?: string | null;
    };
};
type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetResponse = unknown;
type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetError = HTTPValidationError;
type SearchPipelinesApiV1PipelinesGetData = {
    query?: {
        pipeline_name?: string | null;
        pipeline_type?: PipelineType | null;
        project_id?: string | null;
        project_name?: string | null;
    };
};
type SearchPipelinesApiV1PipelinesGetResponse = Array<Pipeline>;
type SearchPipelinesApiV1PipelinesGetError = HTTPValidationError;
type CreatePipelineApiV1PipelinesPostData = {
    body: PipelineCreate;
    query?: {
        project_id?: string | null;
    };
};
type CreatePipelineApiV1PipelinesPostResponse = Pipeline;
type CreatePipelineApiV1PipelinesPostError = HTTPValidationError;
type UpsertPipelineApiV1PipelinesPutData = {
    body: PipelineCreate;
    query?: {
        project_id?: string | null;
    };
};
type UpsertPipelineApiV1PipelinesPutResponse = Pipeline;
type UpsertPipelineApiV1PipelinesPutError = HTTPValidationError;
type GetPipelineApiV1PipelinesPipelineIdGetData = {
    path: {
        pipeline_id: string;
    };
};
type GetPipelineApiV1PipelinesPipelineIdGetResponse = Pipeline;
type GetPipelineApiV1PipelinesPipelineIdGetError = HTTPValidationError;
type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData = {
    body: PipelineUpdate;
    path: {
        pipeline_id: string;
    };
};
type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse = Pipeline;
type UpdateExistingPipelineApiV1PipelinesPipelineIdPutError = HTTPValidationError;
type DeletePipelineApiV1PipelinesPipelineIdDeleteData = {
    path: {
        pipeline_id: string;
    };
};
type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse = void;
type DeletePipelineApiV1PipelinesPipelineIdDeleteError = HTTPValidationError;
type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData = {
    path: {
        pipeline_id: string;
    };
};
type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse = ManagedIngestionStatusResponse;
type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetError = HTTPValidationError;
type SyncPipelineApiV1PipelinesPipelineIdSyncPostData = {
    path: {
        pipeline_id: string;
    };
};
type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse = Pipeline;
type SyncPipelineApiV1PipelinesPipelineIdSyncPostError = HTTPValidationError;
type CopyPipelineApiV1PipelinesPipelineIdCopyPostData = {
    path: {
        pipeline_id: string;
    };
};
type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse = Pipeline;
type CopyPipelineApiV1PipelinesPipelineIdCopyPostError = HTTPValidationError;
type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData = {
    body: EvalExecutionCreate;
    path: {
        eval_dataset_id: string;
        pipeline_id: string;
    };
};
type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostResponse = EvalDatasetJobRecord;
type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostError = HTTPValidationError;
type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData = {
    path: {
        eval_dataset_id: string;
        pipeline_id: string;
    };
};
type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse = Array<EvalDatasetJobRecord>;
type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetError = HTTPValidationError;
type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData = {
    path: {
        eval_dataset_id: string;
        pipeline_id: string;
    };
};
type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse = Array<EvalQuestionResult>;
type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetError = HTTPValidationError;
type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData = {
    path: {
        eval_dataset_execution_id: string;
        eval_dataset_id: string;
        pipeline_id: string;
    };
};
type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetResponse = EvalDatasetJobRecord;
type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetError = HTTPValidationError;
type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData = {
    path: {
        pipeline_id: string;
    };
    query?: {
        data_source_id?: string | null;
        only_manually_uploaded?: boolean;
    };
};
type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse = Array<PipelineFile>;
type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetError = HTTPValidationError;
type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData = {
    body: Array<PipelineFileCreate>;
    path: {
        pipeline_id: string;
    };
};
type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse = Array<PipelineFile>;
type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutError = HTTPValidationError;
type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData = {
    path: {
        file_id: string;
        pipeline_id: string;
    };
};
type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse = ManagedIngestionStatusResponse;
type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetError = HTTPValidationError;
type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData = {
    body: PipelineFileUpdate;
    path: {
        file_id: string;
        pipeline_id: string;
    };
};
type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse = PipelineFile;
type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutError = HTTPValidationError;
type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData = {
    path: {
        file_id: string;
        pipeline_id: string;
    };
};
type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse = void;
type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteError = HTTPValidationError;
type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData = {
    body: Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put;
    path: {
        pipeline_id: string;
    };
};
type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse = {
    [key: string]: string;
};
type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutError = HTTPValidationError;
type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData = {
    path: {
        pipeline_id: string;
    };
};
type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse = void;
type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteError = HTTPValidationError;
type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData = {
    path: {
        pipeline_id: string;
    };
};
type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse = Array<PipelineDataSource>;
type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetError = HTTPValidationError;
type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData = {
    body: Array<PipelineDataSourceCreate>;
    path: {
        pipeline_id: string;
    };
};
type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse = Array<PipelineDataSource>;
type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutError = HTTPValidationError;
type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutData = {
    body: PipelineDataSourceUpdate;
    path: {
        data_source_id: string;
        pipeline_id: string;
    };
};
type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponse = PipelineDataSource;
type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutError = HTTPValidationError;
type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData = {
    path: {
        data_source_id: string;
        pipeline_id: string;
    };
};
type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse = void;
type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteError = HTTPValidationError;
type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData = {
    path: {
        data_source_id: string;
        pipeline_id: string;
    };
};
type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse = Pipeline;
type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostError = HTTPValidationError;
type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetData = {
    path: {
        data_source_id: string;
        pipeline_id: string;
    };
};
type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponse = ManagedIngestionStatusResponse;
type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetError = HTTPValidationError;
type RunSearchApiV1PipelinesPipelineIdRetrievePostData = {
    body: RetrievalParams;
    path: {
        pipeline_id: string;
    };
};
type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse = RetrieveResults;
type RunSearchApiV1PipelinesPipelineIdRetrievePostError = HTTPValidationError;
type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData = {
    path: {
        pipeline_id: string;
    };
};
type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse = Array<PipelineDeployment>;
type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetError = HTTPValidationError;
type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData = {
    path: {
        job_id: string;
        pipeline_id: string;
    };
};
type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse = PipelineDeployment;
type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetError = HTTPValidationError;
type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetData = {
    path: {
        pipeline_id: string;
    };
};
type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponse = PlaygroundSession;
type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetError = HTTPValidationError;
type ChatApiV1PipelinesPipelineIdChatPostData = {
    body: ChatInputParams;
    path: {
        pipeline_id: string;
    };
};
type ChatApiV1PipelinesPipelineIdChatPostResponse = unknown;
type ChatApiV1PipelinesPipelineIdChatPostError = HTTPValidationError;
type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData = {
    body: Array<CloudDocumentCreate>;
    path: {
        pipeline_id: string;
    };
};
type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse = Array<CloudDocument>;
type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostError = HTTPValidationError;
type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData = {
    path: {
        pipeline_id: string;
    };
    query?: {
        file_id?: string | null;
        limit?: number;
        only_direct_upload?: boolean | null;
        skip?: number;
    };
};
type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse = Array<CloudDocument>;
type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetError = HTTPValidationError;
type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData = {
    body: Array<CloudDocumentCreate>;
    path: {
        pipeline_id: string;
    };
};
type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse = Array<CloudDocument>;
type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutError = HTTPValidationError;
type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData = {
    path: {
        document_id: string;
        pipeline_id: string;
    };
};
type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse = CloudDocument;
type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetError = HTTPValidationError;
type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData = {
    path: {
        document_id: string;
        pipeline_id: string;
    };
};
type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse = void;
type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteError = HTTPValidationError;
type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData = {
    path: {
        document_id: string;
        pipeline_id: string;
    };
};
type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse = ManagedIngestionStatusResponse;
type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetError = HTTPValidationError;
type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData = {
    path: {
        document_id: string;
        pipeline_id: string;
    };
};
type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse = Array<TextNode>;
type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetError = HTTPValidationError;
type GetDatasetApiV1EvalsDatasetsDatasetIdGetData = {
    path: {
        dataset_id: string;
    };
};
type GetDatasetApiV1EvalsDatasetsDatasetIdGetResponse = EvalDataset;
type GetDatasetApiV1EvalsDatasetsDatasetIdGetError = HTTPValidationError;
type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData = {
    body: EvalDatasetUpdate;
    path: {
        dataset_id: string;
    };
};
type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutResponse = EvalDataset;
type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutError = HTTPValidationError;
type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData = {
    path: {
        dataset_id: string;
    };
};
type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteResponse = void;
type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteError = HTTPValidationError;
type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData = {
    body: EvalQuestionCreate;
    path: {
        dataset_id: string;
    };
};
type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostResponse = EvalQuestion;
type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostError = HTTPValidationError;
type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData = {
    path: {
        dataset_id: string;
    };
};
type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse = Array<EvalQuestion>;
type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetError = HTTPValidationError;
type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData = {
    body: Array<EvalQuestionCreate>;
    path: {
        dataset_id: string;
    };
};
type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse = Array<EvalQuestion>;
type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostError = HTTPValidationError;
type GetQuestionApiV1EvalsQuestionsQuestionIdGetData = {
    path: {
        question_id: string;
    };
};
type GetQuestionApiV1EvalsQuestionsQuestionIdGetResponse = EvalQuestion;
type GetQuestionApiV1EvalsQuestionsQuestionIdGetError = HTTPValidationError;
type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData = {
    body: EvalQuestionCreate;
    path: {
        question_id: string;
    };
};
type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutResponse = EvalQuestion;
type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutError = HTTPValidationError;
type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData = {
    path: {
        question_id: string;
    };
};
type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteResponse = void;
type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteError = HTTPValidationError;
type ListSupportedModelsApiV1EvalsModelsGetData = unknown;
type ListSupportedModelsApiV1EvalsModelsGetResponse = Array<SupportedLLMModel>;
type ListSupportedModelsApiV1EvalsModelsGetError = HTTPValidationError;
type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData = {
    path: {
        job_id: string;
        name: string;
    };
};
type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponse = unknown;
type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetError = HTTPValidationError;
type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse = Array<LlamaParseSupportedFileExtensions>;
type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetError = unknown;
type UploadFileApiV1ParsingUploadPostData = {
    body?: Body_upload_file_api_v1_parsing_upload_post;
};
type UploadFileApiV1ParsingUploadPostResponse = ParsingJob;
type UploadFileApiV1ParsingUploadPostError = HTTPValidationError;
type UsageApiV1ParsingUsageGetData = unknown;
type UsageApiV1ParsingUsageGetResponse = ParsingUsage;
type UsageApiV1ParsingUsageGetError = HTTPValidationError;
type GetJobApiV1ParsingJobJobIdGetData = {
    path: {
        job_id: string;
    };
};
type GetJobApiV1ParsingJobJobIdGetResponse = ParsingJob;
type GetJobApiV1ParsingJobJobIdGetError = HTTPValidationError;
type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData = {
    path: {
        job_id: string;
    };
};
type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponse = unknown;
type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetError = HTTPValidationError;
type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData = {
    path: {
        job_id: string;
    };
};
type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse = ParsingJobTextResult;
type GetJobTextResultApiV1ParsingJobJobIdResultTextGetError = HTTPValidationError;
type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData = {
    path: {
        job_id: string;
    };
};
type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetResponse = unknown;
type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetError = HTTPValidationError;
type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData = {
    path: {
        job_id: string;
    };
};
type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse = ParsingJobMarkdownResult;
type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetError = HTTPValidationError;
type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData = {
    path: {
        job_id: string;
    };
};
type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponse = unknown;
type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetError = HTTPValidationError;
type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData = {
    path: {
        job_id: string;
    };
};
type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse = ParsingJobJsonResult;
type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetError = HTTPValidationError;
type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData = {
    path: {
        job_id: string;
    };
};
type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponse = unknown;
type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetError = HTTPValidationError;
type GetParsingHistoryResultApiV1ParsingHistoryGetData = unknown;
type GetParsingHistoryResultApiV1ParsingHistoryGetResponse = Array<ParsingHistoryItem>;
type GetParsingHistoryResultApiV1ParsingHistoryGetError = HTTPValidationError;
type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData = {
    path: {
        filename: string;
        job_id: string;
    };
};
type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse = PresignedUrl;
type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetError = HTTPValidationError;
type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse = Array<ConfigurableTransformationDefinition>;
type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetError = unknown;
type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse = Array<DataSourceDefinition>;
type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetError = unknown;
type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse = Array<DataSinkDefinition>;
type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetError = unknown;
type CreateCheckoutSessionApiV1BillingCheckoutSessionPostData = {
    body: CheckoutSessionCreatePayload;
};
type CreateCheckoutSessionApiV1BillingCheckoutSessionPostResponse = string;
type CreateCheckoutSessionApiV1BillingCheckoutSessionPostError = HTTPValidationError;
type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData = {
    body: CustomerPortalSessionCreatePayload;
};
type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse = string;
type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostError = HTTPValidationError;
type StripeWebhookApiV1BillingWebhookPostData = {
    headers?: {
        "stripe-signature"?: string;
    };
};
type StripeWebhookApiV1BillingWebhookPostResponse = unknown;
type StripeWebhookApiV1BillingWebhookPostError = HTTPValidationError;
type CreateSchemaApiV1ExtractionSchemasPostData = {
    body: ExtractionSchemaCreate;
};
type CreateSchemaApiV1ExtractionSchemasPostResponse = ExtractionSchema;
type CreateSchemaApiV1ExtractionSchemasPostError = HTTPValidationError;
type ListSchemasApiV1ExtractionSchemasGetData = {
    query?: {
        project_id?: string | null;
    };
};
type ListSchemasApiV1ExtractionSchemasGetResponse = Array<ExtractionSchema>;
type ListSchemasApiV1ExtractionSchemasGetError = HTTPValidationError;
type InferSchemaApiV1ExtractionSchemasInferPostData = {
    body: ExtractionSchemaInfer;
};
type InferSchemaApiV1ExtractionSchemasInferPostResponse = ExtractionSchema;
type InferSchemaApiV1ExtractionSchemasInferPostError = HTTPValidationError;
type GetSchemaApiV1ExtractionSchemasSchemaIdGetData = {
    path: {
        schema_id: string;
    };
};
type GetSchemaApiV1ExtractionSchemasSchemaIdGetResponse = ExtractionSchema;
type GetSchemaApiV1ExtractionSchemasSchemaIdGetError = HTTPValidationError;
type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData = {
    body: ExtractionSchemaUpdate;
    path: {
        schema_id: string;
    };
};
type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutResponse = ExtractionSchema;
type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutError = HTTPValidationError;
type ListJobsApiV1ExtractionJobsGetData = {
    query: {
        schema_id: string;
    };
};
type ListJobsApiV1ExtractionJobsGetResponse = Array<ExtractionJob>;
type ListJobsApiV1ExtractionJobsGetError = HTTPValidationError;
type RunJobApiV1ExtractionJobsPostData = {
    body: ExtractionJobCreate;
};
type RunJobApiV1ExtractionJobsPostResponse = ExtractionJob;
type RunJobApiV1ExtractionJobsPostError = HTTPValidationError;
type GetJobApiV1ExtractionJobsJobIdGetData = {
    path: {
        job_id: string;
    };
};
type GetJobApiV1ExtractionJobsJobIdGetResponse = ExtractionJob;
type GetJobApiV1ExtractionJobsJobIdGetError = HTTPValidationError;
type RunJobsInBatchApiV1ExtractionJobsBatchPostData = {
    body: ExtractionJobCreateBatch;
};
type RunJobsInBatchApiV1ExtractionJobsBatchPostResponse = Array<ExtractionJob>;
type RunJobsInBatchApiV1ExtractionJobsBatchPostError = HTTPValidationError;
type GetJobResultApiV1ExtractionJobsJobIdResultGetData = {
    path: {
        job_id: string;
    };
};
type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse = ExtractionResult;
type GetJobResultApiV1ExtractionJobsJobIdResultGetError = HTTPValidationError;
type GetJobImageResultApiParsingJobJobIdResultImageNameGetData = {
    path: {
        job_id: string;
        name: string;
    };
};
type GetJobImageResultApiParsingJobJobIdResultImageNameGetResponse = unknown;
type GetJobImageResultApiParsingJobJobIdResultImageNameGetError = HTTPValidationError;
type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse = Array<LlamaParseSupportedFileExtensions>;
type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetError = unknown;
type UploadFileApiParsingUploadPostData = {
    body?: Body_upload_file_api_parsing_upload_post;
};
type UploadFileApiParsingUploadPostResponse = ParsingJob;
type UploadFileApiParsingUploadPostError = HTTPValidationError;
type UsageApiParsingUsageGetData = unknown;
type UsageApiParsingUsageGetResponse = ParsingUsage;
type UsageApiParsingUsageGetError = HTTPValidationError;
type GetJobApiParsingJobJobIdGetData = {
    path: {
        job_id: string;
    };
};
type GetJobApiParsingJobJobIdGetResponse = ParsingJob;
type GetJobApiParsingJobJobIdGetError = HTTPValidationError;
type GetParsingJobDetailsApiParsingJobJobIdDetailsGetData = {
    path: {
        job_id: string;
    };
};
type GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponse = unknown;
type GetParsingJobDetailsApiParsingJobJobIdDetailsGetError = HTTPValidationError;
type GetJobTextResultApiParsingJobJobIdResultTextGetData = {
    path: {
        job_id: string;
    };
};
type GetJobTextResultApiParsingJobJobIdResultTextGetResponse = ParsingJobTextResult;
type GetJobTextResultApiParsingJobJobIdResultTextGetError = HTTPValidationError;
type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData = {
    path: {
        job_id: string;
    };
};
type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetResponse = unknown;
type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetError = HTTPValidationError;
type GetJobResultApiParsingJobJobIdResultMarkdownGetData = {
    path: {
        job_id: string;
    };
};
type GetJobResultApiParsingJobJobIdResultMarkdownGetResponse = ParsingJobMarkdownResult;
type GetJobResultApiParsingJobJobIdResultMarkdownGetError = HTTPValidationError;
type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData = {
    path: {
        job_id: string;
    };
};
type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponse = unknown;
type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetError = HTTPValidationError;
type GetJobJsonResultApiParsingJobJobIdResultJsonGetData = {
    path: {
        job_id: string;
    };
};
type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse = ParsingJobJsonResult;
type GetJobJsonResultApiParsingJobJobIdResultJsonGetError = HTTPValidationError;
type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData = {
    path: {
        job_id: string;
    };
};
type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponse = unknown;
type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetError = HTTPValidationError;
type GetParsingHistoryResultApiParsingHistoryGetData = unknown;
type GetParsingHistoryResultApiParsingHistoryGetResponse = Array<ParsingHistoryItem>;
type GetParsingHistoryResultApiParsingHistoryGetError = HTTPValidationError;
type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData = {
    path: {
        filename: string;
        job_id: string;
    };
};
type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse = PresignedUrl;
type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetError = HTTPValidationError;

declare const client: _hey_api_client_fetch.Client<Request, Response, unknown, _hey_api_client_fetch.RequestOptionsBase<false> & _hey_api_client_fetch.Config<false> & {
    headers: Headers;
}>;
declare class ApiKeysService {
    /**
     * Generate Key
     * Generate a new API Key.
     */
    static generateKeyApiV1ApiKeysPost<ThrowOnError extends boolean = false>(options: Options<GenerateKeyApiV1ApiKeysPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<APIKey, HTTPValidationError, ThrowOnError>;
    /**
     * List Keys
     * List API Keys for a user.
     */
    static listKeysApiV1ApiKeysGet<ThrowOnError extends boolean = false>(options?: Options<ListKeysApiV1ApiKeysGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListKeysApiV1ApiKeysGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Api Key
     * Delete an API Key by ID.
     */
    static deleteApiKeyApiV1ApiKeysApiKeyIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Update Existing Api Key
     * Update name of an existing API Key.
     */
    static updateExistingApiKeyApiV1ApiKeysApiKeyIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<APIKey, HTTPValidationError, ThrowOnError>;
}
declare class ValidationService {
    /**
     * Validate Embedding Connection
     * Validate an embedding connection.
     *
     * Args:
     * embedding_config: The embedding configuration to validate.
     * pipeline_id: If provided, the embedding connection will be validated for the pipeline.
     * user: The user to validate the embedding connection for.
     * db: The database session.
     *
     * Returns:
     * A BaseConnectionValidation object indicating the result of the validation.
     */
    static validateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPost<ThrowOnError extends boolean = false>(options: Options<ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<BaseConnectionValidation, HTTPValidationError, ThrowOnError>;
    /**
     * Validate Data Source Connection
     * Validate a data source connection.
     */
    static validateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPost<ThrowOnError extends boolean = false>(options: Options<ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<BaseConnectionValidation, HTTPValidationError, ThrowOnError>;
    /**
     * Validate Data Sink Connection
     * Validate a data sink connection.
     */
    static validateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPost<ThrowOnError extends boolean = false>(options: Options<ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<BaseConnectionValidation, HTTPValidationError, ThrowOnError>;
}
declare class DataSinksService {
    /**
     * List Data Sinks
     * List data sinks for a given project.
     * If project_id is not provided, uses the default project.
     */
    static listDataSinksApiV1DataSinksGet<ThrowOnError extends boolean = false>(options?: Options<ListDataSinksApiV1DataSinksGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListDataSinksApiV1DataSinksGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Data Sink
     * Create a new data sink.
     */
    static createDataSinkApiV1DataSinksPost<ThrowOnError extends boolean = false>(options: Options<CreateDataSinkApiV1DataSinksPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSink, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Data Sink
     * Upserts a data sink.
     * Updates if a data sink with the same name and project_id already exists. Otherwise, creates a new data sink.
     */
    static upsertDataSinkApiV1DataSinksPut<ThrowOnError extends boolean = false>(options: Options<UpsertDataSinkApiV1DataSinksPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSink, HTTPValidationError, ThrowOnError>;
    /**
     * Get Data Sink
     * Get a data sink by ID.
     */
    static getDataSinkApiV1DataSinksDataSinkIdGet<ThrowOnError extends boolean = false>(options: Options<GetDataSinkApiV1DataSinksDataSinkIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSink, HTTPValidationError, ThrowOnError>;
    /**
     * Update Data Sink
     * Update a data sink by ID.
     */
    static updateDataSinkApiV1DataSinksDataSinkIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateDataSinkApiV1DataSinksDataSinkIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSink, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Data Sink
     * Delete a data sink by ID.
     */
    static deleteDataSinkApiV1DataSinksDataSinkIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
}
declare class DataSourcesService {
    /**
     * List Data Sources
     * List data sources for a given project.
     * If project_id is not provided, uses the default project.
     */
    static listDataSourcesApiV1DataSourcesGet<ThrowOnError extends boolean = false>(options?: Options<ListDataSourcesApiV1DataSourcesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListDataSourcesApiV1DataSourcesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Data Source
     * Create a new data source.
     */
    static createDataSourceApiV1DataSourcesPost<ThrowOnError extends boolean = false>(options: Options<CreateDataSourceApiV1DataSourcesPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSource, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Data Source
     * Upserts a data source.
     * Updates if a data source with the same name and project_id already exists. Otherwise, creates a new data source.
     */
    static upsertDataSourceApiV1DataSourcesPut<ThrowOnError extends boolean = false>(options: Options<UpsertDataSourceApiV1DataSourcesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSource, HTTPValidationError, ThrowOnError>;
    /**
     * Get Data Source
     * Get a data source by ID.
     */
    static getDataSourceApiV1DataSourcesDataSourceIdGet<ThrowOnError extends boolean = false>(options: Options<GetDataSourceApiV1DataSourcesDataSourceIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSource, HTTPValidationError, ThrowOnError>;
    /**
     * Update Data Source
     * Update a data source by ID.
     */
    static updateDataSourceApiV1DataSourcesDataSourceIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateDataSourceApiV1DataSourcesDataSourceIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DataSource, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Data Source
     * Delete a data source by ID.
     */
    static deleteDataSourceApiV1DataSourcesDataSourceIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
}
declare class OrganizationsService {
    /**
     * Create Organization
     * Create a new organization.
     */
    static createOrganizationApiV1OrganizationsPost<ThrowOnError extends boolean = false>(options: Options<CreateOrganizationApiV1OrganizationsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Organization
     * Upsert a new organization.
     */
    static upsertOrganizationApiV1OrganizationsPut<ThrowOnError extends boolean = false>(options: Options<UpsertOrganizationApiV1OrganizationsPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * List Organizations
     * List organizations for a user.
     */
    static listOrganizationsApiV1OrganizationsGet<ThrowOnError extends boolean = false>(options?: Options<ListOrganizationsApiV1OrganizationsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListOrganizationsApiV1OrganizationsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Set Default Organization
     * Set the default organization for the user.
     */
    static setDefaultOrganizationApiV1OrganizationsDefaultPut<ThrowOnError extends boolean = false>(options: Options<SetDefaultOrganizationApiV1OrganizationsDefaultPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * Get Default Organization
     * Get the default organization for the user.
     */
    static getDefaultOrganizationApiV1OrganizationsDefaultGet<ThrowOnError extends boolean = false>(options?: Options<GetDefaultOrganizationApiV1OrganizationsDefaultGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * Get Organization
     * Get an organization by ID.
     */
    static getOrganizationApiV1OrganizationsOrganizationIdGet<ThrowOnError extends boolean = false>(options: Options<GetOrganizationApiV1OrganizationsOrganizationIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * Update Organization
     * Update an existing organization.
     */
    static updateOrganizationApiV1OrganizationsOrganizationIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateOrganizationApiV1OrganizationsOrganizationIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Organization, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Organization
     * Delete an organization by ID.
     */
    static deleteOrganizationApiV1OrganizationsOrganizationIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * List Organization Users
     * Get all users in an organization.
     */
    static listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet<ThrowOnError extends boolean = false>(options: Options<ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Add Users To Organization
     * Add a user to an organization.
     */
    static addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut<ThrowOnError extends boolean = false>(options: Options<AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Remove Users From Organization
     * Remove users from an organization by email.
     */
    static removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete<ThrowOnError extends boolean = false>(options: Options<RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Batch Remove Users From Organization
     * Remove a batch of users from an organization.
     */
    static batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut<ThrowOnError extends boolean = false>(options: Options<BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * List Roles
     * List all roles in an organization.
     */
    static listRolesApiV1OrganizationsOrganizationIdRolesGet<ThrowOnError extends boolean = false>(options: Options<ListRolesApiV1OrganizationsOrganizationIdRolesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListRolesApiV1OrganizationsOrganizationIdRolesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Assign Role To User In Organization
     * Assign a role to a user in an organization.
     */
    static assignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPut<ThrowOnError extends boolean = false>(options: Options<AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UserOrganizationRole, HTTPValidationError, ThrowOnError>;
    /**
     * Get User Role
     * Get the role of a user in an organization.
     */
    static getUserRoleApiV1OrganizationsOrganizationIdUsersRolesGet<ThrowOnError extends boolean = false>(options: Options<GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UserOrganizationRole, HTTPValidationError, ThrowOnError>;
    /**
     * List Projects By User
     * List all projects for a user in an organization.
     */
    static listProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGet<ThrowOnError extends boolean = false>(options: Options<ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Add User To Project
     * Add a user to a project.
     */
    static addUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPut<ThrowOnError extends boolean = false>(options: Options<AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Remove User From Project
     * Remove a user from a project.
     */
    static removeUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDelete<ThrowOnError extends boolean = false>(options: Options<RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
}
declare class ProjectsService {
    /**
     * List Projects
     * List projects or get one by name
     */
    static listProjectsApiV1ProjectsGet<ThrowOnError extends boolean = false>(options?: Options<ListProjectsApiV1ProjectsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListProjectsApiV1ProjectsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Project
     * Create a new project.
     */
    static createProjectApiV1ProjectsPost<ThrowOnError extends boolean = false>(options: Options<CreateProjectApiV1ProjectsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Project, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Project
     * Upsert a project.
     * Updates if a project with the same name already exists. Otherwise, creates a new project.
     */
    static upsertProjectApiV1ProjectsPut<ThrowOnError extends boolean = false>(options: Options<UpsertProjectApiV1ProjectsPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Project, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Project
     * Delete a project by ID.
     */
    static deleteProjectApiV1ProjectsProjectIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteProjectApiV1ProjectsProjectIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Get Project
     * Get a project by ID.
     */
    static getProjectApiV1ProjectsProjectIdGet<ThrowOnError extends boolean = false>(options: Options<GetProjectApiV1ProjectsProjectIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Project, HTTPValidationError, ThrowOnError>;
    /**
     * Update Existing Project
     * Update an existing project.
     */
    static updateExistingProjectApiV1ProjectsProjectIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateExistingProjectApiV1ProjectsProjectIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Project, HTTPValidationError, ThrowOnError>;
    /**
     * Create Eval Dataset For Project
     * Create a new eval dataset for a project.
     */
    static createEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPost<ThrowOnError extends boolean = false>(options: Options<CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalDataset, HTTPValidationError, ThrowOnError>;
    /**
     * List Datasets For Project
     * List eval datasets for a project.
     */
    static listDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGet<ThrowOnError extends boolean = false>(options: Options<ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Local Eval Set For Project
     * Create a new local eval set.
     */
    static createLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPost<ThrowOnError extends boolean = false>(options: Options<CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse, HTTPValidationError, ThrowOnError>;
    /**
     * List Local Evals For Project
     * List local eval results for a project.
     */
    static listLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGet<ThrowOnError extends boolean = false>(options: Options<ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * List Local Eval Sets For Project
     * List local eval sets for a project.
     */
    static listLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGet<ThrowOnError extends boolean = false>(options: Options<ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Local Eval Set
     * Delete a local eval set.
     */
    static deleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Create Prompt Mixin Prompts
     * Create a new PromptMixin prompt set.
     */
    static createPromptMixinPromptsApiV1ProjectsProjectIdPromptsPost<ThrowOnError extends boolean = false>(options: Options<CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PromptMixinPrompts, HTTPValidationError, ThrowOnError>;
    /**
     * List Promptmixin Prompts
     * List PromptMixin prompt sets for a project.
     */
    static listPromptmixinPromptsApiV1ProjectsProjectIdPromptsGet<ThrowOnError extends boolean = false>(options: Options<ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Update Promptmixin Prompts
     * Update a PromptMixin prompt set.
     */
    static updatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPut<ThrowOnError extends boolean = false>(options: Options<UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PromptMixinPrompts, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Prompt Mixin Prompts
     * Delete a PromptMixin prompt set.
     */
    static deletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDelete<ThrowOnError extends boolean = false>(options: Options<DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
}
declare class FilesService {
    /**
     * Get File
     * Read File metadata objects.
     */
    static getFileApiV1FilesIdGet<ThrowOnError extends boolean = false>(options: Options<GetFileApiV1FilesIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<File, HTTPValidationError, ThrowOnError>;
    /**
     * Delete File
     * Delete the file from S3.
     */
    static deleteFileApiV1FilesIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteFileApiV1FilesIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * List Files
     * Read File metadata objects.
     */
    static listFilesApiV1FilesGet<ThrowOnError extends boolean = false>(options?: Options<ListFilesApiV1FilesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListFilesApiV1FilesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Generate Presigned Url
     * Create a presigned url for uploading a file.
     */
    static generatePresignedUrlApiV1FilesPut<ThrowOnError extends boolean = false>(options: Options<GeneratePresignedUrlApiV1FilesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PresignedUrl, HTTPValidationError, ThrowOnError>;
    /**
     * Upload File
     * Upload a file to S3.
     */
    static uploadFileApiV1FilesPost<ThrowOnError extends boolean = false>(options: Options<UploadFileApiV1FilesPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<File, HTTPValidationError, ThrowOnError>;
    /**
     * Sync Files
     * Sync Files API against file contents uploaded via S3 presigned urls.
     */
    static syncFilesApiV1FilesSyncPut<ThrowOnError extends boolean = false>(options?: Options<SyncFilesApiV1FilesSyncPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SyncFilesApiV1FilesSyncPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Read File Content
     * Returns a presigned url to read the file content.
     */
    static readFileContentApiV1FilesIdContentGet<ThrowOnError extends boolean = false>(options: Options<ReadFileContentApiV1FilesIdContentGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PresignedUrl, HTTPValidationError, ThrowOnError>;
    /**
     * List File Page Screenshots
     * List metadata for all screenshots of pages from a file.
     */
    static listFilePageScreenshotsApiV1FilesIdPageScreenshotsGet<ThrowOnError extends boolean = false>(options: Options<ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get File Page Screenshot
     * Get screenshot of a page from a file.
     */
    static getFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGet<ThrowOnError extends boolean = false>(options: Options<GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
}
declare class PipelinesService {
    /**
     * Search Pipelines
     * Search for pipelines by various parameters.
     */
    static searchPipelinesApiV1PipelinesGet<ThrowOnError extends boolean = false>(options?: Options<SearchPipelinesApiV1PipelinesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchPipelinesApiV1PipelinesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Pipeline
     * Create a new pipeline for a project.
     */
    static createPipelineApiV1PipelinesPost<ThrowOnError extends boolean = false>(options: Options<CreatePipelineApiV1PipelinesPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Pipeline
     * Upsert a pipeline for a project.
     * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
     */
    static upsertPipelineApiV1PipelinesPut<ThrowOnError extends boolean = false>(options: Options<UpsertPipelineApiV1PipelinesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline
     * Get a pipeline by ID for a given project.
     */
    static getPipelineApiV1PipelinesPipelineIdGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineApiV1PipelinesPipelineIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Update Existing Pipeline
     * Update an existing pipeline for a project.
     */
    static updateExistingPipelineApiV1PipelinesPipelineIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateExistingPipelineApiV1PipelinesPipelineIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Pipeline
     * Delete a pipeline by ID.
     */
    static deletePipelineApiV1PipelinesPipelineIdDelete<ThrowOnError extends boolean = false>(options: Options<DeletePipelineApiV1PipelinesPipelineIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline Status
     * Get the status of a pipeline by ID.
     */
    static getPipelineStatusApiV1PipelinesPipelineIdStatusGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ManagedIngestionStatusResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Sync Pipeline
     * Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.
     */
    static syncPipelineApiV1PipelinesPipelineIdSyncPost<ThrowOnError extends boolean = false>(options: Options<SyncPipelineApiV1PipelinesPipelineIdSyncPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Copy Pipeline
     * Copy a pipeline by ID.
     */
    static copyPipelineApiV1PipelinesPipelineIdCopyPost<ThrowOnError extends boolean = false>(options: Options<CopyPipelineApiV1PipelinesPipelineIdCopyPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Execute Eval Dataset
     * Execute a dataset.
     */
    static executeEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePost<ThrowOnError extends boolean = false>(options: Options<ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalDatasetJobRecord, HTTPValidationError, ThrowOnError>;
    /**
     * Get Eval Dataset Executions
     * Get the status of an EvalDatasetExecution.
     */
    static getEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGet<ThrowOnError extends boolean = false>(options: Options<GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Eval Dataset Execution Result
     * Get the result of an EvalDatasetExecution.
     * If eval_question_ids is specified, only the results for the specified
     * questions will be returned.
     * If any of the specified questions do not have a result, they will be ignored.
     */
    static getEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGet<ThrowOnError extends boolean = false>(options: Options<GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Eval Dataset Execution
     * Get the status of an EvalDatasetExecution.
     */
    static getEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGet<ThrowOnError extends boolean = false>(options: Options<GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalDatasetJobRecord, HTTPValidationError, ThrowOnError>;
    /**
     * List Pipeline Files
     * Get files for a pipeline.
     */
    static listPipelineFilesApiV1PipelinesPipelineIdFilesGet<ThrowOnError extends boolean = false>(options: Options<ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Add Files To Pipeline
     * Add files to a pipeline.
     */
    static addFilesToPipelineApiV1PipelinesPipelineIdFilesPut<ThrowOnError extends boolean = false>(options: Options<AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline File Status
     * Get status of a file for a pipeline.
     */
    static getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ManagedIngestionStatusResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Update Pipeline File
     * Update a file for a pipeline.
     */
    static updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut<ThrowOnError extends boolean = false>(options: Options<UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PipelineFile, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Pipeline File
     * Delete a file from a pipeline.
     */
    static deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete<ThrowOnError extends boolean = false>(options: Options<DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Import Pipeline Metadata
     * Import metadata for a pipeline.
     */
    static importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut<ThrowOnError extends boolean = false>(options: Options<ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Pipeline Files Metadata
     * Delete metadata for all files in a pipeline.
     */
    static deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete<ThrowOnError extends boolean = false>(options: Options<DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * List Pipeline Data Sources
     * Get data sources for a pipeline.
     */
    static listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet<ThrowOnError extends boolean = false>(options: Options<ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Add Data Sources To Pipeline
     * Add data sources to a pipeline.
     */
    static addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut<ThrowOnError extends boolean = false>(options: Options<AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Update Pipeline Data Source
     * Update the configuration of a data source in a pipeline.
     */
    static updatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPut<ThrowOnError extends boolean = false>(options: Options<UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PipelineDataSource, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Pipeline Data Source
     * Delete a data source from a pipeline.
     */
    static deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete<ThrowOnError extends boolean = false>(options: Options<DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Sync Pipeline Data Source
     * Run ingestion for the pipeline data source by incrementally updating the data-sink with upstream changes from data-source.
     */
    static syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost<ThrowOnError extends boolean = false>(options: Options<SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Pipeline, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline Data Source Status
     * Get the status of a data source for a pipeline.
     */
    static getPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ManagedIngestionStatusResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Run Search
     * Get retrieval results for a managed pipeline and a query
     */
    static runSearchApiV1PipelinesPipelineIdRetrievePost<ThrowOnError extends boolean = false>(options: Options<RunSearchApiV1PipelinesPipelineIdRetrievePostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RetrieveResults, HTTPValidationError, ThrowOnError>;
    /**
     * List Pipeline Jobs
     * Get jobs for a pipeline.
     */
    static listPipelineJobsApiV1PipelinesPipelineIdJobsGet<ThrowOnError extends boolean = false>(options: Options<ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline Job
     * Get a job for a pipeline.
     */
    static getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PipelineDeployment, HTTPValidationError, ThrowOnError>;
    /**
     * Get Playground Session
     * Get a playground session for a user and pipeline.
     */
    static getPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGet<ThrowOnError extends boolean = false>(options: Options<GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PlaygroundSession, HTTPValidationError, ThrowOnError>;
    /**
     * Chat
     * Make a retrieval query + chat completion for a managed pipeline.
     */
    static chatApiV1PipelinesPipelineIdChatPost<ThrowOnError extends boolean = false>(options: Options<ChatApiV1PipelinesPipelineIdChatPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Create Batch Pipeline Documents
     * Batch create documents for a pipeline.
     */
    static createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost<ThrowOnError extends boolean = false>(options: Options<CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse, HTTPValidationError, ThrowOnError>;
    /**
     * List Pipeline Documents
     * Return a list of documents for a pipeline.
     */
    static listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet<ThrowOnError extends boolean = false>(options: Options<ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Upsert Batch Pipeline Documents
     * Batch create or update a document for a pipeline.
     */
    static upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut<ThrowOnError extends boolean = false>(options: Options<UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline Document
     * Return a single document for a pipeline.
     */
    static getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CloudDocument, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Pipeline Document
     * Delete a document for a pipeline.
     */
    static deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete<ThrowOnError extends boolean = false>(options: Options<DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Get Pipeline Document Status
     * Return a single document for a pipeline.
     */
    static getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet<ThrowOnError extends boolean = false>(options: Options<GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ManagedIngestionStatusResponse, HTTPValidationError, ThrowOnError>;
    /**
     * List Pipeline Document Chunks
     * Return a list of chunks for a pipeline document.
     */
    static listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet<ThrowOnError extends boolean = false>(options: Options<ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse, HTTPValidationError, ThrowOnError>;
}
declare class EvalsService {
    /**
     * Get Dataset
     * Get a dataset by ID.
     */
    static getDatasetApiV1EvalsDatasetsDatasetIdGet<ThrowOnError extends boolean = false>(options: Options<GetDatasetApiV1EvalsDatasetsDatasetIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalDataset, HTTPValidationError, ThrowOnError>;
    /**
     * Update Dataset
     * Update a dataset.
     */
    static updateDatasetApiV1EvalsDatasetsDatasetIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalDataset, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Dataset
     * Delete a dataset.
     */
    static deleteDatasetApiV1EvalsDatasetsDatasetIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * Create Question
     * Create a new question.
     */
    static createQuestionApiV1EvalsDatasetsDatasetIdQuestionPost<ThrowOnError extends boolean = false>(options: Options<CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalQuestion, HTTPValidationError, ThrowOnError>;
    /**
     * List Questions
     * List questions for a dataset.
     */
    static listQuestionsApiV1EvalsDatasetsDatasetIdQuestionGet<ThrowOnError extends boolean = false>(options: Options<ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Create Questions
     * Create a new question.
     */
    static createQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPost<ThrowOnError extends boolean = false>(options: Options<CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Question
     * Get a question by ID.
     */
    static getQuestionApiV1EvalsQuestionsQuestionIdGet<ThrowOnError extends boolean = false>(options: Options<GetQuestionApiV1EvalsQuestionsQuestionIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalQuestion, HTTPValidationError, ThrowOnError>;
    /**
     * Replace Question
     * Replace a question.
     */
    static replaceQuestionApiV1EvalsQuestionsQuestionIdPut<ThrowOnError extends boolean = false>(options: Options<ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EvalQuestion, HTTPValidationError, ThrowOnError>;
    /**
     * Delete Question
     * Delete a question.
     */
    static deleteQuestionApiV1EvalsQuestionsQuestionIdDelete<ThrowOnError extends boolean = false>(options: Options<DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<void, HTTPValidationError, ThrowOnError>;
    /**
     * List Supported Models
     * List supported models.
     */
    static listSupportedModelsApiV1EvalsModelsGet<ThrowOnError extends boolean = false>(options?: Options<ListSupportedModelsApiV1EvalsModelsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListSupportedModelsApiV1EvalsModelsGetResponse, HTTPValidationError, ThrowOnError>;
}
declare class ParsingService {
    /**
     * Get Job Image Result
     * Get a job by id
     */
    static getJobImageResultApiV1ParsingJobJobIdResultImageNameGet<ThrowOnError extends boolean = false>(options: Options<GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Supported File Extensions
     * Get a list of supported file extensions
     */
    static getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet<ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse, unknown, ThrowOnError>;
    /**
     * Upload File
     * Upload a file to s3 and create a job. return a job id
     */
    static uploadFileApiV1ParsingUploadPost<ThrowOnError extends boolean = false>(options?: Options<UploadFileApiV1ParsingUploadPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJob, HTTPValidationError, ThrowOnError>;
    /**
     * Usage
     * Get parsing usage for user
     */
    static usageApiV1ParsingUsageGet<ThrowOnError extends boolean = false>(options?: Options<UsageApiV1ParsingUsageGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingUsage, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job
     * Get a job by id
     */
    static getJobApiV1ParsingJobJobIdGet<ThrowOnError extends boolean = false>(options: Options<GetJobApiV1ParsingJobJobIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJob, HTTPValidationError, ThrowOnError>;
    /**
     * Get Parsing Job Details
     * Get a job by id
     */
    static getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet<ThrowOnError extends boolean = false>(options: Options<GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Text Result
     * Get a job by id
     */
    static getJobTextResultApiV1ParsingJobJobIdResultTextGet<ThrowOnError extends boolean = false>(options: Options<GetJobTextResultApiV1ParsingJobJobIdResultTextGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobTextResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Raw Text Result
     * Get a job by id
     */
    static getJobRawTextResultApiV1ParsingJobJobIdResultRawTextGet<ThrowOnError extends boolean = false>(options: Options<GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Result
     * Get a job by id
     */
    static getJobResultApiV1ParsingJobJobIdResultMarkdownGet<ThrowOnError extends boolean = false>(options: Options<GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobMarkdownResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Raw Md Result
     * Get a job by id
     */
    static getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet<ThrowOnError extends boolean = false>(options: Options<GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Json Result
     * Get a job by id
     */
    static getJobJsonResultApiV1ParsingJobJobIdResultJsonGet<ThrowOnError extends boolean = false>(options: Options<GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobJsonResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Json Raw Result
     * Get a job by id
     */
    static getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet<ThrowOnError extends boolean = false>(options: Options<GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Parsing History Result
     * Get parsing history for user
     */
    static getParsingHistoryResultApiV1ParsingHistoryGet<ThrowOnError extends boolean = false>(options?: Options<GetParsingHistoryResultApiV1ParsingHistoryGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetParsingHistoryResultApiV1ParsingHistoryGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Generate Presigned Url
     * Generate a presigned URL for a job
     */
    static generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet<ThrowOnError extends boolean = false>(options: Options<GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PresignedUrl, HTTPValidationError, ThrowOnError>;
}
declare class ComponentDefinitionsService {
    /**
     * List Transformation Definitions
     * List transformation component definitions.
     */
    static listTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGet<ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse, unknown, ThrowOnError>;
    /**
     * List Data Source Definitions
     * List data source component definitions.
     */
    static listDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGet<ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse, unknown, ThrowOnError>;
    /**
     * List Data Sink Definitions
     * List data sink component definitions.
     */
    static listDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGet<ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse, unknown, ThrowOnError>;
}
declare class BillingService {
    /**
     * Create Checkout Session
     * Create a new checkout session.
     */
    static createCheckoutSessionApiV1BillingCheckoutSessionPost<ThrowOnError extends boolean = false>(options: Options<CreateCheckoutSessionApiV1BillingCheckoutSessionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<string, HTTPValidationError, ThrowOnError>;
    /**
     * Create Customer Portal Session
     * Create a new customer portal session.
     */
    static createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost<ThrowOnError extends boolean = false>(options: Options<CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<string, HTTPValidationError, ThrowOnError>;
    /**
     * Stripe Webhook
     * Stripe webhook endpoint.
     */
    static stripeWebhookApiV1BillingWebhookPost<ThrowOnError extends boolean = false>(options?: Options<StripeWebhookApiV1BillingWebhookPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
}
declare class ExtractionService {
    /**
     * Create Schema
     */
    static createSchemaApiV1ExtractionSchemasPost<ThrowOnError extends boolean = false>(options: Options<CreateSchemaApiV1ExtractionSchemasPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionSchema, HTTPValidationError, ThrowOnError>;
    /**
     * List Schemas
     */
    static listSchemasApiV1ExtractionSchemasGet<ThrowOnError extends boolean = false>(options?: Options<ListSchemasApiV1ExtractionSchemasGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListSchemasApiV1ExtractionSchemasGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Infer Schema
     */
    static inferSchemaApiV1ExtractionSchemasInferPost<ThrowOnError extends boolean = false>(options: Options<InferSchemaApiV1ExtractionSchemasInferPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionSchema, HTTPValidationError, ThrowOnError>;
    /**
     * Get Schema
     */
    static getSchemaApiV1ExtractionSchemasSchemaIdGet<ThrowOnError extends boolean = false>(options: Options<GetSchemaApiV1ExtractionSchemasSchemaIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionSchema, HTTPValidationError, ThrowOnError>;
    /**
     * Update Schema
     */
    static updateSchemaApiV1ExtractionSchemasSchemaIdPut<ThrowOnError extends boolean = false>(options: Options<UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionSchema, HTTPValidationError, ThrowOnError>;
    /**
     * List Jobs
     */
    static listJobsApiV1ExtractionJobsGet<ThrowOnError extends boolean = false>(options: Options<ListJobsApiV1ExtractionJobsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ListJobsApiV1ExtractionJobsGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Run Job
     */
    static runJobApiV1ExtractionJobsPost<ThrowOnError extends boolean = false>(options: Options<RunJobApiV1ExtractionJobsPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionJob, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job
     */
    static getJobApiV1ExtractionJobsJobIdGet<ThrowOnError extends boolean = false>(options: Options<GetJobApiV1ExtractionJobsJobIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionJob, HTTPValidationError, ThrowOnError>;
    /**
     * Run Jobs In Batch
     */
    static runJobsInBatchApiV1ExtractionJobsBatchPost<ThrowOnError extends boolean = false>(options: Options<RunJobsInBatchApiV1ExtractionJobsBatchPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RunJobsInBatchApiV1ExtractionJobsBatchPostResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Result
     */
    static getJobResultApiV1ExtractionJobsJobIdResultGet<ThrowOnError extends boolean = false>(options: Options<GetJobResultApiV1ExtractionJobsJobIdResultGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ExtractionResult, HTTPValidationError, ThrowOnError>;
}
declare class DeprecatedService {
    /**
     * Get Job Image Result
     * Get a job by id
     */
    static getJobImageResultApiParsingJobJobIdResultImageNameGet<ThrowOnError extends boolean = false>(options: Options<GetJobImageResultApiParsingJobJobIdResultImageNameGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Supported File Extensions
     * Get a list of supported file extensions
     */
    static getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet<ThrowOnError extends boolean = false>(options?: Options<unknown, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse, unknown, ThrowOnError>;
    /**
     * Upload File
     * Upload a file to s3 and create a job. return a job id
     */
    static uploadFileApiParsingUploadPost<ThrowOnError extends boolean = false>(options?: Options<UploadFileApiParsingUploadPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJob, HTTPValidationError, ThrowOnError>;
    /**
     * Usage
     * Get parsing usage for user
     */
    static usageApiParsingUsageGet<ThrowOnError extends boolean = false>(options?: Options<UsageApiParsingUsageGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingUsage, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job
     * Get a job by id
     */
    static getJobApiParsingJobJobIdGet<ThrowOnError extends boolean = false>(options: Options<GetJobApiParsingJobJobIdGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJob, HTTPValidationError, ThrowOnError>;
    /**
     * Get Parsing Job Details
     * Get a job by id
     */
    static getParsingJobDetailsApiParsingJobJobIdDetailsGet<ThrowOnError extends boolean = false>(options: Options<GetParsingJobDetailsApiParsingJobJobIdDetailsGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Text Result
     * Get a job by id
     */
    static getJobTextResultApiParsingJobJobIdResultTextGet<ThrowOnError extends boolean = false>(options: Options<GetJobTextResultApiParsingJobJobIdResultTextGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobTextResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Raw Text Result
     * Get a job by id
     */
    static getJobRawTextResultApiParsingJobJobIdResultRawTextGet<ThrowOnError extends boolean = false>(options: Options<GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Result
     * Get a job by id
     */
    static getJobResultApiParsingJobJobIdResultMarkdownGet<ThrowOnError extends boolean = false>(options: Options<GetJobResultApiParsingJobJobIdResultMarkdownGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobMarkdownResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Raw Md Result
     * Get a job by id
     */
    static getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet<ThrowOnError extends boolean = false>(options: Options<GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Json Result
     * Get a job by id
     */
    static getJobJsonResultApiParsingJobJobIdResultJsonGet<ThrowOnError extends boolean = false>(options: Options<GetJobJsonResultApiParsingJobJobIdResultJsonGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ParsingJobJsonResult, HTTPValidationError, ThrowOnError>;
    /**
     * Get Job Json Raw Result
     * Get a job by id
     */
    static getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet<ThrowOnError extends boolean = false>(options: Options<GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, HTTPValidationError, ThrowOnError>;
    /**
     * Get Parsing History Result
     * Get parsing history for user
     */
    static getParsingHistoryResultApiParsingHistoryGet<ThrowOnError extends boolean = false>(options?: Options<GetParsingHistoryResultApiParsingHistoryGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetParsingHistoryResultApiParsingHistoryGetResponse, HTTPValidationError, ThrowOnError>;
    /**
     * Generate Presigned Url
     * Generate a presigned URL for a job
     */
    static generatePresignedUrlApiParsingJobJobIdReadFilenameGet<ThrowOnError extends boolean = false>(options: Options<GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PresignedUrl, HTTPValidationError, ThrowOnError>;
}

export { type APIKey, type APIKeyCreate, APIKeyCreateSchema, APIKeySchema, type APIKeyUpdate, APIKeyUpdateSchema, type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutData, type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutError, type AddDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPutResponse, type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutData, type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutError, type AddFilesToPipelineApiV1PipelinesPipelineIdFilesPutResponse, type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutData, type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutError, type AddUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPutResponse, type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutData, type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutError, type AddUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPutResponse, type AdvancedModeTransformConfig, AdvancedModeTransformConfigSchema, ApiKeysService, type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutData, type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutError, type AssignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPutResponse, type AutoTransformConfig, AutoTransformConfigSchema, type AzureOpenAIEmbedding, type AzureOpenAIEmbeddingConfig, AzureOpenAIEmbeddingConfigSchema, AzureOpenAIEmbeddingSchema, type Base, type BaseConnectionValidation, BaseConnectionValidationSchema, type BasePromptTemplate, BasePromptTemplateSchema, BaseSchema, type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutData, type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutError, type BatchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePutResponse, type BedrockEmbedding, type BedrockEmbeddingConfig, BedrockEmbeddingConfigSchema, BedrockEmbeddingSchema, BillingService, type Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put, Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema, type Body_upload_file_api_parsing_upload_post, Body_upload_file_api_parsing_upload_postSchema, type Body_upload_file_api_v1_files_post, Body_upload_file_api_v1_files_postSchema, type Body_upload_file_api_v1_parsing_upload_post, Body_upload_file_api_v1_parsing_upload_postSchema, BoxAuthMechanism, BoxAuthMechanismSchema, type CharacterChunkingConfig, CharacterChunkingConfigSchema, type CharacterSplitter, CharacterSplitterSchema, type ChatApiV1PipelinesPipelineIdChatPostData, type ChatApiV1PipelinesPipelineIdChatPostError, type ChatApiV1PipelinesPipelineIdChatPostResponse, type ChatData, ChatDataSchema, type ChatInputParams, ChatInputParamsSchema, type ChatMessage, ChatMessageSchema, type CheckoutSessionCreatePayload, CheckoutSessionCreatePayloadSchema, type CloudAzStorageBlobDataSource, CloudAzStorageBlobDataSourceSchema, type CloudAzureAISearchVectorStore, CloudAzureAISearchVectorStoreSchema, type CloudBoxDataSource, CloudBoxDataSourceSchema, type CloudConfluenceDataSource, CloudConfluenceDataSourceSchema, type CloudDocument, type CloudDocumentCreate, CloudDocumentCreateSchema, CloudDocumentSchema, type CloudGoogleDriveDataSource, CloudGoogleDriveDataSourceSchema, type CloudJiraDataSource, CloudJiraDataSourceSchema, type CloudMilvusVectorStore, CloudMilvusVectorStoreSchema, type CloudMongoDBAtlasVectorSearch, CloudMongoDBAtlasVectorSearchSchema, type CloudNotionPageDataSource, CloudNotionPageDataSourceSchema, type CloudOneDriveDataSource, CloudOneDriveDataSourceSchema, type CloudPineconeVectorStore, CloudPineconeVectorStoreSchema, type CloudPostgresVectorStore, CloudPostgresVectorStoreSchema, type CloudQdrantVectorStore, CloudQdrantVectorStoreSchema, type CloudS3DataSource, CloudS3DataSourceSchema, type CloudSharepointDataSource, CloudSharepointDataSourceSchema, type CloudSlackDataSource, CloudSlackDataSourceSchema, type CodeSplitter, CodeSplitterSchema, type CohereEmbedding, type CohereEmbeddingConfig, CohereEmbeddingConfigSchema, CohereEmbeddingSchema, ComponentDefinitionsService, ConfigurableDataSinkNames, ConfigurableDataSinkNamesSchema, ConfigurableDataSourceNames, ConfigurableDataSourceNamesSchema, type ConfigurableTransformationDefinition, ConfigurableTransformationDefinitionSchema, ConfigurableTransformationNames, ConfigurableTransformationNamesSchema, type ConfiguredTransformationItem, ConfiguredTransformationItemSchema, type CopyPipelineApiV1PipelinesPipelineIdCopyPostData, type CopyPipelineApiV1PipelinesPipelineIdCopyPostError, type CopyPipelineApiV1PipelinesPipelineIdCopyPostResponse, type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostData, type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostError, type CreateBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPostResponse, type CreateCheckoutSessionApiV1BillingCheckoutSessionPostData, type CreateCheckoutSessionApiV1BillingCheckoutSessionPostError, type CreateCheckoutSessionApiV1BillingCheckoutSessionPostResponse, type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostData, type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostError, type CreateCustomerPortalSessionApiV1BillingCustomerPortalSessionPostResponse, type CreateDataSinkApiV1DataSinksPostData, type CreateDataSinkApiV1DataSinksPostError, type CreateDataSinkApiV1DataSinksPostResponse, type CreateDataSourceApiV1DataSourcesPostData, type CreateDataSourceApiV1DataSourcesPostError, type CreateDataSourceApiV1DataSourcesPostResponse, type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostData, type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostError, type CreateEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPostResponse, type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostData, type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostError, type CreateLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPostResponse, type CreateOrganizationApiV1OrganizationsPostData, type CreateOrganizationApiV1OrganizationsPostError, type CreateOrganizationApiV1OrganizationsPostResponse, type CreatePipelineApiV1PipelinesPostData, type CreatePipelineApiV1PipelinesPostError, type CreatePipelineApiV1PipelinesPostResponse, type CreateProjectApiV1ProjectsPostData, type CreateProjectApiV1ProjectsPostError, type CreateProjectApiV1ProjectsPostResponse, type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostData, type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostError, type CreatePromptMixinPromptsApiV1ProjectsProjectIdPromptsPostResponse, type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostData, type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostError, type CreateQuestionApiV1EvalsDatasetsDatasetIdQuestionPostResponse, type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostData, type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostError, type CreateQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPostResponse, type CreateSchemaApiV1ExtractionSchemasPostData, type CreateSchemaApiV1ExtractionSchemasPostError, type CreateSchemaApiV1ExtractionSchemasPostResponse, type CustomerPortalSessionCreatePayload, CustomerPortalSessionCreatePayloadSchema, type DataSink, type DataSinkCreate, DataSinkCreateSchema, type DataSinkDefinition, DataSinkDefinitionSchema, DataSinkSchema, type DataSinkUpdate, DataSinkUpdateSchema, DataSinksService, type DataSource, type DataSourceCreate, DataSourceCreateSchema, type DataSourceDefinition, DataSourceDefinitionSchema, DataSourceSchema, type DataSourceUpdate, DataSourceUpdateSchema, DataSourcesService, type DefaultOrganizationUpdate, DefaultOrganizationUpdateSchema, type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteData, type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteError, type DeleteApiKeyApiV1ApiKeysApiKeyIdDeleteResponse, type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteData, type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteError, type DeleteDataSinkApiV1DataSinksDataSinkIdDeleteResponse, type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteData, type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteError, type DeleteDataSourceApiV1DataSourcesDataSourceIdDeleteResponse, type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteData, type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteError, type DeleteDatasetApiV1EvalsDatasetsDatasetIdDeleteResponse, type DeleteFileApiV1FilesIdDeleteData, type DeleteFileApiV1FilesIdDeleteError, type DeleteFileApiV1FilesIdDeleteResponse, type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteData, type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteError, type DeleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDeleteResponse, type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteData, type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteError, type DeleteOrganizationApiV1OrganizationsOrganizationIdDeleteResponse, type DeletePipelineApiV1PipelinesPipelineIdDeleteData, type DeletePipelineApiV1PipelinesPipelineIdDeleteError, type DeletePipelineApiV1PipelinesPipelineIdDeleteResponse, type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteData, type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteError, type DeletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDeleteResponse, type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteData, type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteError, type DeletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDeleteResponse, type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteData, type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteError, type DeletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDeleteResponse, type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteData, type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteError, type DeletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDeleteResponse, type DeleteProjectApiV1ProjectsProjectIdDeleteData, type DeleteProjectApiV1ProjectsProjectIdDeleteError, type DeleteProjectApiV1ProjectsProjectIdDeleteResponse, type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteData, type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteError, type DeletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDeleteResponse, type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteData, type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteError, type DeleteQuestionApiV1EvalsQuestionsQuestionIdDeleteResponse, DeprecatedService, type ElementSegmentationConfig, ElementSegmentationConfigSchema, type EvalDataset, type EvalDatasetCreate, EvalDatasetCreateSchema, type EvalDatasetJobParams, EvalDatasetJobParamsSchema, type EvalDatasetJobRecord, EvalDatasetJobRecordSchema, EvalDatasetSchema, type EvalDatasetUpdate, EvalDatasetUpdateSchema, type EvalExecutionCreate, EvalExecutionCreateSchema, type EvalExecutionParams, type EvalExecutionParamsOverride, EvalExecutionParamsOverrideSchema, EvalExecutionParamsSchema, EvalMetric, EvalMetricSchema, type EvalQuestion, type EvalQuestionCreate, EvalQuestionCreateSchema, type EvalQuestionResult, EvalQuestionResultSchema, EvalQuestionSchema, EvalsService, type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostData, type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostError, type ExecuteEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePostResponse, type ExtractionJob, type ExtractionJobCreate, type ExtractionJobCreateBatch, ExtractionJobCreateBatchSchema, ExtractionJobCreateSchema, ExtractionJobSchema, type ExtractionResult, ExtractionResultSchema, type ExtractionSchema, type ExtractionSchemaCreate, ExtractionSchemaCreateSchema, type ExtractionSchemaInfer, ExtractionSchemaInferSchema, ExtractionSchemaSchema, type ExtractionSchemaUpdate, ExtractionSchemaUpdateSchema, ExtractionService, type File, type FileCreate, FileCreateSchema, FileSchema, FilesService, FilterCondition, FilterConditionSchema, FilterOperator, FilterOperatorSchema, type GeminiEmbedding, type GeminiEmbeddingConfig, GeminiEmbeddingConfigSchema, GeminiEmbeddingSchema, type GenerateKeyApiV1ApiKeysPostData, type GenerateKeyApiV1ApiKeysPostError, type GenerateKeyApiV1ApiKeysPostResponse, type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetData, type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetError, type GeneratePresignedUrlApiParsingJobJobIdReadFilenameGetResponse, type GeneratePresignedUrlApiV1FilesPutData, type GeneratePresignedUrlApiV1FilesPutError, type GeneratePresignedUrlApiV1FilesPutResponse, type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetData, type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetError, type GeneratePresignedUrlApiV1ParsingJobJobIdReadFilenameGetResponse, type GetDataSinkApiV1DataSinksDataSinkIdGetData, type GetDataSinkApiV1DataSinksDataSinkIdGetError, type GetDataSinkApiV1DataSinksDataSinkIdGetResponse, type GetDataSourceApiV1DataSourcesDataSourceIdGetData, type GetDataSourceApiV1DataSourcesDataSourceIdGetError, type GetDataSourceApiV1DataSourcesDataSourceIdGetResponse, type GetDatasetApiV1EvalsDatasetsDatasetIdGetData, type GetDatasetApiV1EvalsDatasetsDatasetIdGetError, type GetDatasetApiV1EvalsDatasetsDatasetIdGetResponse, type GetDefaultOrganizationApiV1OrganizationsDefaultGetData, type GetDefaultOrganizationApiV1OrganizationsDefaultGetError, type GetDefaultOrganizationApiV1OrganizationsDefaultGetResponse, type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetData, type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetError, type GetEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGetResponse, type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetData, type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetError, type GetEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGetResponse, type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetData, type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetError, type GetEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGetResponse, type GetFileApiV1FilesIdGetData, type GetFileApiV1FilesIdGetError, type GetFileApiV1FilesIdGetResponse, type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetData, type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetError, type GetFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGetResponse, type GetJobApiParsingJobJobIdGetData, type GetJobApiParsingJobJobIdGetError, type GetJobApiParsingJobJobIdGetResponse, type GetJobApiV1ExtractionJobsJobIdGetData, type GetJobApiV1ExtractionJobsJobIdGetError, type GetJobApiV1ExtractionJobsJobIdGetResponse, type GetJobApiV1ParsingJobJobIdGetData, type GetJobApiV1ParsingJobJobIdGetError, type GetJobApiV1ParsingJobJobIdGetResponse, type GetJobImageResultApiParsingJobJobIdResultImageNameGetData, type GetJobImageResultApiParsingJobJobIdResultImageNameGetError, type GetJobImageResultApiParsingJobJobIdResultImageNameGetResponse, type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetData, type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetError, type GetJobImageResultApiV1ParsingJobJobIdResultImageNameGetResponse, type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetData, type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetError, type GetJobJsonRawResultApiParsingJobJobIdResultRawJsonGetResponse, type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetData, type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetError, type GetJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGetResponse, type GetJobJsonResultApiParsingJobJobIdResultJsonGetData, type GetJobJsonResultApiParsingJobJobIdResultJsonGetError, type GetJobJsonResultApiParsingJobJobIdResultJsonGetResponse, type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetData, type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetError, type GetJobJsonResultApiV1ParsingJobJobIdResultJsonGetResponse, type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetData, type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetError, type GetJobRawMdResultApiParsingJobJobIdResultRawMarkdownGetResponse, type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetData, type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetError, type GetJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGetResponse, type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetData, type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetError, type GetJobRawTextResultApiParsingJobJobIdResultRawTextGetResponse, type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetData, type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetError, type GetJobRawTextResultApiV1ParsingJobJobIdResultRawTextGetResponse, type GetJobResultApiParsingJobJobIdResultMarkdownGetData, type GetJobResultApiParsingJobJobIdResultMarkdownGetError, type GetJobResultApiParsingJobJobIdResultMarkdownGetResponse, type GetJobResultApiV1ExtractionJobsJobIdResultGetData, type GetJobResultApiV1ExtractionJobsJobIdResultGetError, type GetJobResultApiV1ExtractionJobsJobIdResultGetResponse, type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetData, type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetError, type GetJobResultApiV1ParsingJobJobIdResultMarkdownGetResponse, type GetJobTextResultApiParsingJobJobIdResultTextGetData, type GetJobTextResultApiParsingJobJobIdResultTextGetError, type GetJobTextResultApiParsingJobJobIdResultTextGetResponse, type GetJobTextResultApiV1ParsingJobJobIdResultTextGetData, type GetJobTextResultApiV1ParsingJobJobIdResultTextGetError, type GetJobTextResultApiV1ParsingJobJobIdResultTextGetResponse, type GetOrganizationApiV1OrganizationsOrganizationIdGetData, type GetOrganizationApiV1OrganizationsOrganizationIdGetError, type GetOrganizationApiV1OrganizationsOrganizationIdGetResponse, type GetParsingHistoryResultApiParsingHistoryGetData, type GetParsingHistoryResultApiParsingHistoryGetError, type GetParsingHistoryResultApiParsingHistoryGetResponse, type GetParsingHistoryResultApiV1ParsingHistoryGetData, type GetParsingHistoryResultApiV1ParsingHistoryGetError, type GetParsingHistoryResultApiV1ParsingHistoryGetResponse, type GetParsingJobDetailsApiParsingJobJobIdDetailsGetData, type GetParsingJobDetailsApiParsingJobJobIdDetailsGetError, type GetParsingJobDetailsApiParsingJobJobIdDetailsGetResponse, type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetData, type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetError, type GetParsingJobDetailsApiV1ParsingJobJobIdDetailsGetResponse, type GetPipelineApiV1PipelinesPipelineIdGetData, type GetPipelineApiV1PipelinesPipelineIdGetError, type GetPipelineApiV1PipelinesPipelineIdGetResponse, type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetData, type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetError, type GetPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGetResponse, type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetData, type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetError, type GetPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGetResponse, type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetData, type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetError, type GetPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGetResponse, type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetData, type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetError, type GetPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGetResponse, type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetData, type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetError, type GetPipelineJobApiV1PipelinesPipelineIdJobsJobIdGetResponse, type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetData, type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetError, type GetPipelineStatusApiV1PipelinesPipelineIdStatusGetResponse, type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetData, type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetError, type GetPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGetResponse, type GetProjectApiV1ProjectsProjectIdGetData, type GetProjectApiV1ProjectsProjectIdGetError, type GetProjectApiV1ProjectsProjectIdGetResponse, type GetQuestionApiV1EvalsQuestionsQuestionIdGetData, type GetQuestionApiV1EvalsQuestionsQuestionIdGetError, type GetQuestionApiV1EvalsQuestionsQuestionIdGetResponse, type GetSchemaApiV1ExtractionSchemasSchemaIdGetData, type GetSchemaApiV1ExtractionSchemasSchemaIdGetError, type GetSchemaApiV1ExtractionSchemasSchemaIdGetResponse, type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetError, type GetSupportedFileExtensionsApiParsingSupportedFileExtensionsGetResponse, type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetError, type GetSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGetResponse, type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetData, type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetError, type GetUserRoleApiV1OrganizationsOrganizationIdUsersRolesGetResponse, type HTTPValidationError, HTTPValidationErrorSchema, type HuggingFaceInferenceAPIEmbedding, type HuggingFaceInferenceAPIEmbeddingConfig, HuggingFaceInferenceAPIEmbeddingConfigSchema, HuggingFaceInferenceAPIEmbeddingSchema, type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutData, type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutError, type ImportPipelineMetadataApiV1PipelinesPipelineIdMetadataPutResponse, type InferSchemaApiV1ExtractionSchemasInferPostData, type InferSchemaApiV1ExtractionSchemasInferPostError, type InferSchemaApiV1ExtractionSchemasInferPostResponse, type IngestionErrorResponse, IngestionErrorResponseSchema, type InputMessage, InputMessageSchema, JobNameMapping, JobNameMappingSchema, type LLM, type LLMModelData, LLMModelDataSchema, type LLMParameters, LLMParametersSchema, LLMSchema, type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetError, type ListDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGetResponse, type ListDataSinksApiV1DataSinksGetData, type ListDataSinksApiV1DataSinksGetError, type ListDataSinksApiV1DataSinksGetResponse, type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetError, type ListDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGetResponse, type ListDataSourcesApiV1DataSourcesGetData, type ListDataSourcesApiV1DataSourcesGetError, type ListDataSourcesApiV1DataSourcesGetResponse, type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetData, type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetError, type ListDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGetResponse, type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetData, type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetError, type ListFilePageScreenshotsApiV1FilesIdPageScreenshotsGetResponse, type ListFilesApiV1FilesGetData, type ListFilesApiV1FilesGetError, type ListFilesApiV1FilesGetResponse, type ListJobsApiV1ExtractionJobsGetData, type ListJobsApiV1ExtractionJobsGetError, type ListJobsApiV1ExtractionJobsGetResponse, type ListKeysApiV1ApiKeysGetData, type ListKeysApiV1ApiKeysGetError, type ListKeysApiV1ApiKeysGetResponse, type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetData, type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetError, type ListLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGetResponse, type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetData, type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetError, type ListLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGetResponse, type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetData, type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetError, type ListOrganizationUsersApiV1OrganizationsOrganizationIdUsersGetResponse, type ListOrganizationsApiV1OrganizationsGetData, type ListOrganizationsApiV1OrganizationsGetError, type ListOrganizationsApiV1OrganizationsGetResponse, type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetData, type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetError, type ListPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGetResponse, type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetData, type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetError, type ListPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGetResponse, type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetData, type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetError, type ListPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGetResponse, type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetData, type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetError, type ListPipelineFilesApiV1PipelinesPipelineIdFilesGetResponse, type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetData, type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetError, type ListPipelineJobsApiV1PipelinesPipelineIdJobsGetResponse, type ListProjectsApiV1ProjectsGetData, type ListProjectsApiV1ProjectsGetError, type ListProjectsApiV1ProjectsGetResponse, type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetData, type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetError, type ListProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGetResponse, type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetData, type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetError, type ListPromptmixinPromptsApiV1ProjectsProjectIdPromptsGetResponse, type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetData, type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetError, type ListQuestionsApiV1EvalsDatasetsDatasetIdQuestionGetResponse, type ListRolesApiV1OrganizationsOrganizationIdRolesGetData, type ListRolesApiV1OrganizationsOrganizationIdRolesGetError, type ListRolesApiV1OrganizationsOrganizationIdRolesGetResponse, type ListSchemasApiV1ExtractionSchemasGetData, type ListSchemasApiV1ExtractionSchemasGetError, type ListSchemasApiV1ExtractionSchemasGetResponse, type ListSupportedModelsApiV1EvalsModelsGetData, type ListSupportedModelsApiV1EvalsModelsGetError, type ListSupportedModelsApiV1EvalsModelsGetResponse, type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetError, type ListTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGetResponse, type LlamaParseParameters, LlamaParseParametersSchema, LlamaParseSupportedFileExtensions, LlamaParseSupportedFileExtensionsSchema, type LocalEval, type LocalEvalResults, LocalEvalResultsSchema, LocalEvalSchema, type LocalEvalSetCreate, LocalEvalSetCreateSchema, type LocalEvalSets, LocalEvalSetsSchema, ManagedIngestionStatus, type ManagedIngestionStatusResponse, ManagedIngestionStatusResponseSchema, ManagedIngestionStatusSchema, type MarkdownElementNodeParser, MarkdownElementNodeParserSchema, type MarkdownNodeParser, MarkdownNodeParserSchema, type MessageAnnotation, MessageAnnotationSchema, MessageRole, MessageRoleSchema, type MetadataFilter, MetadataFilterSchema, type MetadataFilters, MetadataFiltersSchema, type MetricResult, MetricResultSchema, type NodeParser, NodeParserSchema, NodeRelationship, NodeRelationshipSchema, type NoneChunkingConfig, NoneChunkingConfigSchema, type NoneSegmentationConfig, NoneSegmentationConfigSchema, ObjectType, ObjectTypeSchema, type OpenAIEmbedding, type OpenAIEmbeddingConfig, OpenAIEmbeddingConfigSchema, OpenAIEmbeddingSchema, type Organization, type OrganizationCreate, OrganizationCreateSchema, OrganizationSchema, type OrganizationUpdate, OrganizationUpdateSchema, OrganizationsService, type PageScreenshotMetadata, PageScreenshotMetadataSchema, type PageScreenshotNodeWithScore, PageScreenshotNodeWithScoreSchema, type PageSegmentationConfig, PageSegmentationConfigSchema, type PageSplitterNodeParser, PageSplitterNodeParserSchema, ParserLanguages, ParserLanguagesSchema, type ParsingHistoryItem, ParsingHistoryItemSchema, type ParsingJob, type ParsingJobJsonResult, ParsingJobJsonResultSchema, type ParsingJobMarkdownResult, ParsingJobMarkdownResultSchema, ParsingJobSchema, type ParsingJobTextResult, ParsingJobTextResultSchema, ParsingService, type ParsingUsage, ParsingUsageSchema, PartitionNames, PartitionNamesSchema, type Permission, PermissionSchema, type Pipeline, type PipelineConfigurationHashes, PipelineConfigurationHashesSchema, type PipelineCreate, PipelineCreateSchema, type PipelineDataSource, type PipelineDataSourceCreate, PipelineDataSourceCreateSchema, PipelineDataSourceSchema, type PipelineDataSourceUpdate, PipelineDataSourceUpdateSchema, type PipelineDeployment, PipelineDeploymentSchema, type PipelineFile, type PipelineFileCreate, PipelineFileCreateSchema, PipelineFileSchema, type PipelineFileUpdate, PipelineFileUpdateSchema, PipelineSchema, PipelineType, PipelineTypeSchema, type PipelineUpdate, PipelineUpdateSchema, PipelinesService, type PlaygroundSession, PlaygroundSessionSchema, Pooling, PoolingSchema, type PresetRetrievalParams, PresetRetrievalParamsSchema, type PresignedUrl, PresignedUrlSchema, type Project, type ProjectCreate, ProjectCreateSchema, ProjectSchema, type ProjectUpdate, ProjectUpdateSchema, ProjectsService, type PromptMixinPrompts, PromptMixinPromptsSchema, type PromptSpec, PromptSpecSchema, PydanticProgramMode, PydanticProgramModeSchema, type ReadFileContentApiV1FilesIdContentGetData, type ReadFileContentApiV1FilesIdContentGetError, type ReadFileContentApiV1FilesIdContentGetResponse, type RelatedNodeInfo, RelatedNodeInfoSchema, type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteData, type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteError, type RemoveUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDeleteResponse, type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteData, type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteError, type RemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDeleteResponse, type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutData, type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutError, type ReplaceQuestionApiV1EvalsQuestionsQuestionIdPutResponse, RetrievalMode, RetrievalModeSchema, type RetrievalParams, RetrievalParamsSchema, type RetrieveResults, RetrieveResultsSchema, type Role, RoleSchema, type RunJobApiV1ExtractionJobsPostData, type RunJobApiV1ExtractionJobsPostError, type RunJobApiV1ExtractionJobsPostResponse, type RunJobsInBatchApiV1ExtractionJobsBatchPostData, type RunJobsInBatchApiV1ExtractionJobsBatchPostError, type RunJobsInBatchApiV1ExtractionJobsBatchPostResponse, type RunSearchApiV1PipelinesPipelineIdRetrievePostData, type RunSearchApiV1PipelinesPipelineIdRetrievePostError, type RunSearchApiV1PipelinesPipelineIdRetrievePostResponse, type SearchPipelinesApiV1PipelinesGetData, type SearchPipelinesApiV1PipelinesGetError, type SearchPipelinesApiV1PipelinesGetResponse, type SemanticChunkingConfig, SemanticChunkingConfigSchema, type SentenceChunkingConfig, SentenceChunkingConfigSchema, type SentenceSplitter, SentenceSplitterSchema, type SetDefaultOrganizationApiV1OrganizationsDefaultPutData, type SetDefaultOrganizationApiV1OrganizationsDefaultPutError, type SetDefaultOrganizationApiV1OrganizationsDefaultPutResponse, StatusEnum, StatusEnumSchema, type StripeWebhookApiV1BillingWebhookPostData, type StripeWebhookApiV1BillingWebhookPostError, type StripeWebhookApiV1BillingWebhookPostResponse, type SupportedLLMModel, SupportedLLMModelNames, SupportedLLMModelNamesSchema, SupportedLLMModelSchema, type SyncFilesApiV1FilesSyncPutData, type SyncFilesApiV1FilesSyncPutError, type SyncFilesApiV1FilesSyncPutResponse, type SyncPipelineApiV1PipelinesPipelineIdSyncPostData, type SyncPipelineApiV1PipelinesPipelineIdSyncPostError, type SyncPipelineApiV1PipelinesPipelineIdSyncPostResponse, type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostData, type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostError, type SyncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPostResponse, type TextNode, TextNodeSchema, type TextNodeWithScore, TextNodeWithScoreSchema, type TokenChunkingConfig, TokenChunkingConfigSchema, type TokenTextSplitter, TokenTextSplitterSchema, TransformationCategoryNames, TransformationCategoryNamesSchema, type UpdateDataSinkApiV1DataSinksDataSinkIdPutData, type UpdateDataSinkApiV1DataSinksDataSinkIdPutError, type UpdateDataSinkApiV1DataSinksDataSinkIdPutResponse, type UpdateDataSourceApiV1DataSourcesDataSourceIdPutData, type UpdateDataSourceApiV1DataSourcesDataSourceIdPutError, type UpdateDataSourceApiV1DataSourcesDataSourceIdPutResponse, type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutData, type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutError, type UpdateDatasetApiV1EvalsDatasetsDatasetIdPutResponse, type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutData, type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutError, type UpdateExistingApiKeyApiV1ApiKeysApiKeyIdPutResponse, type UpdateExistingPipelineApiV1PipelinesPipelineIdPutData, type UpdateExistingPipelineApiV1PipelinesPipelineIdPutError, type UpdateExistingPipelineApiV1PipelinesPipelineIdPutResponse, type UpdateExistingProjectApiV1ProjectsProjectIdPutData, type UpdateExistingProjectApiV1ProjectsProjectIdPutError, type UpdateExistingProjectApiV1ProjectsProjectIdPutResponse, type UpdateOrganizationApiV1OrganizationsOrganizationIdPutData, type UpdateOrganizationApiV1OrganizationsOrganizationIdPutError, type UpdateOrganizationApiV1OrganizationsOrganizationIdPutResponse, type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutData, type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutError, type UpdatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPutResponse, type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutData, type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutError, type UpdatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPutResponse, type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutData, type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutError, type UpdatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPutResponse, type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutData, type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutError, type UpdateSchemaApiV1ExtractionSchemasSchemaIdPutResponse, type UploadFileApiParsingUploadPostData, type UploadFileApiParsingUploadPostError, type UploadFileApiParsingUploadPostResponse, type UploadFileApiV1FilesPostData, type UploadFileApiV1FilesPostError, type UploadFileApiV1FilesPostResponse, type UploadFileApiV1ParsingUploadPostData, type UploadFileApiV1ParsingUploadPostError, type UploadFileApiV1ParsingUploadPostResponse, type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutData, type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutError, type UpsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPutResponse, type UpsertDataSinkApiV1DataSinksPutData, type UpsertDataSinkApiV1DataSinksPutError, type UpsertDataSinkApiV1DataSinksPutResponse, type UpsertDataSourceApiV1DataSourcesPutData, type UpsertDataSourceApiV1DataSourcesPutError, type UpsertDataSourceApiV1DataSourcesPutResponse, type UpsertOrganizationApiV1OrganizationsPutData, type UpsertOrganizationApiV1OrganizationsPutError, type UpsertOrganizationApiV1OrganizationsPutResponse, type UpsertPipelineApiV1PipelinesPutData, type UpsertPipelineApiV1PipelinesPutError, type UpsertPipelineApiV1PipelinesPutResponse, type UpsertProjectApiV1ProjectsPutData, type UpsertProjectApiV1ProjectsPutError, type UpsertProjectApiV1ProjectsPutResponse, type UsageApiParsingUsageGetData, type UsageApiParsingUsageGetError, type UsageApiParsingUsageGetResponse, type UsageApiV1ParsingUsageGetData, type UsageApiV1ParsingUsageGetError, type UsageApiV1ParsingUsageGetResponse, type UserOrganization, type UserOrganizationCreate, UserOrganizationCreateSchema, type UserOrganizationDelete, UserOrganizationDeleteSchema, type UserOrganizationRole, type UserOrganizationRoleCreate, UserOrganizationRoleCreateSchema, UserOrganizationRoleSchema, UserOrganizationSchema, type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostData, type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostError, type ValidateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPostResponse, type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostData, type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostError, type ValidateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPostResponse, type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostData, type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostError, type ValidateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPostResponse, type ValidationError, ValidationErrorSchema, ValidationService, type VertexAIEmbeddingConfig, VertexAIEmbeddingConfigSchema, VertexEmbeddingMode, VertexEmbeddingModeSchema, type VertexTextEmbedding, VertexTextEmbeddingSchema, client, job_name, mode, mode2, mode3, mode4, mode5, mode6, mode7, mode8, mode9, type, type2, type3, type4, type5, type6, type7 };
