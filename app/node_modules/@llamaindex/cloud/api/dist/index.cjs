Object.defineProperty(exports, '__esModule', { value: true });

// This file is auto-generated by @hey-api/openapi-ts
const APIKeySchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 0
                },
                {
                    type: "null"
                }
            ],
            title: "Name"
        },
        user_id: {
            type: "string",
            title: "User Id"
        },
        redacted_api_key: {
            type: "string",
            title: "Redacted Api Key"
        }
    },
    type: "object",
    required: [
        "id",
        "user_id",
        "redacted_api_key"
    ],
    title: "APIKey",
    description: "Schema for an API Key."
};
const APIKeyCreateSchema = {
    properties: {
        name: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 0
                },
                {
                    type: "null"
                }
            ],
            title: "Name"
        }
    },
    type: "object",
    title: "APIKeyCreate",
    description: "Schema for creating an API key."
};
const APIKeyUpdateSchema = {
    properties: {
        name: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 0
                },
                {
                    type: "null"
                }
            ],
            title: "Name"
        }
    },
    type: "object",
    title: "APIKeyUpdate",
    description: "Schema for updating an API key."
};
const AdvancedModeTransformConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "advanced"
            ],
            const: "advanced",
            title: "Mode",
            default: "advanced"
        },
        segmentation_config: {
            anyOf: [
                {
                    $ref: "#/components/schemas/NoneSegmentationConfig"
                },
                {
                    $ref: "#/components/schemas/PageSegmentationConfig"
                },
                {
                    $ref: "#/components/schemas/ElementSegmentationConfig"
                }
            ],
            title: "Segmentation Config",
            description: "Configuration for the segmentation."
        },
        chunking_config: {
            anyOf: [
                {
                    $ref: "#/components/schemas/NoneChunkingConfig"
                },
                {
                    $ref: "#/components/schemas/CharacterChunkingConfig"
                },
                {
                    $ref: "#/components/schemas/TokenChunkingConfig"
                },
                {
                    $ref: "#/components/schemas/SentenceChunkingConfig"
                },
                {
                    $ref: "#/components/schemas/SemanticChunkingConfig"
                }
            ],
            title: "Chunking Config",
            description: "Configuration for the chunking."
        }
    },
    type: "object",
    title: "AdvancedModeTransformConfig"
};
const AutoTransformConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "auto"
            ],
            const: "auto",
            title: "Mode",
            default: "auto"
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "Chunk size for the transformation.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            description: "Chunk overlap for the transformation.",
            default: 200,
            gte: 0
        }
    },
    type: "object",
    title: "AutoTransformConfig"
};
const AzureOpenAIEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the OpenAI embedding model.",
            default: "text-embedding-ada-002"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the OpenAI API."
        },
        api_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Key",
            description: "The OpenAI API key."
        },
        api_base: {
            type: "string",
            title: "Api Base",
            description: "The base URL for Azure deployment.",
            default: ""
        },
        api_version: {
            type: "string",
            title: "Api Version",
            description: "The version for Azure OpenAI API.",
            default: ""
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            description: "Maximum number of retries.",
            default: 10,
            gte: 0
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "Timeout for each request.",
            default: 60,
            gte: 0
        },
        default_headers: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Default Headers",
            description: "The default headers for API requests."
        },
        reuse_client: {
            type: "boolean",
            title: "Reuse Client",
            description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
            default: true
        },
        dimensions: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Dimensions",
            description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models."
        },
        azure_endpoint: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Endpoint",
            description: "The Azure endpoint to use."
        },
        azure_deployment: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Deployment",
            description: "The Azure deployment to use."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "AzureOpenAIEmbedding"
        }
    },
    type: "object",
    title: "AzureOpenAIEmbedding"
};
const AzureOpenAIEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "AZURE_EMBEDDING"
            ],
            const: "AZURE_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "AZURE_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/AzureOpenAIEmbedding",
            description: "Configuration for the Azure OpenAI embedding model."
        }
    },
    type: "object",
    title: "AzureOpenAIEmbeddingConfig"
};
const BaseSchema = {
    properties: {},
    type: "object",
    title: "Base"
};
const BaseConnectionValidationSchema = {
    properties: {
        success: {
            type: "boolean",
            title: "Success"
        },
        message: {
            type: "string",
            title: "Message"
        }
    },
    type: "object",
    required: [
        "success",
        "message"
    ],
    title: "BaseConnectionValidation",
    description: "Base response model for connection validation."
};
const BasePromptTemplateSchema = {
    properties: {
        metadata: {
            type: "object",
            title: "Metadata"
        },
        template_vars: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Template Vars"
        },
        kwargs: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Kwargs"
        },
        output_parser: {
            anyOf: [
                {},
                {
                    type: "null"
                }
            ],
            title: "Output Parser"
        },
        template_var_mappings: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Template Var Mappings",
            description: "Template variable mappings (Optional)."
        },
        function_mappings: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Function Mappings",
            description: "Function mappings (Optional). This is a mapping from template variable names to functions that take in the current kwargs and return a string."
        }
    },
    type: "object",
    required: [
        "metadata",
        "template_vars",
        "kwargs",
        "output_parser"
    ],
    title: "BasePromptTemplate"
};
const BedrockEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The modelId of the Bedrock model to use.",
            default: "amazon.titan-embed-text-v1"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        profile_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Profile Name",
            description: "The name of aws profile to use. If not given, then the default profile is used."
        },
        aws_access_key_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Aws Access Key Id",
            description: "AWS Access Key ID to use"
        },
        aws_secret_access_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Aws Secret Access Key",
            description: "AWS Secret Access Key to use"
        },
        aws_session_token: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Aws Session Token",
            description: "AWS Session Token to use"
        },
        region_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Region Name",
            description: "AWS region name to use. Uses region configured in AWS CLI if not passed"
        },
        max_retries: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Max Retries",
            description: "The maximum number of API retries.",
            default: 10
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "The timeout for the Bedrock API request in seconds. It will be used for both connect and read timeouts.",
            default: 60
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the bedrock client."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "BedrockEmbedding"
        }
    },
    type: "object",
    title: "BedrockEmbedding"
};
const BedrockEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "BEDROCK_EMBEDDING"
            ],
            const: "BEDROCK_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "BEDROCK_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/BedrockEmbedding",
            description: "Configuration for the Bedrock embedding model."
        }
    },
    type: "object",
    title: "BedrockEmbeddingConfig"
};
const Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema = {
    properties: {
        upload_file: {
            type: "string",
            format: "binary",
            title: "Upload File"
        }
    },
    type: "object",
    required: [
        "upload_file"
    ],
    title: "Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_put"
};
const Body_upload_file_api_parsing_upload_postSchema = {
    properties: {
        language: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            title: "Language",
            default: [
                "en"
            ]
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: false
        },
        premium_mode: {
            type: "boolean",
            title: "Premium Mode",
            default: false
        },
        continuous_mode: {
            type: "boolean",
            title: "Continuous Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            type: "string",
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "boolean",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name"
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        },
        webhook_url: {
            type: "string",
            title: "Webhook Url",
            default: ""
        },
        take_screenshot: {
            type: "boolean",
            title: "Take Screenshot",
            default: false
        },
        is_formatting_instruction: {
            type: "boolean",
            title: "Is Formatting Instruction",
            default: true
        },
        disable_ocr: {
            type: "boolean",
            title: "Disable Ocr",
            default: false
        },
        annotate_links: {
            type: "boolean",
            title: "Annotate Links",
            default: false
        },
        disable_reconstruction: {
            type: "boolean",
            title: "Disable Reconstruction",
            default: false
        },
        input_s3_path: {
            type: "string",
            title: "Input S3 Path",
            default: ""
        },
        output_s3_path_prefix: {
            type: "string",
            title: "Output S3 Path Prefix",
            default: ""
        },
        azure_openai_deployment_name: {
            type: "string",
            title: "Azure Openai Deployment Name"
        },
        azure_openai_endpoint: {
            type: "string",
            title: "Azure Openai Endpoint"
        },
        azure_openai_api_version: {
            type: "string",
            title: "Azure Openai Api Version"
        },
        azure_openai_key: {
            type: "string",
            title: "Azure Openai Key"
        },
        file: {
            anyOf: [
                {
                    type: "string",
                    format: "binary"
                },
                {
                    type: "null"
                }
            ],
            title: "File"
        }
    },
    type: "object",
    title: "Body_upload_file_api_parsing_upload_post"
};
const Body_upload_file_api_v1_files_postSchema = {
    properties: {
        upload_file: {
            type: "string",
            format: "binary",
            title: "Upload File"
        }
    },
    type: "object",
    required: [
        "upload_file"
    ],
    title: "Body_upload_file_api_v1_files_post"
};
const Body_upload_file_api_v1_parsing_upload_postSchema = {
    properties: {
        language: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            title: "Language",
            default: [
                "en"
            ]
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: false
        },
        premium_mode: {
            type: "boolean",
            title: "Premium Mode",
            default: false
        },
        continuous_mode: {
            type: "boolean",
            title: "Continuous Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            type: "string",
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "boolean",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name"
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        },
        webhook_url: {
            type: "string",
            title: "Webhook Url",
            default: ""
        },
        take_screenshot: {
            type: "boolean",
            title: "Take Screenshot",
            default: false
        },
        is_formatting_instruction: {
            type: "boolean",
            title: "Is Formatting Instruction",
            default: true
        },
        disable_ocr: {
            type: "boolean",
            title: "Disable Ocr",
            default: false
        },
        annotate_links: {
            type: "boolean",
            title: "Annotate Links",
            default: false
        },
        disable_reconstruction: {
            type: "boolean",
            title: "Disable Reconstruction",
            default: false
        },
        input_s3_path: {
            type: "string",
            title: "Input S3 Path",
            default: ""
        },
        output_s3_path_prefix: {
            type: "string",
            title: "Output S3 Path Prefix",
            default: ""
        },
        azure_openai_deployment_name: {
            type: "string",
            title: "Azure Openai Deployment Name"
        },
        azure_openai_endpoint: {
            type: "string",
            title: "Azure Openai Endpoint"
        },
        azure_openai_api_version: {
            type: "string",
            title: "Azure Openai Api Version"
        },
        azure_openai_key: {
            type: "string",
            title: "Azure Openai Key"
        },
        file: {
            anyOf: [
                {
                    type: "string",
                    format: "binary"
                },
                {
                    type: "null"
                }
            ],
            title: "File"
        }
    },
    type: "object",
    title: "Body_upload_file_api_v1_parsing_upload_post"
};
const BoxAuthMechanismSchema = {
    type: "string",
    enum: [
        "developer_token",
        "ccg"
    ],
    title: "BoxAuthMechanism"
};
const CharacterChunkingConfigSchema = {
    properties: {
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            default: 200,
            gte: 0
        },
        mode: {
            type: "string",
            enum: [
                "character"
            ],
            const: "character",
            title: "Mode",
            default: "character"
        }
    },
    type: "object",
    title: "CharacterChunkingConfig"
};
const CharacterSplitterSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "The token chunk size for each chunk.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            minimum: 0,
            title: "Chunk Overlap",
            description: "The token overlap of each chunk when splitting.",
            default: 200
        },
        separator: {
            type: "string",
            title: "Separator",
            description: "Default separator for splitting into words",
            default: " "
        },
        paragraph_separator: {
            type: "string",
            title: "Paragraph Separator",
            description: "Separator between paragraphs.",
            default: `


`
        },
        secondary_chunking_regex: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Secondary Chunking Regex",
            description: "Backup regex for splitting into sentences.",
            default: "[^,.;。？！]+[,.;。？！]?"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "SentenceSplitter"
        }
    },
    type: "object",
    title: "CharacterSplitter",
    description: "A splitter that splits text into characters."
};
const ChatDataSchema = {
    properties: {
        retrieval_parameters: {
            $ref: "#/components/schemas/PresetRetrievalParams"
        },
        llm_parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/LLMParameters"
                },
                {
                    type: "null"
                }
            ]
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "ChatData"
};
const ChatInputParamsSchema = {
    properties: {
        messages: {
            items: {
                $ref: "#/components/schemas/InputMessage"
            },
            type: "array",
            title: "Messages"
        },
        data: {
            $ref: "#/components/schemas/ChatData"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "ChatInputParams"
};
const ChatMessageSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id"
        },
        index: {
            type: "integer",
            title: "Index",
            description: "The index of the message in the chat."
        },
        annotations: {
            items: {
                $ref: "#/components/schemas/MessageAnnotation"
            },
            type: "array",
            title: "Annotations",
            description: "Retrieval annotations for the message."
        },
        role: {
            $ref: "#/components/schemas/MessageRole"
        },
        content: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Content",
            description: "Text content of the generation"
        },
        additional_kwargs: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Additional Kwargs",
            description: "Additional arguments passed to the model"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "id",
        "index",
        "role"
    ],
    title: "ChatMessage"
};
const CheckoutSessionCreatePayloadSchema = {
    properties: {
        success_url: {
            type: "string",
            minLength: 1,
            format: "uri",
            title: "Success Url"
        },
        cancel_url: {
            type: "string",
            minLength: 1,
            format: "uri",
            title: "Cancel Url"
        }
    },
    type: "object",
    required: [
        "success_url",
        "cancel_url"
    ],
    title: "CheckoutSessionCreatePayload"
};
const CloudAzStorageBlobDataSourceSchema = {
    properties: {
        container_name: {
            type: "string",
            title: "Container Name",
            description: "The name of the Azure Storage Blob container to read from."
        },
        account_url: {
            type: "string",
            title: "Account Url",
            description: "The Azure Storage Blob account URL to use for authentication."
        },
        blob: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Blob",
            description: "The blob name to read from."
        },
        prefix: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Prefix",
            description: "The prefix of the Azure Storage Blob objects to read from."
        },
        account_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Account Name",
            description: "The Azure Storage Blob account name to use for authentication."
        },
        account_key: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Account Key",
            description: "The Azure Storage Blob account key to use for authentication."
        },
        tenant_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Tenant Id",
            description: "The Azure AD tenant ID to use for authentication."
        },
        client_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Client Id",
            description: "The Azure AD client ID to use for authentication."
        },
        client_secret: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Client Secret",
            description: "The Azure AD client secret to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudAzStorageBlobDataSource"
        }
    },
    type: "object",
    required: [
        "container_name",
        "account_url"
    ],
    title: "CloudAzStorageBlobDataSource"
};
const CloudAzureAISearchVectorStoreSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                true
            ],
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        search_service_api_key: {
            type: "string",
            format: "password",
            title: "Search Service Api Key",
            writeOnly: true
        },
        search_service_endpoint: {
            type: "string",
            title: "Search Service Endpoint"
        },
        search_service_api_version: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Search Service Api Version"
        },
        index_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Index Name"
        },
        filterable_metadata_field_keys: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Filterable Metadata Field Keys"
        },
        embedding_dimension: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding Dimension"
        },
        client_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Client Id"
        },
        client_secret: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Client Secret"
        },
        tenant_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Tenant Id"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudAzureAISearchVectorStore"
        }
    },
    type: "object",
    required: [
        "search_service_api_key",
        "search_service_endpoint"
    ],
    title: "CloudAzureAISearchVectorStore",
    description: "Cloud Azure AI Search Vector Store."
};
const CloudBoxDataSourceSchema = {
    properties: {
        folder_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Folder Id",
            description: "The ID of the Box folder to read from."
        },
        authentication_mechanism: {
            $ref: "#/components/schemas/BoxAuthMechanism",
            description: "The type of authentication to use (Developer Token or CCG)"
        },
        developer_token: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Developer Token",
            description: "Developer token for authentication if authentication_mechanism is 'developer_token'."
        },
        client_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Client Id",
            description: "Box API key used for identifying the application the user is authenticating with"
        },
        client_secret: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Client Secret",
            description: "Box API secret used for making auth requests."
        },
        user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Id",
            description: "Box User ID, if provided authenticates as user."
        },
        enterprise_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Enterprise Id",
            description: "Box Enterprise ID, if provided authenticates as service."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudBoxDataSource"
        }
    },
    type: "object",
    required: [
        "authentication_mechanism"
    ],
    title: "CloudBoxDataSource"
};
const CloudConfluenceDataSourceSchema = {
    properties: {
        server_url: {
            type: "string",
            title: "Server Url",
            description: "The server URL of the Confluence instance."
        },
        authentication_mechanism: {
            type: "string",
            title: "Authentication Mechanism",
            description: "Type of Authentication for connecting to Confluence APIs."
        },
        user_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Name",
            description: "The username to use for authentication."
        },
        api_token: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Api Token",
            description: "The API token to use for authentication."
        },
        space_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Space Key",
            description: "The space key to read from."
        },
        page_ids: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Ids",
            description: "The page IDs of the Confluence to read from."
        },
        cql: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Cql",
            description: "The CQL query to use for fetching pages."
        },
        label: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Label",
            description: "The label to use for fetching pages."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudConfluenceDataSource"
        }
    },
    type: "object",
    required: [
        "server_url",
        "authentication_mechanism"
    ],
    title: "CloudConfluenceDataSource"
};
const CloudDocumentSchema = {
    properties: {
        text: {
            type: "string",
            title: "Text"
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            default: []
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            default: []
        },
        page_positions: {
            anyOf: [
                {
                    items: {
                        type: "integer"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Positions",
            description: "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1]."
        },
        id: {
            type: "string",
            title: "Id"
        }
    },
    type: "object",
    required: [
        "text",
        "metadata",
        "id"
    ],
    title: "CloudDocument",
    description: "Cloud document stored in S3."
};
const CloudDocumentCreateSchema = {
    properties: {
        text: {
            type: "string",
            title: "Text"
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            default: []
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            default: []
        },
        page_positions: {
            anyOf: [
                {
                    items: {
                        type: "integer"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Positions",
            description: "indices in the CloudDocument.text where a new page begins. e.g. Second page starts at index specified by page_positions[1]."
        },
        id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id"
        }
    },
    type: "object",
    required: [
        "text",
        "metadata"
    ],
    title: "CloudDocumentCreate",
    description: "Create a new cloud document."
};
const CloudGoogleDriveDataSourceSchema = {
    properties: {
        folder_id: {
            type: "string",
            title: "Folder Id",
            description: "The ID of the Google Drive folder to read from."
        },
        service_account_key: {
            type: "object",
            title: "Service Account Key",
            description: "The service account key JSON to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudGoogleDriveDataSource"
        }
    },
    type: "object",
    required: [
        "folder_id",
        "service_account_key"
    ],
    title: "CloudGoogleDriveDataSource"
};
const CloudJiraDataSourceSchema = {
    properties: {
        email: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Email",
            description: "The email address to use for authentication."
        },
        api_token: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Api Token",
            description: "The API/ Access Token used for Basic, PAT and OAuth2 authentication."
        },
        server_url: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Server Url",
            description: "The server url for Jira Cloud."
        },
        cloud_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Cloud Id",
            description: "The cloud ID, used in case of OAuth2."
        },
        authentication_mechanism: {
            type: "string",
            title: "Authentication Mechanism",
            description: "Type of Authentication for connecting to Jira APIs."
        },
        query: {
            type: "string",
            title: "Query",
            description: "JQL (Jira Query Language) query to search."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudJiraDataSource"
        }
    },
    type: "object",
    required: [
        "authentication_mechanism",
        "query"
    ],
    title: "CloudJiraDataSource",
    description: "Cloud Jira Data Source integrating JiraReader."
};
const CloudMilvusVectorStoreSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                false
            ],
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        uri: {
            type: "string",
            title: "Uri"
        },
        collection_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Collection Name"
        },
        token: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Token"
        },
        embedding_dimension: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding Dimension"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudMilvusVectorStore"
        }
    },
    type: "object",
    required: [
        "uri"
    ],
    title: "CloudMilvusVectorStore",
    description: "Cloud Milvus Vector Store."
};
const CloudMongoDBAtlasVectorSearchSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                false
            ],
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        mongodb_uri: {
            type: "string",
            format: "password",
            title: "Mongodb Uri",
            writeOnly: true
        },
        db_name: {
            type: "string",
            title: "Db Name"
        },
        collection_name: {
            type: "string",
            title: "Collection Name"
        },
        vector_index_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Vector Index Name"
        },
        fulltext_index_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Fulltext Index Name"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudMongoDBAtlasVectorSearch"
        }
    },
    type: "object",
    required: [
        "mongodb_uri",
        "db_name",
        "collection_name"
    ],
    title: "CloudMongoDBAtlasVectorSearch",
    description: `Cloud MongoDB Atlas Vector Store.

This class is used to store the configuration for a MongoDB Atlas vector store,
so that it can be created and used in LlamaCloud.

Args:
    mongodb_uri (str): URI for connecting to MongoDB Atlas
    db_name (str): name of the MongoDB database
    collection_name (str): name of the MongoDB collection
    vector_index_name (str): name of the MongoDB Atlas vector index
    fulltext_index_name (str): name of the MongoDB Atlas full-text index`
};
const CloudNotionPageDataSourceSchema = {
    properties: {
        integration_token: {
            type: "string",
            format: "password",
            title: "Integration Token",
            description: "The integration token to use for authentication.",
            writeOnly: true
        },
        database_ids: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Database Ids",
            description: "The Notion Database Id to read content from."
        },
        page_ids: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Ids",
            description: "The Page ID's of the Notion to read from."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudNotionPageDataSource"
        }
    },
    type: "object",
    required: [
        "integration_token"
    ],
    title: "CloudNotionPageDataSource"
};
const CloudOneDriveDataSourceSchema = {
    properties: {
        user_principal_name: {
            type: "string",
            title: "User Principal Name",
            description: "The user principal name to use for authentication."
        },
        folder_path: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Folder Path",
            description: "The path of the OneDrive folder to read from."
        },
        folder_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Folder Id",
            description: "The ID of the OneDrive folder to read from."
        },
        client_id: {
            type: "string",
            title: "Client Id",
            description: "The client ID to use for authentication."
        },
        client_secret: {
            type: "string",
            format: "password",
            title: "Client Secret",
            description: "The client secret to use for authentication.",
            writeOnly: true
        },
        tenant_id: {
            type: "string",
            title: "Tenant Id",
            description: "The tenant ID to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudOneDriveDataSource"
        }
    },
    type: "object",
    required: [
        "user_principal_name",
        "client_id",
        "client_secret",
        "tenant_id"
    ],
    title: "CloudOneDriveDataSource"
};
const CloudPineconeVectorStoreSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                true
            ],
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        api_key: {
            type: "string",
            format: "password",
            title: "Api Key",
            description: "The API key for authenticating with Pinecone",
            writeOnly: true
        },
        index_name: {
            type: "string",
            title: "Index Name"
        },
        namespace: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Namespace"
        },
        insert_kwargs: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Insert Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudPineconeVectorStore"
        }
    },
    type: "object",
    required: [
        "api_key",
        "index_name"
    ],
    title: "CloudPineconeVectorStore",
    description: `Cloud Pinecone Vector Store.

This class is used to store the configuration for a Pinecone vector store, so that it can be
created and used in LlamaCloud.

Args:
    api_key (str): API key for authenticating with Pinecone
    index_name (str): name of the Pinecone index
    namespace (optional[str]): namespace to use in the Pinecone index
    insert_kwargs (optional[dict]): additional kwargs to pass during insertion`
};
const CloudPostgresVectorStoreSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                false
            ],
            const: false,
            title: "Supports Nested Metadata Filters",
            default: false
        },
        database: {
            type: "string",
            title: "Database"
        },
        host: {
            type: "string",
            title: "Host"
        },
        password: {
            type: "string",
            format: "password",
            title: "Password",
            writeOnly: true
        },
        port: {
            type: "string",
            title: "Port"
        },
        user: {
            type: "string",
            title: "User"
        },
        table_name: {
            type: "string",
            title: "Table Name"
        },
        schema_name: {
            type: "string",
            title: "Schema Name"
        },
        embed_dim: {
            type: "integer",
            title: "Embed Dim"
        },
        hybrid_search: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Hybrid Search",
            default: true
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudPostgresVectorStore"
        }
    },
    type: "object",
    required: [
        "database",
        "host",
        "password",
        "port",
        "user",
        "table_name",
        "schema_name",
        "embed_dim"
    ],
    title: "CloudPostgresVectorStore"
};
const CloudQdrantVectorStoreSchema = {
    properties: {
        supports_nested_metadata_filters: {
            type: "boolean",
            enum: [
                true
            ],
            const: true,
            title: "Supports Nested Metadata Filters",
            default: true
        },
        collection_name: {
            type: "string",
            title: "Collection Name"
        },
        url: {
            type: "string",
            title: "Url"
        },
        api_key: {
            type: "string",
            format: "password",
            title: "Api Key",
            writeOnly: true
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            default: 3
        },
        client_kwargs: {
            type: "object",
            title: "Client Kwargs"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudQdrantVectorStore"
        }
    },
    type: "object",
    required: [
        "collection_name",
        "url",
        "api_key"
    ],
    title: "CloudQdrantVectorStore",
    description: `Cloud Qdrant Vector Store.

This class is used to store the configuration for a Qdrant vector store, so that it can be
created and used in LlamaCloud.

Args:
    collection_name (str): name of the Qdrant collection
    url (str): url of the Qdrant instance
    api_key (str): API key for authenticating with Qdrant
    max_retries (int): maximum number of retries in case of a failure. Defaults to 3
    client_kwargs (dict): additional kwargs to pass to the Qdrant client`
};
const CloudS3DataSourceSchema = {
    properties: {
        bucket: {
            type: "string",
            title: "Bucket",
            description: "The name of the S3 bucket to read from."
        },
        prefix: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Prefix",
            description: "The prefix of the S3 objects to read from."
        },
        aws_access_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Aws Access Id",
            description: "The AWS access ID to use for authentication."
        },
        aws_access_secret: {
            anyOf: [
                {
                    type: "string",
                    format: "password",
                    writeOnly: true
                },
                {
                    type: "null"
                }
            ],
            title: "Aws Access Secret",
            description: "The AWS access secret to use for authentication."
        },
        s3_endpoint_url: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "S3 Endpoint Url",
            description: "The S3 endpoint URL to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudS3DataSource"
        }
    },
    type: "object",
    required: [
        "bucket"
    ],
    title: "CloudS3DataSource"
};
const CloudSharepointDataSourceSchema = {
    properties: {
        site_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Site Name",
            description: "The name of the SharePoint site to download from."
        },
        site_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Site Id",
            description: "The ID of the SharePoint site to download from."
        },
        folder_path: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Folder Path",
            description: "The path of the Sharepoint folder to read from."
        },
        folder_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Folder Id",
            description: "The ID of the Sharepoint folder to read from."
        },
        drive_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Drive Name",
            description: "The name of the Sharepoint drive to read from."
        },
        client_id: {
            type: "string",
            title: "Client Id",
            description: "The client ID to use for authentication."
        },
        client_secret: {
            type: "string",
            format: "password",
            title: "Client Secret",
            description: "The client secret to use for authentication.",
            writeOnly: true
        },
        tenant_id: {
            type: "string",
            title: "Tenant Id",
            description: "The tenant ID to use for authentication."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudSharepointDataSource"
        }
    },
    type: "object",
    required: [
        "client_id",
        "client_secret",
        "tenant_id"
    ],
    title: "CloudSharepointDataSource"
};
const CloudSlackDataSourceSchema = {
    properties: {
        slack_token: {
            type: "string",
            format: "password",
            title: "Slack Token",
            description: "Slack Bot Token.",
            writeOnly: true
        },
        channel_ids: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Channel Ids",
            description: "Slack Channel."
        },
        latest_date: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Latest Date",
            description: "Latest date."
        },
        earliest_date: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Earliest Date",
            description: "Earliest date."
        },
        earliest_date_timestamp: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Earliest Date Timestamp",
            description: "Earliest date timestamp."
        },
        latest_date_timestamp: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Latest Date Timestamp",
            description: "Latest date timestamp."
        },
        channel_patterns: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Channel Patterns",
            description: "Slack Channel name pattern."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CloudSlackDataSource"
        }
    },
    type: "object",
    required: [
        "slack_token"
    ],
    title: "CloudSlackDataSource"
};
const CodeSplitterSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        language: {
            type: "string",
            title: "Language",
            description: "The programming language of the code being split."
        },
        chunk_lines: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Lines",
            description: "The number of lines to include in each chunk.",
            default: 40
        },
        chunk_lines_overlap: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Lines Overlap",
            description: "How many lines of code each chunk overlaps with.",
            default: 15
        },
        max_chars: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Max Chars",
            description: "Maximum number of characters per chunk.",
            default: 1500
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CodeSplitter"
        }
    },
    type: "object",
    required: [
        "language"
    ],
    title: "CodeSplitter",
    description: `Split code using a AST parser.

Thank you to Kevin Lu / SweepAI for suggesting this elegant code splitting solution.
https://docs.sweep.dev/blogs/chunking-2m-files`
};
const CohereEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The modelId of the Cohere model to use.",
            default: "embed-english-v3.0"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        api_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Key",
            description: "The Cohere API key."
        },
        truncate: {
            type: "string",
            title: "Truncate",
            description: "Truncation type - START/ END/ NONE",
            default: "END"
        },
        input_type: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Input Type",
            description: "Model Input type. If not provided, search_document and search_query are used when needed."
        },
        embedding_type: {
            type: "string",
            title: "Embedding Type",
            description: "Embedding type. If not provided float embedding_type is used when needed.",
            default: "float"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "CohereEmbedding"
        }
    },
    type: "object",
    required: [
        "api_key"
    ],
    title: "CohereEmbedding"
};
const CohereEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "COHERE_EMBEDDING"
            ],
            const: "COHERE_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "COHERE_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/CohereEmbedding",
            description: "Configuration for the Cohere embedding model."
        }
    },
    type: "object",
    title: "CohereEmbeddingConfig"
};
const ConfigurableDataSinkNamesSchema = {
    type: "string",
    enum: [
        "PINECONE",
        "POSTGRES",
        "QDRANT",
        "AZUREAI_SEARCH",
        "MONGODB_ATLAS",
        "MILVUS"
    ],
    title: "ConfigurableDataSinkNames"
};
const ConfigurableDataSourceNamesSchema = {
    type: "string",
    enum: [
        "S3",
        "AZURE_STORAGE_BLOB",
        "GOOGLE_DRIVE",
        "MICROSOFT_ONEDRIVE",
        "MICROSOFT_SHAREPOINT",
        "SLACK",
        "NOTION_PAGE",
        "CONFLUENCE",
        "JIRA",
        "BOX"
    ],
    title: "ConfigurableDataSourceNames"
};
const ConfigurableTransformationDefinitionSchema = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        configurable_transformation_type: {
            $ref: "#/components/schemas/ConfigurableTransformationNames",
            description: "The name field will act as the unique identifier of TransformationDefinition objects"
        },
        transformation_category: {
            $ref: "#/components/schemas/TransformationCategoryNames",
            description: "The transformation_category field will be used to group transformations in the UI"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "configurable_transformation_type",
        "transformation_category"
    ],
    title: "ConfigurableTransformationDefinition",
    description: "Schema for a transformation definition."
};
const ConfigurableTransformationNamesSchema = {
    type: "string",
    enum: [
        "CHARACTER_SPLITTER",
        "PAGE_SPLITTER_NODE_PARSER",
        "CODE_NODE_PARSER",
        "SENTENCE_AWARE_NODE_PARSER",
        "TOKEN_AWARE_NODE_PARSER",
        "MARKDOWN_NODE_PARSER",
        "MARKDOWN_ELEMENT_NODE_PARSER"
    ],
    title: "ConfigurableTransformationNames"
};
const ConfiguredTransformationItemSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id"
        },
        configurable_transformation_type: {
            $ref: "#/components/schemas/ConfigurableTransformationNames",
            description: "Name for the type of transformation this is (e.g. SIMPLE_NODE_PARSER). Can also be an enum instance of llama_index.ingestion.transformations.ConfigurableTransformations. This will be converted to ConfigurableTransformationNames."
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CharacterSplitter"
                },
                {
                    $ref: "#/components/schemas/PageSplitterNodeParser"
                },
                {
                    $ref: "#/components/schemas/CodeSplitter"
                },
                {
                    $ref: "#/components/schemas/SentenceSplitter"
                },
                {
                    $ref: "#/components/schemas/TokenTextSplitter"
                },
                {
                    $ref: "#/components/schemas/MarkdownNodeParser"
                },
                {
                    $ref: "#/components/schemas/MarkdownElementNodeParser"
                }
            ],
            title: "Component",
            description: "Component that implements the transformation"
        }
    },
    type: "object",
    required: [
        "configurable_transformation_type",
        "component"
    ],
    title: "ConfiguredTransformationItem",
    description: `Configured transformations for pipelines.

Similar to ConfigurableTransformation but includes a few
more fields that are useful to the platform.`
};
const CustomerPortalSessionCreatePayloadSchema = {
    properties: {
        return_url: {
            type: "string",
            minLength: 1,
            format: "uri",
            title: "Return Url"
        }
    },
    type: "object",
    required: [
        "return_url"
    ],
    title: "CustomerPortalSessionCreatePayload"
};
const DataSinkSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudPineconeVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudPostgresVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudQdrantVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch"
                },
                {
                    $ref: "#/components/schemas/CloudMilvusVectorStore"
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "sink_type",
        "component",
        "project_id"
    ],
    title: "DataSink",
    description: "Schema for a data sink."
};
const DataSinkCreateSchema = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudPineconeVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudPostgresVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudQdrantVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch"
                },
                {
                    $ref: "#/components/schemas/CloudMilvusVectorStore"
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "name",
        "sink_type",
        "component"
    ],
    title: "DataSinkCreate",
    description: "Schema for creating a data sink."
};
const DataSinkDefinitionSchema = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames",
            description: "The name field will act as the unique identifier of DataSinkDefinition objects"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "sink_type"
    ],
    title: "DataSinkDefinition",
    description: "Schema for a data sink definition."
};
const DataSinkUpdateSchema = {
    properties: {
        name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Name",
            description: "The name of the data sink."
        },
        sink_type: {
            $ref: "#/components/schemas/ConfigurableDataSinkNames"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudPineconeVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudPostgresVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudQdrantVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudAzureAISearchVectorStore"
                },
                {
                    $ref: "#/components/schemas/CloudMongoDBAtlasVectorSearch"
                },
                {
                    $ref: "#/components/schemas/CloudMilvusVectorStore"
                },
                {
                    type: "null"
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "sink_type"
    ],
    title: "DataSinkUpdate",
    description: "Schema for updating a data sink."
};
const DataSourceSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudS3DataSource"
                },
                {
                    $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudGoogleDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudOneDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSharepointDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSlackDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudNotionPageDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudConfluenceDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudJiraDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudBoxDataSource"
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "source_type",
        "component",
        "project_id"
    ],
    title: "DataSource",
    description: "Schema for a data source."
};
const DataSourceCreateSchema = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudS3DataSource"
                },
                {
                    $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudGoogleDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudOneDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSharepointDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSlackDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudNotionPageDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudConfluenceDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudJiraDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudBoxDataSource"
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "name",
        "source_type",
        "component"
    ],
    title: "DataSourceCreate",
    description: "Schema for creating a data source."
};
const DataSourceDefinitionSchema = {
    properties: {
        label: {
            type: "string",
            title: "Label",
            description: "The label field will be used to display the name of the component in the UI"
        },
        json_schema: {
            type: "object",
            title: "Json Schema",
            description: "The json_schema field can be used by clients to determine how to construct the component"
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames",
            description: "The name field will act as the unique identifier of DataSourceDefinition objects"
        }
    },
    type: "object",
    required: [
        "label",
        "json_schema",
        "source_type"
    ],
    title: "DataSourceDefinition",
    description: "Schema for a data source definition."
};
const DataSourceUpdateSchema = {
    properties: {
        name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudS3DataSource"
                },
                {
                    $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudGoogleDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudOneDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSharepointDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSlackDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudNotionPageDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudConfluenceDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudJiraDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudBoxDataSource"
                },
                {
                    type: "null"
                }
            ],
            title: "Component"
        }
    },
    type: "object",
    required: [
        "source_type"
    ],
    title: "DataSourceUpdate",
    description: "Schema for updating a data source."
};
const DefaultOrganizationUpdateSchema = {
    properties: {
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        }
    },
    type: "object",
    required: [
        "organization_id"
    ],
    title: "DefaultOrganizationUpdate",
    description: "Schema for updating the default organization for a user."
};
const ElementSegmentationConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "element"
            ],
            const: "element",
            title: "Mode",
            default: "element"
        }
    },
    type: "object",
    title: "ElementSegmentationConfig"
};
const EvalDatasetSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "EvalDataset",
    description: `Schema for an eval dataset.
Includes the other DB fields like id, created_at, & updated_at.`
};
const EvalDatasetCreateSchema = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "EvalDatasetCreate",
    description: "Schema for creating an eval dataset."
};
const EvalDatasetJobParamsSchema = {
    properties: {
        eval_question_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            title: "Eval Question Ids",
            description: "The IDs for the EvalQuestions this execution ran against."
        },
        eval_execution_params: {
            $ref: "#/components/schemas/EvalExecutionParams",
            description: "The parameters for the eval execution."
        }
    },
    type: "object",
    required: [
        "eval_question_ids",
        "eval_execution_params"
    ],
    title: "EvalDatasetJobParams",
    description: "Schema for the parameters of an eval dataset job."
};
const EvalDatasetJobRecordSchema = {
    properties: {
        job_name: {
            type: "string",
            enum: [
                "eval_dataset_job"
            ],
            const: "eval_dataset_job",
            title: "Job Name"
        },
        partitions: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "string",
                        format: "uuid"
                    },
                    {
                        type: "string"
                    }
                ]
            },
            type: "object",
            title: "Partitions",
            description: "The partitions for this execution. Used for determining where to save job output."
        },
        parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/EvalDatasetJobParams"
                },
                {
                    type: "null"
                }
            ],
            description: "Additional input parameters for the eval execution."
        },
        session_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Session Id",
            description: "The upstream request ID that created this job. Used for tracking the job across services."
        },
        correlation_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Correlation Id",
            description: "The correlation ID for this job. Used for tracking the job across services."
        },
        parent_job_execution_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Parent Job Execution Id",
            description: "The ID of the parent job execution."
        },
        user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Id",
            description: "The ID of the user that created this job"
        },
        created_at: {
            type: "string",
            format: "date-time",
            title: "Created At",
            description: "Creation datetime"
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        status: {
            $ref: "#/components/schemas/StatusEnum"
        },
        error_code: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Error Code"
        },
        error_message: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Error Message"
        },
        attempts: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Attempts",
            description: "The number of times this job has been attempted",
            default: 0
        },
        started_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Started At"
        },
        ended_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Ended At"
        },
        updated_at: {
            type: "string",
            format: "date-time",
            title: "Updated At",
            description: "Update datetime"
        },
        data: {
            anyOf: [
                {
                    $ref: "#/components/schemas/Base"
                },
                {
                    type: "null"
                }
            ],
            description: "Additional metadata for the job execution."
        }
    },
    type: "object",
    required: [
        "job_name",
        "partitions",
        "status"
    ],
    title: "EvalDatasetJobRecord",
    description: "Schema for job that evaluates an EvalDataset against a pipeline."
};
const EvalDatasetUpdateSchema = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the EvalDataset."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "EvalDatasetUpdate",
    description: `Schema for updating an eval dataset.
Only the name can be updated.`
};
const EvalExecutionCreateSchema = {
    properties: {
        eval_question_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            title: "Eval Question Ids"
        },
        params: {
            $ref: "#/components/schemas/EvalExecutionParamsOverride",
            description: "The parameters for the eval execution that will override the ones set in the pipeline."
        }
    },
    type: "object",
    required: [
        "eval_question_ids"
    ],
    title: "EvalExecutionCreate",
    description: "Schema for creating an eval execution for a given set of questions on a pipeline."
};
const EvalExecutionParamsSchema = {
    properties: {
        llm_model: {
            $ref: "#/components/schemas/SupportedLLMModelNames",
            description: "The LLM model to use within eval execution.",
            default: "GPT_4O"
        },
        qa_prompt_tmpl: {
            type: "string",
            title: "Qa Prompt Tmpl",
            description: "The template to use for the question answering prompt.",
            default: `Context information is below.
---------------------
{context_str}
---------------------
Given the context information and not prior knowledge, answer the query.
Query: {query_str}
Answer: `
        }
    },
    type: "object",
    title: "EvalExecutionParams",
    description: "Schema for the params for an eval execution."
};
const EvalExecutionParamsOverrideSchema = {
    properties: {
        llm_model: {
            anyOf: [
                {
                    $ref: "#/components/schemas/SupportedLLMModelNames"
                },
                {
                    type: "null"
                }
            ],
            description: "The LLM model to use within eval execution."
        },
        qa_prompt_tmpl: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Qa Prompt Tmpl",
            description: "The template to use for the question answering prompt."
        }
    },
    type: "object",
    title: "EvalExecutionParamsOverride",
    description: "Schema for the params override for an eval execution."
};
const EvalMetricSchema = {
    type: "string",
    enum: [
        "RELEVANCY",
        "FAITHFULNESS"
    ],
    title: "EvalMetric"
};
const EvalQuestionSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        content: {
            type: "string",
            maxLength: 1000,
            minLength: 1,
            title: "Content",
            description: "The content of the question."
        },
        eval_dataset_id: {
            type: "string",
            format: "uuid",
            title: "Eval Dataset Id"
        },
        eval_dataset_index: {
            type: "integer",
            title: "Eval Dataset Index",
            description: "The index at which this question is positioned relative to the other questions in the linked EvalDataset. Client is responsible for setting this correctly.",
            min: 0
        }
    },
    type: "object",
    required: [
        "id",
        "content",
        "eval_dataset_id",
        "eval_dataset_index"
    ],
    title: "EvalQuestion"
};
const EvalQuestionCreateSchema = {
    properties: {
        content: {
            type: "string",
            maxLength: 1000,
            minLength: 1,
            title: "Content",
            description: "The content of the question."
        }
    },
    type: "object",
    required: [
        "content"
    ],
    title: "EvalQuestionCreate"
};
const EvalQuestionResultSchema = {
    properties: {
        eval_question_id: {
            type: "string",
            format: "uuid",
            title: "Eval Question Id",
            description: "The ID of the question that was executed."
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the question was executed against."
        },
        source_nodes: {
            items: {
                $ref: "#/components/schemas/TextNode"
            },
            type: "array",
            title: "Source Nodes",
            description: "The nodes retrieved by the pipeline for the given question."
        },
        answer: {
            type: "string",
            title: "Answer",
            description: "The answer to the question."
        },
        eval_metrics: {
            additionalProperties: {
                $ref: "#/components/schemas/MetricResult"
            },
            type: "object",
            title: "Eval Metrics",
            description: "The eval metrics for the question."
        },
        eval_dataset_execution_id: {
            type: "string",
            format: "uuid",
            title: "Eval Dataset Execution Id",
            description: "The ID of the EvalDatasetJobRecord that this result was generated from."
        },
        eval_dataset_execution_params: {
            $ref: "#/components/schemas/EvalExecutionParams",
            description: "The EvalExecutionParams that were used when this result was generated."
        },
        eval_finished_at: {
            type: "string",
            format: "date-time",
            title: "Eval Finished At",
            description: "The timestamp when the eval finished."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "EvalQuestionResult"
        }
    },
    type: "object",
    required: [
        "eval_question_id",
        "pipeline_id",
        "source_nodes",
        "answer",
        "eval_metrics",
        "eval_dataset_execution_id",
        "eval_dataset_execution_params",
        "eval_finished_at"
    ],
    title: "EvalQuestionResult",
    description: "Schema for the result of an eval question job."
};
const ExtractionJobSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "The id of the extraction job"
        },
        status: {
            $ref: "#/components/schemas/StatusEnum",
            description: "The status of the extraction job"
        },
        file: {
            $ref: "#/components/schemas/File",
            description: "The file that the extract was extracted from"
        }
    },
    type: "object",
    required: [
        "id",
        "status",
        "file"
    ],
    title: "ExtractionJob"
};
const ExtractionJobCreateSchema = {
    properties: {
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The id of the file"
        }
    },
    type: "object",
    required: [
        "schema_id",
        "file_id"
    ],
    title: "ExtractionJobCreate",
    description: "Schema for creating an extraction job."
};
const ExtractionJobCreateBatchSchema = {
    properties: {
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        file_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            minItems: 1,
            title: "File Ids",
            description: "The ids of the files"
        }
    },
    type: "object",
    required: [
        "schema_id",
        "file_ids"
    ],
    title: "ExtractionJobCreateBatch",
    description: "Schema for creating extraction jobs in batch."
};
const ExtractionResultSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        schema_id: {
            type: "string",
            format: "uuid",
            title: "Schema Id",
            description: "The id of the schema"
        },
        data: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    },
                    {
                        type: "null"
                    }
                ]
            },
            type: "object",
            title: "Data",
            description: "The data extracted from the file"
        },
        file: {
            $ref: "#/components/schemas/File",
            description: "The file that the extract was extracted from"
        }
    },
    type: "object",
    required: [
        "id",
        "schema_id",
        "data",
        "file"
    ],
    title: "ExtractionResult",
    description: "Schema for an extraction result."
};
const ExtractionSchemaSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        data_schema: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "ExtractionSchema",
    description: "Schema for extraction schema."
};
const ExtractionSchemaCreateSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        data_schema: {
            additionalProperties: {
                anyOf: [
                    {
                        type: "object"
                    },
                    {
                        items: {},
                        type: "array"
                    },
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    },
                    {
                        type: "number"
                    },
                    {
                        type: "boolean"
                    },
                    {
                        type: "null"
                    }
                ]
            },
            type: "object",
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    required: [
        "name",
        "data_schema"
    ],
    title: "ExtractionSchemaCreate",
    description: "Schema for creating an extraction schema."
};
const ExtractionSchemaInferSchema = {
    properties: {
        schema_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Schema Id",
            description: "The ID of a schema to update with the new schema"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "The name of the extraction schema"
        },
        project_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Project Id",
            description: "The ID of the project that the extraction schema belongs to"
        },
        file_ids: {
            items: {
                type: "string",
                format: "uuid"
            },
            type: "array",
            minItems: 1,
            title: "File Ids",
            description: "The IDs of the files that the extraction schema contains"
        },
        stream: {
            type: "boolean",
            title: "Stream",
            description: "Whether to stream the results of the extraction schema",
            default: false
        }
    },
    type: "object",
    required: [
        "name",
        "file_ids"
    ],
    title: "ExtractionSchemaInfer",
    description: "Schema for inferring an extraction schema."
};
const ExtractionSchemaUpdateSchema = {
    properties: {
        data_schema: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Schema",
            description: "The schema of the data"
        }
    },
    type: "object",
    title: "ExtractionSchemaUpdate",
    description: "Schema for updating an extraction schema."
};
const FileSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        file_size: {
            anyOf: [
                {
                    type: "integer",
                    minimum: 0
                },
                {
                    type: "null"
                }
            ],
            title: "File Size",
            description: "Size of the file in bytes"
        },
        file_type: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 1
                },
                {
                    type: "null"
                }
            ],
            title: "File Type",
            description: "File type (e.g. pdf, docx, etc.)"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the file belongs to"
        },
        last_modified_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id"
    ],
    title: "File",
    description: "Schema for a file."
};
const FileCreateSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        file_size: {
            anyOf: [
                {
                    type: "integer",
                    minimum: 0
                },
                {
                    type: "null"
                }
            ],
            title: "File Size",
            description: "Size of the file in bytes"
        },
        last_modified_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "FileCreate"
};
const FilterConditionSchema = {
    type: "string",
    enum: [
        "and",
        "or"
    ],
    title: "FilterCondition",
    description: "Vector store filter conditions to combine different filters."
};
const FilterOperatorSchema = {
    type: "string",
    enum: [
        "==",
        ">",
        "<",
        "!=",
        ">=",
        "<=",
        "in",
        "nin",
        "any",
        "all",
        "text_match",
        "contains",
        "is_empty"
    ],
    title: "FilterOperator",
    description: "Vector store filter operator."
};
const GeminiEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The modelId of the Gemini model to use.",
            default: "models/embedding-001"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        title: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Title",
            description: "Title is only applicable for retrieval_document tasks, and is used to represent a document title. For other tasks, title is invalid.",
            default: ""
        },
        task_type: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Task Type",
            description: "The task for embedding model.",
            default: "retrieval_document"
        },
        api_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Key",
            description: "API key to access the model. Defaults to None."
        },
        api_base: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Base",
            description: "API base to access the model. Defaults to None."
        },
        transport: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Transport",
            description: "Transport to access the model. Defaults to None."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "GeminiEmbedding"
        }
    },
    type: "object",
    title: "GeminiEmbedding"
};
const GeminiEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "GEMINI_EMBEDDING"
            ],
            const: "GEMINI_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "GEMINI_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/GeminiEmbedding",
            description: "Configuration for the Gemini embedding model."
        }
    },
    type: "object",
    title: "GeminiEmbeddingConfig"
};
const HTTPValidationErrorSchema = {
    properties: {
        detail: {
            items: {
                $ref: "#/components/schemas/ValidationError"
            },
            type: "array",
            title: "Detail"
        }
    },
    type: "object",
    title: "HTTPValidationError"
};
const HuggingFaceInferenceAPIEmbeddingSchema = {
    properties: {
        model_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Model Name",
            description: "Hugging Face model name. If None, the task will be used."
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        pooling: {
            anyOf: [
                {
                    $ref: "#/components/schemas/Pooling"
                },
                {
                    type: "null"
                }
            ],
            description: "Pooling strategy. If None, the model's default pooling is used.",
            default: "cls"
        },
        query_instruction: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Query Instruction",
            description: "Instruction to prepend during query embedding."
        },
        text_instruction: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Text Instruction",
            description: "Instruction to prepend during text embedding."
        },
        token: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Token",
            description: "Hugging Face token. Will default to the locally saved token. Pass token=False if you don’t want to send your token to the server."
        },
        timeout: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Timeout",
            description: "The maximum number of seconds to wait for a response from the server. Loading a new model in Inference API can take up to several minutes. Defaults to None, meaning it will loop until the server is available."
        },
        headers: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Headers",
            description: "Additional headers to send to the server. By default only the authorization and user-agent headers are sent. Values in this dictionary will override the default values."
        },
        cookies: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Cookies",
            description: "Additional cookies to send to the server."
        },
        task: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Task",
            description: "Optional task to pick Hugging Face's recommended model, used when model_name is left as default of None."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "HuggingFaceInferenceAPIEmbedding"
        }
    },
    type: "object",
    title: "HuggingFaceInferenceAPIEmbedding"
};
const HuggingFaceInferenceAPIEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "HUGGINGFACE_API_EMBEDDING"
            ],
            const: "HUGGINGFACE_API_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "HUGGINGFACE_API_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbedding",
            description: "Configuration for the HuggingFace Inference API embedding model."
        }
    },
    type: "object",
    title: "HuggingFaceInferenceAPIEmbeddingConfig"
};
const IngestionErrorResponseSchema = {
    properties: {
        job_id: {
            type: "string",
            format: "uuid",
            title: "Job Id",
            description: "ID of the job that failed."
        },
        message: {
            type: "string",
            title: "Message",
            description: "List of errors that occurred during ingestion."
        },
        step: {
            $ref: "#/components/schemas/JobNameMapping",
            description: "Name of the job that failed."
        }
    },
    type: "object",
    required: [
        "job_id",
        "message",
        "step"
    ],
    title: "IngestionErrorResponse"
};
const InputMessageSchema = {
    properties: {
        id: {
            type: "string",
            title: "Id",
            description: "ID of the message, if any. a UUID."
        },
        role: {
            $ref: "#/components/schemas/MessageRole"
        },
        content: {
            type: "string",
            title: "Content"
        },
        data: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Data",
            description: "Additional data to be stored with the message."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "id",
        "role",
        "content"
    ],
    title: "InputMessage",
    description: "This is distinct from a ChatMessage because this schema is enforced by the AI Chat library used in the frontend"
};
const JobNameMappingSchema = {
    type: "string",
    enum: [
        "MANAGED_INGESTION",
        "DATA_SOURCE",
        "FILES_UPDATE",
        "FILE_UPDATER",
        "PARSE",
        "TRANSFORM",
        "INGESTION"
    ],
    title: "JobNameMapping",
    description: "Enum for mapping original job names to readable names."
};
const LLMSchema = {
    properties: {
        callback_manager: {
            title: "Callback Manager"
        },
        system_prompt: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "System Prompt",
            description: "System prompt for LLM calls."
        },
        messages_to_prompt: {
            type: "string",
            title: "Messages To Prompt",
            description: "Function to convert a list of messages to an LLM prompt."
        },
        completion_to_prompt: {
            type: "string",
            title: "Completion To Prompt",
            description: "Function to convert a completion to an LLM prompt."
        },
        output_parser: {
            anyOf: [
                {},
                {
                    type: "null"
                }
            ],
            title: "Output Parser",
            description: "Output parser to parse, validate, and correct errors programmatically."
        },
        pydantic_program_mode: {
            $ref: "#/components/schemas/PydanticProgramMode",
            default: "default"
        },
        query_wrapper_prompt: {
            anyOf: [
                {
                    $ref: "#/components/schemas/BasePromptTemplate"
                },
                {
                    type: "null"
                }
            ],
            description: "Query wrapper prompt for LLM calls."
        }
    },
    type: "object",
    title: "LLM",
    description: `The LLM class is the main class for interacting with language models.

Attributes:
    system_prompt (Optional[str]):
        System prompt for LLM calls.
    messages_to_prompt (Callable):
        Function to convert a list of messages to an LLM prompt.
    completion_to_prompt (Callable):
        Function to convert a completion to an LLM prompt.
    output_parser (Optional[BaseOutputParser]):
        Output parser to parse, validate, and correct errors programmatically.
    pydantic_program_mode (PydanticProgramMode):
        Pydantic program mode to use for structured prediction.`
};
const LLMModelDataSchema = {
    properties: {
        name: {
            type: "string",
            title: "Name",
            description: "The name of the LLM model."
        },
        description: {
            type: "string",
            title: "Description",
            description: "The description of the LLM model."
        },
        multi_modal: {
            type: "boolean",
            title: "Multi Modal",
            description: "Whether the model supports multi-modal image input"
        }
    },
    type: "object",
    required: [
        "name",
        "description",
        "multi_modal"
    ],
    title: "LLMModelData",
    description: "Schema for an eval LLM model."
};
const LLMParametersSchema = {
    properties: {
        model_name: {
            $ref: "#/components/schemas/SupportedLLMModelNames",
            description: "The name of the model to use for LLM completions.",
            default: "GPT_3_5_TURBO"
        },
        system_prompt: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "System Prompt",
            description: "The system prompt to use for the completion."
        },
        temperature: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Temperature",
            description: "The temperature value for the model.",
            default: 0.1
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "LLMParameters"
};
const LlamaParseParametersSchema = {
    properties: {
        languages: {
            items: {
                $ref: "#/components/schemas/ParserLanguages"
            },
            type: "array",
            minItems: 1,
            title: "Languages"
        },
        parsing_instruction: {
            type: "string",
            title: "Parsing Instruction",
            default: ""
        },
        disable_ocr: {
            type: "boolean",
            title: "Disable Ocr",
            default: false
        },
        annotate_links: {
            type: "boolean",
            title: "Annotate Links",
            default: false
        },
        disable_reconstruction: {
            type: "boolean",
            title: "Disable Reconstruction",
            default: false
        },
        invalidate_cache: {
            type: "boolean",
            title: "Invalidate Cache",
            default: false
        },
        do_not_cache: {
            type: "boolean",
            title: "Do Not Cache",
            default: false
        },
        fast_mode: {
            type: "boolean",
            title: "Fast Mode",
            default: false
        },
        skip_diagonal_text: {
            type: "boolean",
            title: "Skip Diagonal Text",
            default: false
        },
        gpt4o_mode: {
            type: "boolean",
            title: "Gpt4O Mode",
            default: false
        },
        gpt4o_api_key: {
            type: "string",
            title: "Gpt4O Api Key",
            default: ""
        },
        do_not_unroll_columns: {
            type: "boolean",
            title: "Do Not Unroll Columns",
            default: false
        },
        page_separator: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Separator"
        },
        bounding_box: {
            type: "string",
            title: "Bounding Box",
            default: ""
        },
        target_pages: {
            type: "string",
            title: "Target Pages",
            default: ""
        },
        use_vendor_multimodal_model: {
            type: "boolean",
            title: "Use Vendor Multimodal Model",
            default: false
        },
        vendor_multimodal_model_name: {
            type: "string",
            title: "Vendor Multimodal Model Name",
            default: ""
        },
        vendor_multimodal_api_key: {
            type: "string",
            title: "Vendor Multimodal Api Key",
            default: ""
        },
        page_prefix: {
            type: "string",
            title: "Page Prefix",
            default: ""
        },
        page_suffix: {
            type: "string",
            title: "Page Suffix",
            default: ""
        },
        webhook_url: {
            type: "string",
            title: "Webhook Url",
            default: ""
        },
        take_screenshot: {
            type: "boolean",
            title: "Take Screenshot",
            default: false
        },
        is_formatting_instruction: {
            type: "boolean",
            title: "Is Formatting Instruction",
            default: true
        },
        premium_mode: {
            type: "boolean",
            title: "Premium Mode",
            default: false
        },
        continuous_mode: {
            type: "boolean",
            title: "Continuous Mode",
            default: false
        },
        s3_input_path: {
            type: "string",
            title: "S3 Input Path",
            default: ""
        },
        s3_output_path_prefix: {
            type: "string",
            title: "S3 Output Path Prefix",
            default: ""
        },
        azure_openai_deployment_name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Openai Deployment Name"
        },
        azure_openai_endpoint: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Openai Endpoint"
        },
        azure_openai_api_version: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Openai Api Version"
        },
        azure_openai_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Azure Openai Key"
        }
    },
    type: "object",
    title: "LlamaParseParameters",
    description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
};
const LlamaParseSupportedFileExtensionsSchema = {
    type: "string",
    enum: [
        ".pdf",
        ".doc",
        ".docx",
        ".docm",
        ".dot",
        ".dotx",
        ".dotm",
        ".rtf",
        ".wps",
        ".wpd",
        ".sxw",
        ".stw",
        ".sxg",
        ".pages",
        ".mw",
        ".mcw",
        ".uot",
        ".uof",
        ".uos",
        ".uop",
        ".ppt",
        ".pptx",
        ".pot",
        ".pptm",
        ".potx",
        ".potm",
        ".key",
        ".odp",
        ".odg",
        ".otp",
        ".fopd",
        ".sxi",
        ".sti",
        ".epub",
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".bmp",
        ".svg",
        ".tiff",
        ".webp",
        ".html",
        ".htm",
        ".xls",
        ".xlsx",
        ".xlsm",
        ".xlsb",
        ".xlw",
        ".csv",
        ".dif",
        ".sylk",
        ".slk",
        ".prn",
        ".numbers",
        ".et",
        ".ods",
        ".fods",
        ".uos1",
        ".uos2",
        ".dbf",
        ".wk1",
        ".wk2",
        ".wk3",
        ".wk4",
        ".wks",
        ".wq1",
        ".wq2",
        ".wb1",
        ".wb2",
        ".wb3",
        ".qpw",
        ".xlr",
        ".eth",
        ".tsv"
    ],
    title: "LlamaParseSupportedFileExtensions"
};
const LocalEvalSchema = {
    properties: {
        query: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Query",
            description: "Query string"
        },
        contexts: {
            anyOf: [
                {
                    items: {
                        type: "string"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Contexts",
            description: "Context strings"
        },
        response: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Response",
            description: "Response string"
        },
        passing: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Passing",
            description: "Binary evaluation result (passing or not)"
        },
        feedback: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Feedback",
            description: "Feedback or reasoning for the response"
        },
        score: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Score",
            description: "Score for the response"
        },
        pairwise_source: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Pairwise Source",
            description: "Used only for pairwise and specifies whether it is from original order of presented answers or flipped order"
        },
        invalid_result: {
            type: "boolean",
            title: "Invalid Result",
            description: "Whether the evaluation result is an invalid one.",
            default: false
        },
        invalid_reason: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Invalid Reason",
            description: "Reason for invalid evaluation."
        }
    },
    type: "object",
    title: "LocalEval",
    description: `Evaluation result, EvaluationResult from llama_index.

Output of an BaseEvaluator.`
};
const LocalEvalResultsSchema = {
    properties: {
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project."
        },
        eval_set_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Eval Set Id",
            description: "The ID of the local eval result set."
        },
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        eval_name: {
            type: "string",
            title: "Eval Name",
            description: "The name of the eval."
        },
        result: {
            $ref: "#/components/schemas/LocalEval",
            description: "The eval results."
        }
    },
    type: "object",
    required: [
        "project_id",
        "app_name",
        "eval_name",
        "result"
    ],
    title: "LocalEvalResults",
    description: "Schema for the result of a local evaluation."
};
const LocalEvalSetCreateSchema = {
    properties: {
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        results: {
            additionalProperties: {
                items: {
                    $ref: "#/components/schemas/LocalEval"
                },
                type: "array"
            },
            type: "object",
            title: "Results",
            description: "The eval results."
        }
    },
    type: "object",
    required: [
        "app_name",
        "results"
    ],
    title: "LocalEvalSetCreate",
    description: "Schema for creating a local eval set."
};
const LocalEvalSetsSchema = {
    properties: {
        eval_set_id: {
            type: "string",
            format: "uuid",
            title: "Eval Set Id",
            description: "The ID of the eval set."
        },
        app_name: {
            type: "string",
            title: "App Name",
            description: "The name of the app."
        },
        upload_time: {
            type: "string",
            format: "date-time",
            title: "Upload Time",
            description: "The time of the upload."
        }
    },
    type: "object",
    required: [
        "eval_set_id",
        "app_name",
        "upload_time"
    ],
    title: "LocalEvalSets"
};
const ManagedIngestionStatusSchema = {
    type: "string",
    enum: [
        "NOT_STARTED",
        "IN_PROGRESS",
        "SUCCESS",
        "ERROR",
        "PARTIAL_SUCCESS"
    ],
    title: "ManagedIngestionStatus",
    description: "Status of managed ingestion with partial Updates."
};
const ManagedIngestionStatusResponseSchema = {
    properties: {
        job_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Job Id",
            description: "ID of the latest job."
        },
        deployment_date: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Deployment Date",
            description: "Date of the deployment."
        },
        status: {
            $ref: "#/components/schemas/ManagedIngestionStatus",
            description: "Status of the ingestion."
        },
        error: {
            anyOf: [
                {
                    items: {
                        $ref: "#/components/schemas/IngestionErrorResponse"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Error",
            description: "List of errors that occurred during ingestion."
        }
    },
    type: "object",
    required: [
        "status"
    ],
    title: "ManagedIngestionStatusResponse"
};
const MarkdownElementNodeParserSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        llm: {
            anyOf: [
                {
                    $ref: "#/components/schemas/LLM"
                },
                {
                    type: "null"
                }
            ],
            description: "LLM model to use for summarization."
        },
        summary_query_str: {
            type: "string",
            title: "Summary Query Str",
            description: "Query string to use for summarization.",
            default: "What is this table about? Give a very concise summary (imagine you are adding a new caption and summary for this table), and output the real/existing table title/caption if context provided.and output the real/existing table id if context provided.and also output whether or not the table should be kept."
        },
        num_workers: {
            type: "integer",
            title: "Num Workers",
            description: "Num of workers for async jobs.",
            default: 4
        },
        show_progress: {
            type: "boolean",
            title: "Show Progress",
            description: "Whether to show progress.",
            default: true
        },
        nested_node_parser: {
            anyOf: [
                {
                    $ref: "#/components/schemas/NodeParser"
                },
                {
                    type: "null"
                }
            ],
            description: "Other types of node parsers to handle some types of nodes."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "MarkdownElementNodeParser"
        }
    },
    type: "object",
    title: "MarkdownElementNodeParser",
    description: `Markdown element node parser.

Splits a markdown document into Text Nodes and Index Nodes corresponding to embedded objects
(e.g. tables).`
};
const MarkdownNodeParserSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "MarkdownNodeParser"
        }
    },
    type: "object",
    title: "MarkdownNodeParser",
    description: `Markdown node parser.

Splits a document into Nodes using custom Markdown splitting logic.

Args:
    include_metadata (bool): whether to include metadata in nodes
    include_prev_next_rel (bool): whether to include prev/next relationships`
};
const MessageAnnotationSchema = {
    properties: {
        type: {
            type: "string",
            title: "Type"
        },
        data: {
            type: "string",
            contentMediaType: "application/json",
            contentSchema: {},
            title: "Data"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "type",
        "data"
    ],
    title: "MessageAnnotation"
};
const MessageRoleSchema = {
    type: "string",
    enum: [
        "system",
        "user",
        "assistant",
        "function",
        "tool",
        "chatbot",
        "model"
    ],
    title: "MessageRole",
    description: "Message role."
};
const MetadataFilterSchema = {
    properties: {
        key: {
            type: "string",
            title: "Key"
        },
        value: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "number"
                },
                {
                    type: "string"
                },
                {
                    items: {
                        type: "string"
                    },
                    type: "array"
                },
                {
                    items: {
                        type: "number"
                    },
                    type: "array"
                },
                {
                    items: {
                        type: "integer"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Value"
        },
        operator: {
            $ref: "#/components/schemas/FilterOperator",
            default: "=="
        }
    },
    type: "object",
    required: [
        "key",
        "value"
    ],
    title: "MetadataFilter",
    description: `Comprehensive metadata filter for vector stores to support more operators.

Value uses Strict* types, as int, float and str are compatible types and were all
converted to string before.

See: https://docs.pydantic.dev/latest/usage/types/#strict-types`
};
const MetadataFiltersSchema = {
    properties: {
        filters: {
            items: {
                anyOf: [
                    {
                        $ref: "#/components/schemas/MetadataFilter"
                    },
                    {
                        $ref: "#/components/schemas/MetadataFilters"
                    }
                ]
            },
            type: "array",
            title: "Filters"
        },
        condition: {
            anyOf: [
                {
                    $ref: "#/components/schemas/FilterCondition"
                },
                {
                    type: "null"
                }
            ],
            default: "and"
        }
    },
    type: "object",
    required: [
        "filters"
    ],
    title: "MetadataFilters",
    description: "Metadata filters for vector stores."
};
const MetricResultSchema = {
    properties: {
        passing: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Passing",
            description: "Whether the metric passed or not."
        },
        score: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Score",
            description: "The score for the metric."
        },
        feedback: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Feedback",
            description: "The reasoning for the metric."
        }
    },
    type: "object",
    title: "MetricResult"
};
const NodeParserSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "NodeParser",
    description: "Base interface for node parser."
};
const NodeRelationshipSchema = {
    type: "string",
    enum: [
        "1",
        "2",
        "3",
        "4",
        "5"
    ],
    title: "NodeRelationship",
    description: `Node relationships used in \`BaseNode\` class.

Attributes:
    SOURCE: The node is the source document.
    PREVIOUS: The node is the previous node in the document.
    NEXT: The node is the next node in the document.
    PARENT: The node is the parent node in the document.
    CHILD: The node is a child node in the document.`
};
const NoneChunkingConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "none"
            ],
            const: "none",
            title: "Mode",
            default: "none"
        }
    },
    type: "object",
    title: "NoneChunkingConfig"
};
const NoneSegmentationConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "none"
            ],
            const: "none",
            title: "Mode",
            default: "none"
        }
    },
    type: "object",
    title: "NoneSegmentationConfig"
};
const ObjectTypeSchema = {
    type: "string",
    enum: [
        "1",
        "2",
        "3",
        "4"
    ],
    title: "ObjectType"
};
const OpenAIEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The name of the OpenAI embedding model.",
            default: "text-embedding-ada-002"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the OpenAI API."
        },
        api_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Key",
            description: "The OpenAI API key."
        },
        api_base: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Base",
            description: "The base URL for OpenAI API.",
            default: "https://api.openai.com/v1"
        },
        api_version: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Api Version",
            description: "The version for OpenAI API.",
            default: ""
        },
        max_retries: {
            type: "integer",
            title: "Max Retries",
            description: "Maximum number of retries.",
            default: 10,
            gte: 0
        },
        timeout: {
            type: "number",
            title: "Timeout",
            description: "Timeout for each request.",
            default: 60,
            gte: 0
        },
        default_headers: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Default Headers",
            description: "The default headers for API requests."
        },
        reuse_client: {
            type: "boolean",
            title: "Reuse Client",
            description: "Reuse the OpenAI client between requests. When doing anything with large volumes of async API calls, setting this to false can improve stability.",
            default: true
        },
        dimensions: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Dimensions",
            description: "The number of dimensions on the output embedding vectors. Works only with v3 embedding models."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "OpenAIEmbedding"
        }
    },
    type: "object",
    title: "OpenAIEmbedding"
};
const OpenAIEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "OPENAI_EMBEDDING"
            ],
            const: "OPENAI_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "OPENAI_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/OpenAIEmbedding",
            description: "Configuration for the OpenAI embedding model."
        }
    },
    type: "object",
    title: "OpenAIEmbeddingConfig"
};
const OrganizationSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    required: [
        "id",
        "name"
    ],
    title: "Organization",
    description: "Schema for an organization."
};
const OrganizationCreateSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "OrganizationCreate",
    description: "Schema for creating an organization."
};
const OrganizationUpdateSchema = {
    properties: {
        name: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Name",
            description: "A name for the organization."
        }
    },
    type: "object",
    title: "OrganizationUpdate",
    description: "Schema for updating an organization."
};
const PageScreenshotMetadataSchema = {
    properties: {
        page_index: {
            type: "integer",
            minimum: 0,
            title: "Page Index",
            description: "The index of the page for which the screenshot is taken (0-indexed)"
        },
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The ID of the file that the page screenshot was taken from"
        },
        image_size: {
            type: "integer",
            minimum: 0,
            title: "Image Size",
            description: "The size of the image in bytes"
        }
    },
    type: "object",
    required: [
        "page_index",
        "file_id",
        "image_size"
    ],
    title: "PageScreenshotMetadata"
};
const PageScreenshotNodeWithScoreSchema = {
    properties: {
        node: {
            $ref: "#/components/schemas/PageScreenshotMetadata"
        },
        score: {
            type: "number",
            title: "Score",
            description: "The score of the screenshot node"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "NodeWithScore"
        }
    },
    type: "object",
    required: [
        "node",
        "score"
    ],
    title: "PageScreenshotNodeWithScore",
    description: "Page screenshot metadata with score"
};
const PageSegmentationConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "page"
            ],
            const: "page",
            title: "Mode",
            default: "page"
        },
        page_separator: {
            type: "string",
            title: "Page Separator",
            default: `
---
`
        }
    },
    type: "object",
    title: "PageSegmentationConfig"
};
const PageSplitterNodeParserSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        page_separator: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Page Separator",
            description: "Separator to split text into pages.",
            default: `
---
`
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "PageSplitterNodeParser",
    description: "Split text into pages."
};
const ParserLanguagesSchema = {
    type: "string",
    enum: [
        "af",
        "az",
        "bs",
        "cs",
        "cy",
        "da",
        "de",
        "en",
        "es",
        "et",
        "fr",
        "ga",
        "hr",
        "hu",
        "id",
        "is",
        "it",
        "ku",
        "la",
        "lt",
        "lv",
        "mi",
        "ms",
        "mt",
        "nl",
        "no",
        "oc",
        "pi",
        "pl",
        "pt",
        "ro",
        "rs_latin",
        "sk",
        "sl",
        "sq",
        "sv",
        "sw",
        "tl",
        "tr",
        "uz",
        "vi",
        "ar",
        "fa",
        "ug",
        "ur",
        "bn",
        "as",
        "mni",
        "ru",
        "rs_cyrillic",
        "be",
        "bg",
        "uk",
        "mn",
        "abq",
        "ady",
        "kbd",
        "ava",
        "dar",
        "inh",
        "che",
        "lbe",
        "lez",
        "tab",
        "tjk",
        "hi",
        "mr",
        "ne",
        "bh",
        "mai",
        "ang",
        "bho",
        "mah",
        "sck",
        "new",
        "gom",
        "sa",
        "bgc",
        "th",
        "ch_sim",
        "ch_tra",
        "ja",
        "ko",
        "ta",
        "te",
        "kn"
    ],
    title: "ParserLanguages",
    description: "Enum for representing the languages supported by the parser"
};
const ParsingHistoryItemSchema = {
    properties: {
        user_id: {
            type: "string",
            title: "User Id"
        },
        day: {
            type: "string",
            title: "Day"
        },
        job_id: {
            type: "string",
            title: "Job Id"
        },
        file_name: {
            type: "string",
            title: "File Name"
        },
        original_file_name: {
            type: "string",
            title: "Original File Name"
        },
        expired: {
            type: "boolean",
            title: "Expired",
            default: false
        },
        pages: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Pages"
        },
        images: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Images"
        },
        time: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Time"
        }
    },
    type: "object",
    required: [
        "user_id",
        "day",
        "job_id",
        "file_name",
        "original_file_name"
    ],
    title: "ParsingHistoryItem"
};
const ParsingJobSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id"
        },
        status: {
            $ref: "#/components/schemas/StatusEnum"
        },
        error_code: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Error Code"
        },
        error_message: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Error Message"
        }
    },
    type: "object",
    required: [
        "id",
        "status"
    ],
    title: "ParsingJob"
};
const ParsingJobJsonResultSchema = {
    properties: {
        pages: {
            title: "Pages",
            description: "The json result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    required: [
        "pages",
        "job_metadata"
    ],
    title: "ParsingJobJsonResult"
};
const ParsingJobMarkdownResultSchema = {
    properties: {
        markdown: {
            type: "string",
            title: "Markdown",
            description: "The markdown result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    required: [
        "markdown",
        "job_metadata"
    ],
    title: "ParsingJobMarkdownResult"
};
const ParsingJobTextResultSchema = {
    properties: {
        text: {
            type: "string",
            title: "Text",
            description: "The text result of the parsing job"
        },
        job_metadata: {
            title: "Job Metadata",
            description: "Parsing job metadata , including usage"
        }
    },
    type: "object",
    required: [
        "text",
        "job_metadata"
    ],
    title: "ParsingJobTextResult"
};
const ParsingUsageSchema = {
    properties: {
        usage_pdf_pages: {
            type: "integer",
            title: "Usage Pdf Pages"
        },
        max_pdf_pages: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Max Pdf Pages"
        }
    },
    type: "object",
    required: [
        "usage_pdf_pages"
    ],
    title: "ParsingUsage"
};
const PartitionNamesSchema = {
    type: "string",
    enum: [
        "data_source_id_partition",
        "pipeline_id_partition",
        "eval_dataset_id_partition",
        "file_id_partition",
        "pipeline_file_id_partition",
        "file_parsing_id_partition",
        "extraction_schema_id_partition"
    ],
    title: "PartitionNames",
    description: "Enum for dataset partition names."
};
const PermissionSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the permission."
        },
        description: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Description",
            description: "A description for the permission."
        },
        access: {
            type: "boolean",
            title: "Access",
            description: "Whether the permission is granted or not."
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "description",
        "access"
    ],
    title: "Permission",
    description: "Schema for a permission."
};
const PipelineSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        },
        pipeline_type: {
            $ref: "#/components/schemas/PipelineType",
            description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
            default: "MANAGED"
        },
        managed_pipeline_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        },
        embedding_config: {
            oneOf: [
                {
                    $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/CohereEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/GeminiEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/OpenAIEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/VertexAIEmbeddingConfig"
                },
                {
                    $ref: "#/components/schemas/BedrockEmbeddingConfig"
                }
            ],
            title: "Embedding Config",
            discriminator: {
                propertyName: "type",
                mapping: {
                    AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
                    BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
                    COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
                    GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
                    HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
                    OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
                    VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig"
                }
            }
        },
        configured_transformations: {
            items: {
                $ref: "#/components/schemas/ConfiguredTransformationItem"
            },
            type: "array",
            title: "Configured Transformations",
            description: "Deprecated don't use it, List of configured transformations.",
            default: []
        },
        config_hash: {
            anyOf: [
                {
                    $ref: "#/components/schemas/PipelineConfigurationHashes"
                },
                {
                    type: "null"
                }
            ],
            description: "Hashes for the configuration of the pipeline."
        },
        transform_config: {
            anyOf: [
                {
                    $ref: "#/components/schemas/AutoTransformConfig"
                },
                {
                    $ref: "#/components/schemas/AdvancedModeTransformConfig"
                }
            ],
            title: "Transform Config",
            description: "Configuration for the transformation."
        },
        preset_retrieval_parameters: {
            $ref: "#/components/schemas/PresetRetrievalParams",
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            $ref: "#/components/schemas/EvalExecutionParams",
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/LlamaParseParameters"
                },
                {
                    type: "null"
                }
            ],
            description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
        },
        data_sink: {
            anyOf: [
                {
                    $ref: "#/components/schemas/DataSink"
                },
                {
                    type: "null"
                }
            ],
            description: "The data sink for the pipeline. If None, the pipeline will use the fully managed data sink."
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "project_id",
        "embedding_config"
    ],
    title: "Pipeline",
    description: "Schema for a pipeline."
};
const PipelineConfigurationHashesSchema = {
    properties: {
        embedding_config_hash: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding Config Hash",
            description: "Hash of the embedding config.",
            default: ""
        },
        parsing_config_hash: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Parsing Config Hash",
            description: "Hash of the llama parse parameters.",
            default: ""
        },
        transform_config_hash: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Transform Config Hash",
            description: "Hash of the transform config.",
            default: ""
        }
    },
    type: "object",
    title: "PipelineConfigurationHashes",
    description: "Hashes for the configuration of a pipeline."
};
const PipelineCreateSchema = {
    properties: {
        embedding_config: {
            anyOf: [
                {
                    oneOf: [
                        {
                            $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/CohereEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/GeminiEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/OpenAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/VertexAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/BedrockEmbeddingConfig"
                        }
                    ],
                    discriminator: {
                        propertyName: "type",
                        mapping: {
                            AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
                            BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
                            COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
                            GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
                            HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
                            OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
                            VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig"
                        }
                    }
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding Config"
        },
        transform_config: {
            anyOf: [
                {
                    $ref: "#/components/schemas/AutoTransformConfig"
                },
                {
                    $ref: "#/components/schemas/AdvancedModeTransformConfig"
                },
                {
                    type: "null"
                }
            ],
            title: "Transform Config",
            description: "Configuration for the transformation."
        },
        configured_transformations: {
            anyOf: [
                {
                    items: {
                        $ref: "#/components/schemas/ConfiguredTransformationItem"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Configured Transformations",
            description: "Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.",
            default: []
        },
        data_sink_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Sink Id",
            description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID."
        },
        data_sink: {
            anyOf: [
                {
                    $ref: "#/components/schemas/DataSinkCreate"
                },
                {
                    type: "null"
                }
            ],
            description: "Data sink. When provided instead of data_sink_id, the data sink will be created."
        },
        preset_retrieval_parameters: {
            $ref: "#/components/schemas/PresetRetrievalParams",
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            $ref: "#/components/schemas/EvalExecutionParams",
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            $ref: "#/components/schemas/LlamaParseParameters"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        pipeline_type: {
            $ref: "#/components/schemas/PipelineType",
            description: "Type of pipeline. Either PLAYGROUND or MANAGED.",
            default: "MANAGED"
        },
        managed_pipeline_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "PipelineCreate",
    description: "Schema for creating a pipeline."
};
const PipelineDataSourceSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the data source."
        },
        source_type: {
            $ref: "#/components/schemas/ConfigurableDataSourceNames"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata that will be present on all data loaded from the data source"
        },
        component: {
            anyOf: [
                {
                    type: "object"
                },
                {
                    $ref: "#/components/schemas/CloudS3DataSource"
                },
                {
                    $ref: "#/components/schemas/CloudAzStorageBlobDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudGoogleDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudOneDriveDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSharepointDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudSlackDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudNotionPageDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudConfluenceDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudJiraDataSource"
                },
                {
                    $ref: "#/components/schemas/CloudBoxDataSource"
                }
            ],
            title: "Component"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id"
        },
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source."
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline."
        },
        last_synced_at: {
            type: "string",
            format: "date-time",
            title: "Last Synced At",
            description: "The last time the data source was automatically synced."
        },
        sync_interval: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Sync Interval",
            description: "The interval at which the data source should be synced."
        },
        sync_schedule_set_by: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Sync Schedule Set By",
            description: "The id of the user who set the sync schedule."
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "source_type",
        "component",
        "project_id",
        "data_source_id",
        "pipeline_id",
        "last_synced_at"
    ],
    title: "PipelineDataSource",
    description: "Schema for a data source in a pipeline."
};
const PipelineDataSourceCreateSchema = {
    properties: {
        data_source_id: {
            type: "string",
            format: "uuid",
            title: "Data Source Id",
            description: "The ID of the data source."
        },
        sync_interval: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Sync Interval",
            description: "The interval at which the data source should be synced."
        }
    },
    type: "object",
    required: [
        "data_source_id"
    ],
    title: "PipelineDataSourceCreate",
    description: "Schema for creating an association between a data source and a pipeline."
};
const PipelineDataSourceUpdateSchema = {
    properties: {
        sync_interval: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Sync Interval",
            description: "The interval at which the data source should be synced."
        }
    },
    type: "object",
    title: "PipelineDataSourceUpdate",
    description: "Schema for updating an association between a data source and a pipeline."
};
const PipelineDeploymentSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        status: {
            $ref: "#/components/schemas/ManagedIngestionStatus",
            description: "Status of the pipeline deployment."
        },
        started_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Started At",
            description: "Time the pipeline deployment started."
        },
        ended_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Ended At",
            description: "Time the pipeline deployment finished."
        }
    },
    type: "object",
    required: [
        "id",
        "status"
    ],
    title: "PipelineDeployment"
};
const PipelineFileSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Name"
        },
        file_size: {
            anyOf: [
                {
                    type: "integer",
                    minimum: 0
                },
                {
                    type: "null"
                }
            ],
            title: "File Size",
            description: "Size of the file in bytes"
        },
        file_type: {
            anyOf: [
                {
                    type: "string",
                    maxLength: 3000,
                    minLength: 1
                },
                {
                    type: "null"
                }
            ],
            title: "File Type",
            description: "File type (e.g. pdf, docx, etc.)"
        },
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project that the file belongs to"
        },
        last_modified_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Last Modified At",
            description: "The last modified time of the file"
        },
        resource_info: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Resource Info",
            description: "Resource information for the file"
        },
        data_source_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Source Id",
            description: "The ID of the data source that the file belongs to"
        },
        file_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "File Id",
            description: "The ID of the file"
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the file is associated with"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        },
        config_hash: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Config Hash",
            description: "Hashes for the configuration of the pipeline."
        }
    },
    type: "object",
    required: [
        "id",
        "project_id",
        "pipeline_id"
    ],
    title: "PipelineFile",
    description: "Schema for a file that is associated with a pipeline."
};
const PipelineFileCreateSchema = {
    properties: {
        file_id: {
            type: "string",
            format: "uuid",
            title: "File Id",
            description: "The ID of the file"
        },
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        }
    },
    type: "object",
    required: [
        "file_id"
    ],
    title: "PipelineFileCreate",
    description: "Schema for creating a file that is associated with a pipeline."
};
const PipelineFileUpdateSchema = {
    properties: {
        custom_metadata: {
            anyOf: [
                {
                    additionalProperties: {
                        anyOf: [
                            {
                                type: "object"
                            },
                            {
                                items: {},
                                type: "array"
                            },
                            {
                                type: "string"
                            },
                            {
                                type: "integer"
                            },
                            {
                                type: "number"
                            },
                            {
                                type: "boolean"
                            },
                            {
                                type: "null"
                            }
                        ]
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Custom Metadata",
            description: "Custom metadata for the file"
        }
    },
    type: "object",
    title: "PipelineFileUpdate",
    description: "Schema for updating a file that is associated with a pipeline."
};
const PipelineTypeSchema = {
    type: "string",
    enum: [
        "PLAYGROUND",
        "MANAGED"
    ],
    title: "PipelineType",
    description: "Enum for representing the type of a pipeline"
};
const PipelineUpdateSchema = {
    properties: {
        embedding_config: {
            anyOf: [
                {
                    oneOf: [
                        {
                            $ref: "#/components/schemas/AzureOpenAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/CohereEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/GeminiEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/OpenAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/VertexAIEmbeddingConfig"
                        },
                        {
                            $ref: "#/components/schemas/BedrockEmbeddingConfig"
                        }
                    ],
                    discriminator: {
                        propertyName: "type",
                        mapping: {
                            AZURE_EMBEDDING: "#/components/schemas/AzureOpenAIEmbeddingConfig",
                            BEDROCK_EMBEDDING: "#/components/schemas/BedrockEmbeddingConfig",
                            COHERE_EMBEDDING: "#/components/schemas/CohereEmbeddingConfig",
                            GEMINI_EMBEDDING: "#/components/schemas/GeminiEmbeddingConfig",
                            HUGGINGFACE_API_EMBEDDING: "#/components/schemas/HuggingFaceInferenceAPIEmbeddingConfig",
                            OPENAI_EMBEDDING: "#/components/schemas/OpenAIEmbeddingConfig",
                            VERTEXAI_EMBEDDING: "#/components/schemas/VertexAIEmbeddingConfig"
                        }
                    }
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding Config"
        },
        transform_config: {
            anyOf: [
                {
                    $ref: "#/components/schemas/AutoTransformConfig"
                },
                {
                    $ref: "#/components/schemas/AdvancedModeTransformConfig"
                },
                {
                    type: "null"
                }
            ],
            title: "Transform Config",
            description: "Configuration for the transformation."
        },
        configured_transformations: {
            anyOf: [
                {
                    items: {
                        $ref: "#/components/schemas/ConfiguredTransformationItem"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Configured Transformations",
            description: "Deprecated, use embedding_config or transform_config instead. configured transformations for the pipeline.",
            default: []
        },
        data_sink_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Data Sink Id",
            description: "Data sink ID. When provided instead of data_sink, the data sink will be looked up by ID."
        },
        data_sink: {
            anyOf: [
                {
                    $ref: "#/components/schemas/DataSinkCreate"
                },
                {
                    type: "null"
                }
            ],
            description: "Data sink. When provided instead of data_sink_id, the data sink will be created."
        },
        preset_retrieval_parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/PresetRetrievalParams"
                },
                {
                    type: "null"
                }
            ],
            description: "Preset retrieval parameters for the pipeline."
        },
        eval_parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/EvalExecutionParams"
                },
                {
                    type: "null"
                }
            ],
            description: "Eval parameters for the pipeline."
        },
        llama_parse_parameters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/LlamaParseParameters"
                },
                {
                    type: "null"
                }
            ],
            description: "Settings that can be configured for how to use LlamaParse to parse files within a LlamaCloud pipeline."
        },
        name: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Name"
        },
        managed_pipeline_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Managed Pipeline Id",
            description: "The ID of the ManagedPipeline this playground pipeline is linked to."
        }
    },
    type: "object",
    title: "PipelineUpdate",
    description: "Schema for updating a pipeline."
};
const PlaygroundSessionSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id"
        },
        user_id: {
            type: "string",
            title: "User Id"
        },
        llm_params_id: {
            type: "string",
            format: "uuid",
            title: "Llm Params Id"
        },
        llm_params: {
            $ref: "#/components/schemas/LLMParameters",
            description: "LLM parameters last used in this session."
        },
        retrieval_params_id: {
            type: "string",
            format: "uuid",
            title: "Retrieval Params Id"
        },
        retrieval_params: {
            $ref: "#/components/schemas/PresetRetrievalParams",
            description: "Preset retrieval parameters last used in this session."
        },
        chat_messages: {
            items: {
                $ref: "#/components/schemas/ChatMessage"
            },
            type: "array",
            title: "Chat Messages",
            description: "Chat message history for this session."
        }
    },
    type: "object",
    required: [
        "id",
        "pipeline_id",
        "user_id",
        "llm_params_id",
        "retrieval_params_id"
    ],
    title: "PlaygroundSession",
    description: "A playground session for a user."
};
const PoolingSchema = {
    type: "string",
    enum: [
        "cls",
        "mean",
        "last"
    ],
    title: "Pooling",
    description: "Enum of possible pooling choices with pooling behaviors."
};
const PresetRetrievalParamsSchema = {
    properties: {
        dense_similarity_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Dense Similarity Top K",
            description: "Number of nodes for dense retrieval.",
            default: 30
        },
        sparse_similarity_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Sparse Similarity Top K",
            description: "Number of nodes for sparse retrieval.",
            default: 30
        },
        enable_reranking: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Enable Reranking",
            description: "Enable reranking for retrieval"
        },
        rerank_top_n: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Rerank Top N",
            description: "Number of reranked nodes for returning.",
            default: 3
        },
        alpha: {
            anyOf: [
                {
                    type: "number",
                    maximum: 1,
                    minimum: 0
                },
                {
                    type: "null"
                }
            ],
            title: "Alpha",
            description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval."
        },
        search_filters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/MetadataFilters"
                },
                {
                    type: "null"
                }
            ],
            description: "Search filters for retrieval."
        },
        files_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 5,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Files Top K",
            description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
            default: 1
        },
        retrieval_mode: {
            $ref: "#/components/schemas/RetrievalMode",
            description: "The retrieval mode for the query.",
            default: "auto_routed"
        },
        retrieve_image_nodes: {
            type: "boolean",
            title: "Retrieve Image Nodes",
            description: "Whether to retrieve image nodes.",
            default: false
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    title: "PresetRetrievalParams",
    description: "Schema for the search params for an retrieval execution that can be preset for a pipeline."
};
const PresignedUrlSchema = {
    properties: {
        url: {
            type: "string",
            minLength: 1,
            format: "uri",
            title: "Url",
            description: "A presigned URL for IO operations against a private file"
        },
        expires_at: {
            type: "string",
            format: "date-time",
            title: "Expires At",
            description: "The time at which the presigned URL expires"
        },
        form_fields: {
            anyOf: [
                {
                    additionalProperties: {
                        type: "string"
                    },
                    type: "object"
                },
                {
                    type: "null"
                }
            ],
            title: "Form Fields",
            description: "Form fields for a presigned POST request"
        }
    },
    type: "object",
    required: [
        "url",
        "expires_at"
    ],
    title: "PresignedUrl",
    description: "Schema for a presigned URL."
};
const ProjectSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        },
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        ad_hoc_eval_dataset_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Ad Hoc Eval Dataset Id"
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The Organization ID the project is under."
        },
        is_default: {
            type: "boolean",
            title: "Is Default",
            description: "Whether this project is the default project for the user.",
            default: false
        }
    },
    type: "object",
    required: [
        "name",
        "id",
        "organization_id"
    ],
    title: "Project",
    description: "Schema for a project."
};
const ProjectCreateSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "ProjectCreate",
    description: "Schema for creating a project."
};
const ProjectUpdateSchema = {
    properties: {
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name"
        }
    },
    type: "object",
    required: [
        "name"
    ],
    title: "ProjectUpdate",
    description: "Schema for updating a project."
};
const PromptMixinPromptsSchema = {
    properties: {
        project_id: {
            type: "string",
            format: "uuid",
            title: "Project Id",
            description: "The ID of the project."
        },
        id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Id",
            description: "The ID of the prompt set."
        },
        name: {
            type: "string",
            title: "Name",
            description: "The name of the prompt set."
        },
        prompts: {
            items: {
                $ref: "#/components/schemas/PromptSpec"
            },
            type: "array",
            title: "Prompts",
            description: "The prompts."
        }
    },
    type: "object",
    required: [
        "project_id",
        "name",
        "prompts"
    ],
    title: "PromptMixinPrompts",
    description: "Schema for the prompts derived from the PromptMixin."
};
const PromptSpecSchema = {
    properties: {
        prompt_key: {
            type: "string",
            title: "Prompt Key",
            description: "The key of the prompt in the PromptMixin."
        },
        prompt_class: {
            type: "string",
            title: "Prompt Class",
            description: "The class of the prompt (PromptTemplate or ChatPromptTemplate)."
        },
        prompt_type: {
            type: "string",
            title: "Prompt Type",
            description: "The type of prompt."
        },
        template: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Template",
            description: "The template of the prompt."
        },
        message_templates: {
            anyOf: [
                {
                    items: {
                        $ref: "#/components/schemas/ChatMessage"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Message Templates",
            description: "The chat message templates of the prompt."
        }
    },
    type: "object",
    required: [
        "prompt_key",
        "prompt_class",
        "prompt_type"
    ],
    title: "PromptSpec"
};
const PydanticProgramModeSchema = {
    type: "string",
    enum: [
        "default",
        "openai",
        "llm",
        "function",
        "guidance",
        "lm-format-enforcer"
    ],
    title: "PydanticProgramMode",
    description: "Pydantic program mode."
};
const RelatedNodeInfoSchema = {
    properties: {
        node_id: {
            type: "string",
            title: "Node Id"
        },
        node_type: {
            anyOf: [
                {
                    $ref: "#/components/schemas/ObjectType"
                },
                {
                    type: "null"
                }
            ]
        },
        metadata: {
            type: "object",
            title: "Metadata"
        },
        hash: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Hash"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "RelatedNodeInfo"
        }
    },
    type: "object",
    required: [
        "node_id"
    ],
    title: "RelatedNodeInfo"
};
const RetrievalModeSchema = {
    type: "string",
    enum: [
        "chunks",
        "files_via_metadata",
        "files_via_content",
        "auto_routed"
    ],
    title: "RetrievalMode"
};
const RetrievalParamsSchema = {
    properties: {
        dense_similarity_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Dense Similarity Top K",
            description: "Number of nodes for dense retrieval.",
            default: 30
        },
        sparse_similarity_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Sparse Similarity Top K",
            description: "Number of nodes for sparse retrieval.",
            default: 30
        },
        enable_reranking: {
            anyOf: [
                {
                    type: "boolean"
                },
                {
                    type: "null"
                }
            ],
            title: "Enable Reranking",
            description: "Enable reranking for retrieval"
        },
        rerank_top_n: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 100,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Rerank Top N",
            description: "Number of reranked nodes for returning.",
            default: 3
        },
        alpha: {
            anyOf: [
                {
                    type: "number",
                    maximum: 1,
                    minimum: 0
                },
                {
                    type: "null"
                }
            ],
            title: "Alpha",
            description: "Alpha value for hybrid retrieval to determine the weights between dense and sparse retrieval. 0 is sparse retrieval and 1 is dense retrieval."
        },
        search_filters: {
            anyOf: [
                {
                    $ref: "#/components/schemas/MetadataFilters"
                },
                {
                    type: "null"
                }
            ],
            description: "Search filters for retrieval."
        },
        files_top_k: {
            anyOf: [
                {
                    type: "integer",
                    maximum: 5,
                    minimum: 1
                },
                {
                    type: "null"
                }
            ],
            title: "Files Top K",
            description: "Number of files to retrieve (only for retrieval mode files_via_metadata and files_via_content).",
            default: 1
        },
        retrieval_mode: {
            $ref: "#/components/schemas/RetrievalMode",
            description: "The retrieval mode for the query.",
            default: "auto_routed"
        },
        retrieve_image_nodes: {
            type: "boolean",
            title: "Retrieve Image Nodes",
            description: "Whether to retrieve image nodes.",
            default: false
        },
        query: {
            type: "string",
            title: "Query",
            description: "The query to retrieve against."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "base_component"
        }
    },
    type: "object",
    required: [
        "query"
    ],
    title: "RetrievalParams",
    description: "Schema for the search params for an retrieval execution."
};
const RetrieveResultsSchema = {
    properties: {
        pipeline_id: {
            type: "string",
            format: "uuid",
            title: "Pipeline Id",
            description: "The ID of the pipeline that the query was retrieved against."
        },
        retrieval_nodes: {
            items: {
                $ref: "#/components/schemas/TextNodeWithScore"
            },
            type: "array",
            title: "Retrieval Nodes",
            description: "The nodes retrieved by the pipeline for the given query."
        },
        image_nodes: {
            items: {
                $ref: "#/components/schemas/PageScreenshotNodeWithScore"
            },
            type: "array",
            title: "Image Nodes",
            description: "The image nodes retrieved by the pipeline for the given query."
        },
        retrieval_latency: {
            additionalProperties: {
                type: "number"
            },
            type: "object",
            title: "Retrieval Latency",
            description: "The end-to-end latency for retrieval and reranking."
        },
        metadata: {
            additionalProperties: {
                type: "string"
            },
            type: "object",
            title: "Metadata",
            description: "Metadata associated with the retrieval execution"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "RetrieveResults"
        }
    },
    type: "object",
    required: [
        "pipeline_id",
        "retrieval_nodes",
        "retrieval_latency"
    ],
    title: "RetrieveResults",
    description: "Schema for the result of an retrieval execution."
};
const RoleSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        name: {
            type: "string",
            maxLength: 3000,
            minLength: 1,
            title: "Name",
            description: "A name for the role."
        },
        organization_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Organization Id",
            description: "The organization's ID."
        },
        permissions: {
            items: {
                $ref: "#/components/schemas/Permission"
            },
            type: "array",
            title: "Permissions",
            description: "The actual permissions of the role."
        }
    },
    type: "object",
    required: [
        "id",
        "name",
        "organization_id",
        "permissions"
    ],
    title: "Role",
    description: "Schema for a role."
};
const SemanticChunkingConfigSchema = {
    properties: {
        mode: {
            type: "string",
            enum: [
                "semantic"
            ],
            const: "semantic",
            title: "Mode",
            default: "semantic"
        },
        buffer_size: {
            type: "integer",
            title: "Buffer Size",
            default: 1
        },
        breakpoint_percentile_threshold: {
            type: "integer",
            title: "Breakpoint Percentile Threshold",
            default: 95
        }
    },
    type: "object",
    title: "SemanticChunkingConfig"
};
const SentenceChunkingConfigSchema = {
    properties: {
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            default: 200,
            gte: 0
        },
        mode: {
            type: "string",
            enum: [
                "sentence"
            ],
            const: "sentence",
            title: "Mode",
            default: "sentence"
        },
        separator: {
            type: "string",
            title: "Separator",
            default: " "
        },
        paragraph_separator: {
            type: "string",
            title: "Paragraph Separator",
            default: `


`
        }
    },
    type: "object",
    title: "SentenceChunkingConfig"
};
const SentenceSplitterSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "The token chunk size for each chunk.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            minimum: 0,
            title: "Chunk Overlap",
            description: "The token overlap of each chunk when splitting.",
            default: 200
        },
        separator: {
            type: "string",
            title: "Separator",
            description: "Default separator for splitting into words",
            default: " "
        },
        paragraph_separator: {
            type: "string",
            title: "Paragraph Separator",
            description: "Separator between paragraphs.",
            default: `


`
        },
        secondary_chunking_regex: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Secondary Chunking Regex",
            description: "Backup regex for splitting into sentences.",
            default: "[^,.;。？！]+[,.;。？！]?"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "SentenceSplitter"
        }
    },
    type: "object",
    title: "SentenceSplitter",
    description: `Parse text with a preference for complete sentences.

In general, this class tries to keep sentences and paragraphs together. Therefore
compared to the original TokenTextSplitter, there are less likely to be
hanging sentences or parts of sentences at the end of the node chunk.`
};
const StatusEnumSchema = {
    type: "string",
    enum: [
        "PENDING",
        "SUCCESS",
        "ERROR",
        "PARTIAL_SUCCESS"
    ],
    title: "StatusEnum",
    description: "Enum for representing the status of a job"
};
const SupportedLLMModelSchema = {
    properties: {
        name: {
            $ref: "#/components/schemas/SupportedLLMModelNames",
            description: "The name of the supported LLM model."
        },
        enabled: {
            type: "boolean",
            title: "Enabled",
            description: "Whether the LLM model is enabled for use in LlamaCloud.",
            default: true
        },
        details: {
            $ref: "#/components/schemas/LLMModelData",
            description: "The details of the supported LLM model."
        }
    },
    type: "object",
    required: [
        "name",
        "details"
    ],
    title: "SupportedLLMModel",
    description: "Response Schema for a supported eval LLM model."
};
const SupportedLLMModelNamesSchema = {
    type: "string",
    enum: [
        "GPT_3_5_TURBO",
        "GPT_4",
        "GPT_4_TURBO",
        "GPT_4O",
        "GPT_4O_MINI",
        "AZURE_OPENAI"
    ],
    title: "SupportedLLMModelNames"
};
const TextNodeSchema = {
    properties: {
        id_: {
            type: "string",
            title: "Id ",
            description: "Unique ID of the node."
        },
        embedding: {
            anyOf: [
                {
                    items: {
                        type: "number"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Embedding",
            description: "Embedding of the node."
        },
        extra_info: {
            type: "object",
            title: "Extra Info",
            description: "A flat dictionary of metadata fields"
        },
        excluded_embed_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Embed Metadata Keys",
            description: "Metadata keys that are excluded from text for the embed model."
        },
        excluded_llm_metadata_keys: {
            items: {
                type: "string"
            },
            type: "array",
            title: "Excluded Llm Metadata Keys",
            description: "Metadata keys that are excluded from text for the LLM."
        },
        relationships: {
            additionalProperties: {
                anyOf: [
                    {
                        $ref: "#/components/schemas/RelatedNodeInfo"
                    },
                    {
                        items: {
                            $ref: "#/components/schemas/RelatedNodeInfo"
                        },
                        type: "array"
                    }
                ]
            },
            type: "object",
            title: "Relationships",
            description: "A mapping of relationships to other node information."
        },
        text: {
            type: "string",
            title: "Text",
            description: "Text content of the node.",
            default: ""
        },
        mimetype: {
            type: "string",
            title: "Mimetype",
            description: "MIME type of the node content.",
            default: "text/plain"
        },
        start_char_idx: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Start Char Idx",
            description: "Start char index of the node."
        },
        end_char_idx: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "End Char Idx",
            description: "End char index of the node."
        },
        text_template: {
            type: "string",
            title: "Text Template",
            description: "Template for how text is formatted, with {content} and {metadata_str} placeholders.",
            default: `{metadata_str}

{content}`
        },
        metadata_template: {
            type: "string",
            title: "Metadata Template",
            description: "Template for how metadata is formatted, with {key} and {value} placeholders.",
            default: "{key}: {value}"
        },
        metadata_seperator: {
            type: "string",
            title: "Metadata Seperator",
            description: "Separator between metadata fields when converting to string.",
            default: `
`
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "TextNode"
        }
    },
    type: "object",
    title: "TextNode"
};
const TextNodeWithScoreSchema = {
    properties: {
        node: {
            $ref: "#/components/schemas/TextNode"
        },
        score: {
            anyOf: [
                {
                    type: "number"
                },
                {
                    type: "null"
                }
            ],
            title: "Score"
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "TextNodeWithScore"
        }
    },
    type: "object",
    required: [
        "node"
    ],
    title: "TextNodeWithScore",
    description: `Same as NodeWithScore but type for node is a TextNode instead of BaseNode.
FastAPI doesn't accept abstract classes like BaseNode.`
};
const TokenChunkingConfigSchema = {
    properties: {
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            title: "Chunk Overlap",
            default: 200,
            gte: 0
        },
        mode: {
            type: "string",
            enum: [
                "token"
            ],
            const: "token",
            title: "Mode",
            default: "token"
        },
        separator: {
            type: "string",
            title: "Separator",
            default: " "
        }
    },
    type: "object",
    title: "TokenChunkingConfig"
};
const TokenTextSplitterSchema = {
    properties: {
        include_metadata: {
            type: "boolean",
            title: "Include Metadata",
            description: "Whether or not to consider metadata when splitting.",
            default: true
        },
        include_prev_next_rel: {
            type: "boolean",
            title: "Include Prev Next Rel",
            description: "Include prev/next node relationships.",
            default: true
        },
        callback_manager: {
            title: "Callback Manager"
        },
        id_func: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Id Func",
            description: "Function to generate node IDs."
        },
        chunk_size: {
            type: "integer",
            exclusiveMinimum: 0,
            title: "Chunk Size",
            description: "The token chunk size for each chunk.",
            default: 1024
        },
        chunk_overlap: {
            type: "integer",
            minimum: 0,
            title: "Chunk Overlap",
            description: "The token overlap of each chunk when splitting.",
            default: 20
        },
        separator: {
            type: "string",
            title: "Separator",
            description: "Default separator for splitting into words",
            default: " "
        },
        backup_separators: {
            items: {},
            type: "array",
            title: "Backup Separators",
            description: "Additional separators for splitting."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "TokenTextSplitter"
        }
    },
    type: "object",
    title: "TokenTextSplitter",
    description: "Implementation of splitting text that looks at word tokens."
};
const TransformationCategoryNamesSchema = {
    type: "string",
    enum: [
        "NODE_PARSER",
        "EMBEDDING"
    ],
    title: "TransformationCategoryNames"
};
const UserOrganizationSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        email: {
            type: "string",
            format: "email",
            title: "Email",
            description: "The user's email address."
        },
        user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Id",
            description: "The user's ID."
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        },
        pending: {
            type: "boolean",
            title: "Pending",
            description: "Whether the user's membership is pending account signup.",
            default: true
        },
        invited_by_user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Invited By User Id",
            description: "The user ID of the user who added the user to the organization."
        },
        invited_by_user_email: {
            anyOf: [
                {
                    type: "string",
                    format: "email"
                },
                {
                    type: "null"
                }
            ],
            title: "Invited By User Email",
            description: "The email address of the user who added the user to the organization."
        },
        roles: {
            items: {
                $ref: "#/components/schemas/UserOrganizationRole"
            },
            type: "array",
            title: "Roles",
            description: "The roles of the user in the organization."
        }
    },
    type: "object",
    required: [
        "id",
        "email",
        "organization_id",
        "roles"
    ],
    title: "UserOrganization",
    description: "Schema for a user's membership to an organization."
};
const UserOrganizationCreateSchema = {
    properties: {
        user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Id",
            description: "The user's ID."
        },
        email: {
            anyOf: [
                {
                    type: "string",
                    format: "email"
                },
                {
                    type: "null"
                }
            ],
            title: "Email",
            description: "The user's email address."
        },
        project_ids: {
            anyOf: [
                {
                    items: {
                        type: "string",
                        format: "uuid"
                    },
                    type: "array"
                },
                {
                    type: "null"
                }
            ],
            title: "Project Ids",
            description: "The project IDs to add the user to."
        },
        role_id: {
            anyOf: [
                {
                    type: "string",
                    format: "uuid"
                },
                {
                    type: "null"
                }
            ],
            title: "Role Id",
            description: "The role ID to assign to the user."
        }
    },
    type: "object",
    required: [
        "project_ids"
    ],
    title: "UserOrganizationCreate",
    description: "Schema for creating a user's membership to an organization."
};
const UserOrganizationDeleteSchema = {
    properties: {
        user_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "User Id",
            description: "The user's ID."
        },
        email: {
            anyOf: [
                {
                    type: "string",
                    format: "email"
                },
                {
                    type: "null"
                }
            ],
            title: "Email",
            description: "The user's email address."
        }
    },
    type: "object",
    title: "UserOrganizationDelete",
    description: "Schema for deleting a user's membership to an organization."
};
const UserOrganizationRoleSchema = {
    properties: {
        id: {
            type: "string",
            format: "uuid",
            title: "Id",
            description: "Unique identifier"
        },
        created_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Created At",
            description: "Creation datetime"
        },
        updated_at: {
            anyOf: [
                {
                    type: "string",
                    format: "date-time"
                },
                {
                    type: "null"
                }
            ],
            title: "Updated At",
            description: "Update datetime"
        },
        user_id: {
            type: "string",
            title: "User Id",
            description: "The user's ID."
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        },
        role_id: {
            type: "string",
            format: "uuid",
            title: "Role Id",
            description: "The role's ID."
        },
        role: {
            $ref: "#/components/schemas/Role",
            description: "The role."
        }
    },
    type: "object",
    required: [
        "id",
        "user_id",
        "organization_id",
        "role_id",
        "role"
    ],
    title: "UserOrganizationRole",
    description: "Schema for a user's role in an organization."
};
const UserOrganizationRoleCreateSchema = {
    properties: {
        user_id: {
            type: "string",
            title: "User Id",
            description: "The user's ID."
        },
        organization_id: {
            type: "string",
            format: "uuid",
            title: "Organization Id",
            description: "The organization's ID."
        },
        role_id: {
            type: "string",
            format: "uuid",
            title: "Role Id",
            description: "The role's ID."
        }
    },
    type: "object",
    required: [
        "user_id",
        "organization_id",
        "role_id"
    ],
    title: "UserOrganizationRoleCreate",
    description: "Schema for creating a user's role in an organization."
};
const ValidationErrorSchema = {
    properties: {
        loc: {
            items: {
                anyOf: [
                    {
                        type: "string"
                    },
                    {
                        type: "integer"
                    }
                ]
            },
            type: "array",
            title: "Location"
        },
        msg: {
            type: "string",
            title: "Message"
        },
        type: {
            type: "string",
            title: "Error Type"
        }
    },
    type: "object",
    required: [
        "loc",
        "msg",
        "type"
    ],
    title: "ValidationError"
};
const VertexAIEmbeddingConfigSchema = {
    properties: {
        type: {
            type: "string",
            enum: [
                "VERTEXAI_EMBEDDING"
            ],
            const: "VERTEXAI_EMBEDDING",
            title: "Type",
            description: "Type of the embedding model.",
            default: "VERTEXAI_EMBEDDING"
        },
        component: {
            $ref: "#/components/schemas/VertexTextEmbedding",
            description: "Configuration for the VertexAI embedding model."
        }
    },
    type: "object",
    title: "VertexAIEmbeddingConfig"
};
const VertexEmbeddingModeSchema = {
    type: "string",
    enum: [
        "default",
        "classification",
        "clustering",
        "similarity",
        "retrieval"
    ],
    title: "VertexEmbeddingMode",
    description: `Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.`
};
const VertexTextEmbeddingSchema = {
    properties: {
        model_name: {
            type: "string",
            title: "Model Name",
            description: "The modelId of the VertexAI model to use.",
            default: "textembedding-gecko@003"
        },
        embed_batch_size: {
            type: "integer",
            maximum: 2048,
            exclusiveMinimum: 0,
            title: "Embed Batch Size",
            description: "The batch size for embedding calls.",
            default: 10
        },
        num_workers: {
            anyOf: [
                {
                    type: "integer"
                },
                {
                    type: "null"
                }
            ],
            title: "Num Workers",
            description: "The number of workers to use for async embedding calls."
        },
        location: {
            type: "string",
            title: "Location",
            description: "The default location to use when making API calls."
        },
        project: {
            type: "string",
            title: "Project",
            description: "The default GCP project to use when making Vertex API calls."
        },
        embed_mode: {
            $ref: "#/components/schemas/VertexEmbeddingMode",
            description: "The embedding mode to use.",
            default: "retrieval"
        },
        additional_kwargs: {
            type: "object",
            title: "Additional Kwargs",
            description: "Additional kwargs for the Vertex."
        },
        client_email: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Client Email",
            description: "The client email for the VertexAI credentials."
        },
        token_uri: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Token Uri",
            description: "The token URI for the VertexAI credentials."
        },
        private_key_id: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Private Key Id",
            description: "The private key ID for the VertexAI credentials."
        },
        private_key: {
            anyOf: [
                {
                    type: "string"
                },
                {
                    type: "null"
                }
            ],
            title: "Private Key",
            description: "The private key for the VertexAI credentials."
        },
        class_name: {
            type: "string",
            title: "Class Name",
            default: "VertexTextEmbedding"
        }
    },
    type: "object",
    required: [
        "location",
        "project",
        "client_email",
        "token_uri",
        "private_key_id",
        "private_key"
    ],
    title: "VertexTextEmbedding"
};

var T = /\{[^{}]+\}/g, h = ({ allowReserved: n, name: i, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${i}=${n ? e : encodeURIComponent(e)}`;
}, U = (n)=>{
    switch(n){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, $ = (n)=>{
    switch(n){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (n)=>{
    switch(n){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, j = ({ allowReserved: n, explode: i, name: e, style: a, value: o })=>{
    if (!i) {
        let r = (n ? o : o.map((c)=>encodeURIComponent(c))).join($(a));
        switch(a){
            case "label":
                return `.${r}`;
            case "matrix":
                return `;${e}=${r}`;
            case "simple":
                return r;
            default:
                return `${e}=${r}`;
        }
    }
    let s = U(a), t = o.map((r)=>a === "label" || a === "simple" ? n ? r : encodeURIComponent(r) : h({
            allowReserved: n,
            name: e,
            value: r
        })).join(s);
    return a === "label" || a === "matrix" ? s + t : t;
}, C = ({ allowReserved: n, explode: i, name: e, style: a, value: o })=>{
    if (o instanceof Date) return `${e}=${o.toISOString()}`;
    if (a !== "deepObject" && !i) {
        let r = [];
        Object.entries(o).forEach(([u, l])=>{
            r = [
                ...r,
                u,
                n ? l : encodeURIComponent(l)
            ];
        });
        let c = r.join(",");
        switch(a){
            case "form":
                return `${e}=${c}`;
            case "label":
                return `.${c}`;
            case "matrix":
                return `;${e}=${c}`;
            default:
                return c;
        }
    }
    let s = D(a), t = Object.entries(o).map(([r, c])=>h({
            allowReserved: n,
            name: a === "deepObject" ? `${e}[${r}]` : r,
            value: c
        })).join(s);
    return a === "label" || a === "matrix" ? s + t : t;
}, _ = ({ path: n, url: i })=>{
    let e = i, a = i.match(T);
    if (a) for (let o of a){
        let s = !1, t = o.substring(1, o.length - 1), r = "simple";
        t.endsWith("*") && (s = !0, t = t.substring(0, t.length - 1)), t.startsWith(".") ? (t = t.substring(1), r = "label") : t.startsWith(";") && (t = t.substring(1), r = "matrix");
        let c = n[t];
        if (c == null) continue;
        if (Array.isArray(c)) {
            e = e.replace(o, j({
                explode: s,
                name: t,
                style: r,
                value: c
            }));
            continue;
        }
        if (typeof c == "object") {
            e = e.replace(o, C({
                explode: s,
                name: t,
                style: r,
                value: c
            }));
            continue;
        }
        if (r === "matrix") {
            e = e.replace(o, `;${h({
                name: t,
                value: c
            })}`);
            continue;
        }
        let u = encodeURIComponent(r === "label" ? `.${c}` : c);
        e = e.replace(o, u);
    }
    return e;
}, b = ({ allowReserved: n, array: i, object: e } = {})=>(o)=>{
        let s = [];
        if (o && typeof o == "object") for(let t in o){
            let r = o[t];
            if (r != null) {
                if (Array.isArray(r)) {
                    s = [
                        ...s,
                        j({
                            allowReserved: n,
                            explode: !0,
                            name: t,
                            style: "form",
                            value: r,
                            ...i
                        })
                    ];
                    continue;
                }
                if (typeof r == "object") {
                    s = [
                        ...s,
                        C({
                            allowReserved: n,
                            explode: !0,
                            name: t,
                            style: "deepObject",
                            value: r,
                            ...e
                        })
                    ];
                    continue;
                }
                s = [
                    ...s,
                    h({
                        allowReserved: n,
                        name: t,
                        value: r
                    })
                ];
            }
        }
        return s.join("&");
    }, A = (n)=>{
    if (n) {
        if (n.startsWith("application/json") || n.endsWith("+json")) return "json";
        if (n === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((i)=>n.startsWith(i))) return "blob";
        if (n.startsWith("text/")) return "text";
    }
}, w = ({ baseUrl: n, path: i, query: e, querySerializer: a, url: o })=>{
    let s = o.startsWith("/") ? o : `/${o}`, t = n + s;
    i && (t = _({
        path: i,
        url: t
    }));
    let r = e ? a(e) : "";
    return r.startsWith("?") && (r = r.substring(1)), r && (t += `?${r}`), t;
}, R = (n, i)=>{
    let e = {
        ...n,
        ...i
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = O(n.headers, i.headers), e;
}, O = (...n)=>{
    let i = new Headers;
    for (let e of n){
        if (!e || typeof e != "object") continue;
        let a = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [o, s] of a)if (s === null) i.delete(o);
        else if (Array.isArray(s)) for (let t of s)i.append(o, t);
        else s !== void 0 && i.set(o, typeof s == "object" ? JSON.stringify(s) : s);
    }
    return i;
}, y = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    exists(i) {
        return this._fns.indexOf(i) !== -1;
    }
    eject(i) {
        let e = this._fns.indexOf(i);
        e !== -1 && (this._fns = [
            ...this._fns.slice(0, e),
            ...this._fns.slice(e + 1)
        ]);
    }
    use(i) {
        this._fns = [
            ...this._fns,
            i
        ];
    }
}, P = ()=>({
        error: new y,
        request: new y,
        response: new y
    }), q = (n, i, e)=>{
    typeof e == "string" || e instanceof Blob ? n.append(i, e) : n.append(i, JSON.stringify(e));
}, k = {
    bodySerializer: (n)=>{
        let i = new FormData;
        return Object.entries(n).forEach(([e, a])=>{
            a != null && (Array.isArray(a) ? a.forEach((o)=>q(i, e, o)) : q(i, e, a));
        }), i;
    }
}, E = {
    bodySerializer: (n)=>JSON.stringify(n)
}, W = b({
    allowReserved: !1,
    array: {
        explode: !0,
        style: "form"
    },
    object: {
        explode: !0,
        style: "deepObject"
    }
}), B = {
    "Content-Type": "application/json"
}, x = (n = {})=>({
        ...E,
        baseUrl: "",
        fetch: globalThis.fetch,
        headers: B,
        parseAs: "auto",
        querySerializer: W,
        ...n
    });
var J = (n = {})=>{
    let i = R(x(), n), e = ()=>({
            ...i
        }), a = (t)=>(i = R(i, t), e()), o = P(), s = async (t)=>{
        let r = {
            ...i,
            ...t,
            headers: O(i.headers, t.headers)
        };
        r.body && r.bodySerializer && (r.body = r.bodySerializer(r.body)), r.body || r.headers.delete("Content-Type");
        let c = w({
            baseUrl: r.baseUrl ?? "",
            path: r.path,
            query: r.query,
            querySerializer: typeof r.querySerializer == "function" ? r.querySerializer : b(r.querySerializer),
            url: r.url
        }), u = {
            redirect: "follow",
            ...r
        }, l = new Request(c, u);
        for (let f of o.request._fns)l = await f(l, r);
        let I = r.fetch, p = await I(l);
        for (let f of o.response._fns)p = await f(p, l, r);
        let g = {
            request: l,
            response: p
        };
        if (p.ok) {
            if (p.status === 204 || p.headers.get("Content-Length") === "0") return {
                data: {},
                ...g
            };
            if (r.parseAs === "stream") return {
                data: p.body,
                ...g
            };
            let f = (r.parseAs === "auto" ? A(p.headers.get("Content-Type")) : r.parseAs) ?? "json", S = await p[f]();
            return f === "json" && r.responseTransformer && (S = await r.responseTransformer(S)), {
                data: S,
                ...g
            };
        }
        let m = await p.text();
        try {
            m = JSON.parse(m);
        } catch  {}
        let d = m;
        for (let f of o.error._fns)d = await f(m, p, l, r);
        if (d = d || {}, r.throwOnError) throw d;
        return {
            error: d,
            ...g
        };
    };
    return {
        connect: (t)=>s({
                ...t,
                method: "CONNECT"
            }),
        delete: (t)=>s({
                ...t,
                method: "DELETE"
            }),
        get: (t)=>s({
                ...t,
                method: "GET"
            }),
        getConfig: e,
        head: (t)=>s({
                ...t,
                method: "HEAD"
            }),
        interceptors: o,
        options: (t)=>s({
                ...t,
                method: "OPTIONS"
            }),
        patch: (t)=>s({
                ...t,
                method: "PATCH"
            }),
        post: (t)=>s({
                ...t,
                method: "POST"
            }),
        put: (t)=>s({
                ...t,
                method: "PUT"
            }),
        request: s,
        setConfig: a,
        trace: (t)=>s({
                ...t,
                method: "TRACE"
            })
    };
};

// This file is auto-generated by @hey-api/openapi-ts
const client = J(x());
class ApiKeysService {
    /**
   * Generate Key
   * Generate a new API Key.
   */ static generateKeyApiV1ApiKeysPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/api-keys"
        });
    }
    /**
   * List Keys
   * List API Keys for a user.
   */ static listKeysApiV1ApiKeysGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/api-keys"
        });
    }
    /**
   * Delete Api Key
   * Delete an API Key by ID.
   */ static deleteApiKeyApiV1ApiKeysApiKeyIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/api-keys/{api_key_id}"
        });
    }
    /**
   * Update Existing Api Key
   * Update name of an existing API Key.
   */ static updateExistingApiKeyApiV1ApiKeysApiKeyIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/api-keys/{api_key_id}"
        });
    }
}
class ValidationService {
    /**
   * Validate Embedding Connection
   * Validate an embedding connection.
   *
   * Args:
   * embedding_config: The embedding configuration to validate.
   * pipeline_id: If provided, the embedding connection will be validated for the pipeline.
   * user: The user to validate the embedding connection for.
   * db: The database session.
   *
   * Returns:
   * A BaseConnectionValidation object indicating the result of the validation.
   */ static validateEmbeddingConnectionApiV1ValidateIntegrationsValidateEmbeddingConnectionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/validate-integrations/validate-embedding-connection"
        });
    }
    /**
   * Validate Data Source Connection
   * Validate a data source connection.
   */ static validateDataSourceConnectionApiV1ValidateIntegrationsValidateDataSourceConnectionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/validate-integrations/validate-data-source-connection"
        });
    }
    /**
   * Validate Data Sink Connection
   * Validate a data sink connection.
   */ static validateDataSinkConnectionApiV1ValidateIntegrationsValidateDataSinkConnectionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/validate-integrations/validate-data-sink-connection"
        });
    }
}
class DataSinksService {
    /**
   * List Data Sinks
   * List data sinks for a given project.
   * If project_id is not provided, uses the default project.
   */ static listDataSinksApiV1DataSinksGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/data-sinks"
        });
    }
    /**
   * Create Data Sink
   * Create a new data sink.
   */ static createDataSinkApiV1DataSinksPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/data-sinks"
        });
    }
    /**
   * Upsert Data Sink
   * Upserts a data sink.
   * Updates if a data sink with the same name and project_id already exists. Otherwise, creates a new data sink.
   */ static upsertDataSinkApiV1DataSinksPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/data-sinks"
        });
    }
    /**
   * Get Data Sink
   * Get a data sink by ID.
   */ static getDataSinkApiV1DataSinksDataSinkIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/data-sinks/{data_sink_id}"
        });
    }
    /**
   * Update Data Sink
   * Update a data sink by ID.
   */ static updateDataSinkApiV1DataSinksDataSinkIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/data-sinks/{data_sink_id}"
        });
    }
    /**
   * Delete Data Sink
   * Delete a data sink by ID.
   */ static deleteDataSinkApiV1DataSinksDataSinkIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/data-sinks/{data_sink_id}"
        });
    }
}
class DataSourcesService {
    /**
   * List Data Sources
   * List data sources for a given project.
   * If project_id is not provided, uses the default project.
   */ static listDataSourcesApiV1DataSourcesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/data-sources"
        });
    }
    /**
   * Create Data Source
   * Create a new data source.
   */ static createDataSourceApiV1DataSourcesPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/data-sources"
        });
    }
    /**
   * Upsert Data Source
   * Upserts a data source.
   * Updates if a data source with the same name and project_id already exists. Otherwise, creates a new data source.
   */ static upsertDataSourceApiV1DataSourcesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/data-sources"
        });
    }
    /**
   * Get Data Source
   * Get a data source by ID.
   */ static getDataSourceApiV1DataSourcesDataSourceIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/data-sources/{data_source_id}"
        });
    }
    /**
   * Update Data Source
   * Update a data source by ID.
   */ static updateDataSourceApiV1DataSourcesDataSourceIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/data-sources/{data_source_id}"
        });
    }
    /**
   * Delete Data Source
   * Delete a data source by ID.
   */ static deleteDataSourceApiV1DataSourcesDataSourceIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/data-sources/{data_source_id}"
        });
    }
}
class OrganizationsService {
    /**
   * Create Organization
   * Create a new organization.
   */ static createOrganizationApiV1OrganizationsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/organizations"
        });
    }
    /**
   * Upsert Organization
   * Upsert a new organization.
   */ static upsertOrganizationApiV1OrganizationsPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations"
        });
    }
    /**
   * List Organizations
   * List organizations for a user.
   */ static listOrganizationsApiV1OrganizationsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations"
        });
    }
    /**
   * Set Default Organization
   * Set the default organization for the user.
   */ static setDefaultOrganizationApiV1OrganizationsDefaultPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/default"
        });
    }
    /**
   * Get Default Organization
   * Get the default organization for the user.
   */ static getDefaultOrganizationApiV1OrganizationsDefaultGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/default"
        });
    }
    /**
   * Get Organization
   * Get an organization by ID.
   */ static getOrganizationApiV1OrganizationsOrganizationIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/{organization_id}"
        });
    }
    /**
   * Update Organization
   * Update an existing organization.
   */ static updateOrganizationApiV1OrganizationsOrganizationIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/{organization_id}"
        });
    }
    /**
   * Delete Organization
   * Delete an organization by ID.
   */ static deleteOrganizationApiV1OrganizationsOrganizationIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/organizations/{organization_id}"
        });
    }
    /**
   * List Organization Users
   * Get all users in an organization.
   */ static listOrganizationUsersApiV1OrganizationsOrganizationIdUsersGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users"
        });
    }
    /**
   * Add Users To Organization
   * Add a user to an organization.
   */ static addUsersToOrganizationApiV1OrganizationsOrganizationIdUsersPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users"
        });
    }
    /**
   * Remove Users From Organization
   * Remove users from an organization by email.
   */ static removeUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersMemberUserIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/{member_user_id}"
        });
    }
    /**
   * Batch Remove Users From Organization
   * Remove a batch of users from an organization.
   */ static batchRemoveUsersFromOrganizationApiV1OrganizationsOrganizationIdUsersRemovePut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/remove"
        });
    }
    /**
   * List Roles
   * List all roles in an organization.
   */ static listRolesApiV1OrganizationsOrganizationIdRolesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/{organization_id}/roles"
        });
    }
    /**
   * Assign Role To User In Organization
   * Assign a role to a user in an organization.
   */ static assignRoleToUserInOrganizationApiV1OrganizationsOrganizationIdUsersRolesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/roles"
        });
    }
    /**
   * Get User Role
   * Get the role of a user in an organization.
   */ static getUserRoleApiV1OrganizationsOrganizationIdUsersRolesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/roles"
        });
    }
    /**
   * List Projects By User
   * List all projects for a user in an organization.
   */ static listProjectsByUserApiV1OrganizationsOrganizationIdUsersUserIdProjectsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects"
        });
    }
    /**
   * Add User To Project
   * Add a user to a project.
   */ static addUserToProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects"
        });
    }
    /**
   * Remove User From Project
   * Remove a user from a project.
   */ static removeUserFromProjectApiV1OrganizationsOrganizationIdUsersUserIdProjectsProjectIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/organizations/{organization_id}/users/{user_id}/projects/{project_id}"
        });
    }
}
class ProjectsService {
    /**
   * List Projects
   * List projects or get one by name
   */ static listProjectsApiV1ProjectsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects"
        });
    }
    /**
   * Create Project
   * Create a new project.
   */ static createProjectApiV1ProjectsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/projects"
        });
    }
    /**
   * Upsert Project
   * Upsert a project.
   * Updates if a project with the same name already exists. Otherwise, creates a new project.
   */ static upsertProjectApiV1ProjectsPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/projects"
        });
    }
    /**
   * Delete Project
   * Delete a project by ID.
   */ static deleteProjectApiV1ProjectsProjectIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/projects/{project_id}"
        });
    }
    /**
   * Get Project
   * Get a project by ID.
   */ static getProjectApiV1ProjectsProjectIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects/{project_id}"
        });
    }
    /**
   * Update Existing Project
   * Update an existing project.
   */ static updateExistingProjectApiV1ProjectsProjectIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/projects/{project_id}"
        });
    }
    /**
   * Create Eval Dataset For Project
   * Create a new eval dataset for a project.
   */ static createEvalDatasetForProjectApiV1ProjectsProjectIdEvalDatasetPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/projects/{project_id}/eval/dataset"
        });
    }
    /**
   * List Datasets For Project
   * List eval datasets for a project.
   */ static listDatasetsForProjectApiV1ProjectsProjectIdEvalDatasetGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects/{project_id}/eval/dataset"
        });
    }
    /**
   * Create Local Eval Set For Project
   * Create a new local eval set.
   */ static createLocalEvalSetForProjectApiV1ProjectsProjectIdLocalevalsetPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/projects/{project_id}/localevalset"
        });
    }
    /**
   * List Local Evals For Project
   * List local eval results for a project.
   */ static listLocalEvalsForProjectApiV1ProjectsProjectIdLocalevalGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects/{project_id}/localeval"
        });
    }
    /**
   * List Local Eval Sets For Project
   * List local eval sets for a project.
   */ static listLocalEvalSetsForProjectApiV1ProjectsProjectIdLocalevalsetsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects/{project_id}/localevalsets"
        });
    }
    /**
   * Delete Local Eval Set
   * Delete a local eval set.
   */ static deleteLocalEvalSetApiV1ProjectsProjectIdLocalevalsetLocalEvalSetIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/projects/{project_id}/localevalset/{local_eval_set_id}"
        });
    }
    /**
   * Create Prompt Mixin Prompts
   * Create a new PromptMixin prompt set.
   */ static createPromptMixinPromptsApiV1ProjectsProjectIdPromptsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/projects/{project_id}/prompts"
        });
    }
    /**
   * List Promptmixin Prompts
   * List PromptMixin prompt sets for a project.
   */ static listPromptmixinPromptsApiV1ProjectsProjectIdPromptsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/projects/{project_id}/prompts"
        });
    }
    /**
   * Update Promptmixin Prompts
   * Update a PromptMixin prompt set.
   */ static updatePromptmixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/projects/{project_id}/prompts/{prompt_set_id}"
        });
    }
    /**
   * Delete Prompt Mixin Prompts
   * Delete a PromptMixin prompt set.
   */ static deletePromptMixinPromptsApiV1ProjectsProjectIdPromptsPromptSetIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/projects/{project_id}/prompts/{prompt_set_id}"
        });
    }
}
class FilesService {
    /**
   * Get File
   * Read File metadata objects.
   */ static getFileApiV1FilesIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/files/{id}"
        });
    }
    /**
   * Delete File
   * Delete the file from S3.
   */ static deleteFileApiV1FilesIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/files/{id}"
        });
    }
    /**
   * List Files
   * Read File metadata objects.
   */ static listFilesApiV1FilesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/files"
        });
    }
    /**
   * Generate Presigned Url
   * Create a presigned url for uploading a file.
   */ static generatePresignedUrlApiV1FilesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/files"
        });
    }
    /**
   * Upload File
   * Upload a file to S3.
   */ static uploadFileApiV1FilesPost(options) {
        return (options?.client ?? client).post({
            ...options,
            ...k,
            headers: {
                "Content-Type": null,
                ...options?.headers
            },
            url: "/api/v1/files"
        });
    }
    /**
   * Sync Files
   * Sync Files API against file contents uploaded via S3 presigned urls.
   */ static syncFilesApiV1FilesSyncPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/files/sync"
        });
    }
    /**
   * Read File Content
   * Returns a presigned url to read the file content.
   */ static readFileContentApiV1FilesIdContentGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/files/{id}/content"
        });
    }
    /**
   * List File Page Screenshots
   * List metadata for all screenshots of pages from a file.
   */ static listFilePageScreenshotsApiV1FilesIdPageScreenshotsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/files/{id}/page_screenshots"
        });
    }
    /**
   * Get File Page Screenshot
   * Get screenshot of a page from a file.
   */ static getFilePageScreenshotApiV1FilesIdPageScreenshotsPageIndexGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/files/{id}/page_screenshots/{page_index}"
        });
    }
}
class PipelinesService {
    /**
   * Search Pipelines
   * Search for pipelines by various parameters.
   */ static searchPipelinesApiV1PipelinesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines"
        });
    }
    /**
   * Create Pipeline
   * Create a new pipeline for a project.
   */ static createPipelineApiV1PipelinesPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines"
        });
    }
    /**
   * Upsert Pipeline
   * Upsert a pipeline for a project.
   * Updates if a pipeline with the same name and project_id already exists. Otherwise, creates a new pipeline.
   */ static upsertPipelineApiV1PipelinesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines"
        });
    }
    /**
   * Get Pipeline
   * Get a pipeline by ID for a given project.
   */ static getPipelineApiV1PipelinesPipelineIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}"
        });
    }
    /**
   * Update Existing Pipeline
   * Update an existing pipeline for a project.
   */ static updateExistingPipelineApiV1PipelinesPipelineIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}"
        });
    }
    /**
   * Delete Pipeline
   * Delete a pipeline by ID.
   */ static deletePipelineApiV1PipelinesPipelineIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}"
        });
    }
    /**
   * Get Pipeline Status
   * Get the status of a pipeline by ID.
   */ static getPipelineStatusApiV1PipelinesPipelineIdStatusGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/status"
        });
    }
    /**
   * Sync Pipeline
   * Run ingestion for the pipeline by incrementally updating the data-sink with upstream changes from data-sources & files.
   */ static syncPipelineApiV1PipelinesPipelineIdSyncPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/sync"
        });
    }
    /**
   * Copy Pipeline
   * Copy a pipeline by ID.
   */ static copyPipelineApiV1PipelinesPipelineIdCopyPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/copy"
        });
    }
    /**
   * Execute Eval Dataset
   * Execute a dataset.
   */ static executeEvalDatasetApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecutePost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute"
        });
    }
    /**
   * Get Eval Dataset Executions
   * Get the status of an EvalDatasetExecution.
   */ static getEvalDatasetExecutionsApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute"
        });
    }
    /**
   * Get Eval Dataset Execution Result
   * Get the result of an EvalDatasetExecution.
   * If eval_question_ids is specified, only the results for the specified
   * questions will be returned.
   * If any of the specified questions do not have a result, they will be ignored.
   */ static getEvalDatasetExecutionResultApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteResultGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/result"
        });
    }
    /**
   * Get Eval Dataset Execution
   * Get the status of an EvalDatasetExecution.
   */ static getEvalDatasetExecutionApiV1PipelinesPipelineIdEvalDatasetsEvalDatasetIdExecuteEvalDatasetExecutionIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/eval-datasets/{eval_dataset_id}/execute/{eval_dataset_execution_id}"
        });
    }
    /**
   * List Pipeline Files
   * Get files for a pipeline.
   */ static listPipelineFilesApiV1PipelinesPipelineIdFilesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/files"
        });
    }
    /**
   * Add Files To Pipeline
   * Add files to a pipeline.
   */ static addFilesToPipelineApiV1PipelinesPipelineIdFilesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/files"
        });
    }
    /**
   * Get Pipeline File Status
   * Get status of a file for a pipeline.
   */ static getPipelineFileStatusApiV1PipelinesPipelineIdFilesFileIdStatusGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}/status"
        });
    }
    /**
   * Update Pipeline File
   * Update a file for a pipeline.
   */ static updatePipelineFileApiV1PipelinesPipelineIdFilesFileIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}"
        });
    }
    /**
   * Delete Pipeline File
   * Delete a file from a pipeline.
   */ static deletePipelineFileApiV1PipelinesPipelineIdFilesFileIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/files/{file_id}"
        });
    }
    /**
   * Import Pipeline Metadata
   * Import metadata for a pipeline.
   */ static importPipelineMetadataApiV1PipelinesPipelineIdMetadataPut(options) {
        return (options?.client ?? client).put({
            ...options,
            ...k,
            headers: {
                "Content-Type": null,
                ...options?.headers
            },
            url: "/api/v1/pipelines/{pipeline_id}/metadata"
        });
    }
    /**
   * Delete Pipeline Files Metadata
   * Delete metadata for all files in a pipeline.
   */ static deletePipelineFilesMetadataApiV1PipelinesPipelineIdMetadataDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/metadata"
        });
    }
    /**
   * List Pipeline Data Sources
   * Get data sources for a pipeline.
   */ static listPipelineDataSourcesApiV1PipelinesPipelineIdDataSourcesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources"
        });
    }
    /**
   * Add Data Sources To Pipeline
   * Add data sources to a pipeline.
   */ static addDataSourcesToPipelineApiV1PipelinesPipelineIdDataSourcesPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources"
        });
    }
    /**
   * Update Pipeline Data Source
   * Update the configuration of a data source in a pipeline.
   */ static updatePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}"
        });
    }
    /**
   * Delete Pipeline Data Source
   * Delete a data source from a pipeline.
   */ static deletePipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}"
        });
    }
    /**
   * Sync Pipeline Data Source
   * Run ingestion for the pipeline data source by incrementally updating the data-sink with upstream changes from data-source.
   */ static syncPipelineDataSourceApiV1PipelinesPipelineIdDataSourcesDataSourceIdSyncPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/sync"
        });
    }
    /**
   * Get Pipeline Data Source Status
   * Get the status of a data source for a pipeline.
   */ static getPipelineDataSourceStatusApiV1PipelinesPipelineIdDataSourcesDataSourceIdStatusGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/data-sources/{data_source_id}/status"
        });
    }
    /**
   * Run Search
   * Get retrieval results for a managed pipeline and a query
   */ static runSearchApiV1PipelinesPipelineIdRetrievePost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/retrieve"
        });
    }
    /**
   * List Pipeline Jobs
   * Get jobs for a pipeline.
   */ static listPipelineJobsApiV1PipelinesPipelineIdJobsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/jobs"
        });
    }
    /**
   * Get Pipeline Job
   * Get a job for a pipeline.
   */ static getPipelineJobApiV1PipelinesPipelineIdJobsJobIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/jobs/{job_id}"
        });
    }
    /**
   * Get Playground Session
   * Get a playground session for a user and pipeline.
   */ static getPlaygroundSessionApiV1PipelinesPipelineIdPlaygroundSessionGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/playground-session"
        });
    }
    /**
   * Chat
   * Make a retrieval query + chat completion for a managed pipeline.
   */ static chatApiV1PipelinesPipelineIdChatPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/chat"
        });
    }
    /**
   * Create Batch Pipeline Documents
   * Batch create documents for a pipeline.
   */ static createBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents"
        });
    }
    /**
   * List Pipeline Documents
   * Return a list of documents for a pipeline.
   */ static listPipelineDocumentsApiV1PipelinesPipelineIdDocumentsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents"
        });
    }
    /**
   * Upsert Batch Pipeline Documents
   * Batch create or update a document for a pipeline.
   */ static upsertBatchPipelineDocumentsApiV1PipelinesPipelineIdDocumentsPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents"
        });
    }
    /**
   * Get Pipeline Document
   * Return a single document for a pipeline.
   */ static getPipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}"
        });
    }
    /**
   * Delete Pipeline Document
   * Delete a document for a pipeline.
   */ static deletePipelineDocumentApiV1PipelinesPipelineIdDocumentsDocumentIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}"
        });
    }
    /**
   * Get Pipeline Document Status
   * Return a single document for a pipeline.
   */ static getPipelineDocumentStatusApiV1PipelinesPipelineIdDocumentsDocumentIdStatusGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/status"
        });
    }
    /**
   * List Pipeline Document Chunks
   * Return a list of chunks for a pipeline document.
   */ static listPipelineDocumentChunksApiV1PipelinesPipelineIdDocumentsDocumentIdChunksGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/pipelines/{pipeline_id}/documents/{document_id}/chunks"
        });
    }
}
class EvalsService {
    /**
   * Get Dataset
   * Get a dataset by ID.
   */ static getDatasetApiV1EvalsDatasetsDatasetIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}"
        });
    }
    /**
   * Update Dataset
   * Update a dataset.
   */ static updateDatasetApiV1EvalsDatasetsDatasetIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}"
        });
    }
    /**
   * Delete Dataset
   * Delete a dataset.
   */ static deleteDatasetApiV1EvalsDatasetsDatasetIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}"
        });
    }
    /**
   * Create Question
   * Create a new question.
   */ static createQuestionApiV1EvalsDatasetsDatasetIdQuestionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}/question"
        });
    }
    /**
   * List Questions
   * List questions for a dataset.
   */ static listQuestionsApiV1EvalsDatasetsDatasetIdQuestionGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}/question"
        });
    }
    /**
   * Create Questions
   * Create a new question.
   */ static createQuestionsApiV1EvalsDatasetsDatasetIdQuestionsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/evals/datasets/{dataset_id}/questions"
        });
    }
    /**
   * Get Question
   * Get a question by ID.
   */ static getQuestionApiV1EvalsQuestionsQuestionIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/evals/questions/{question_id}"
        });
    }
    /**
   * Replace Question
   * Replace a question.
   */ static replaceQuestionApiV1EvalsQuestionsQuestionIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/evals/questions/{question_id}"
        });
    }
    /**
   * Delete Question
   * Delete a question.
   */ static deleteQuestionApiV1EvalsQuestionsQuestionIdDelete(options) {
        return (options?.client ?? client).delete({
            ...options,
            url: "/api/v1/evals/questions/{question_id}"
        });
    }
    /**
   * List Supported Models
   * List supported models.
   */ static listSupportedModelsApiV1EvalsModelsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/evals/models"
        });
    }
}
class ParsingService {
    /**
   * Get Job Image Result
   * Get a job by id
   */ static getJobImageResultApiV1ParsingJobJobIdResultImageNameGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/image/{name}"
        });
    }
    /**
   * Get Supported File Extensions
   * Get a list of supported file extensions
   */ static getSupportedFileExtensionsApiV1ParsingSupportedFileExtensionsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/supported_file_extensions"
        });
    }
    /**
   * Upload File
   * Upload a file to s3 and create a job. return a job id
   */ static uploadFileApiV1ParsingUploadPost(options) {
        return (options?.client ?? client).post({
            ...options,
            ...k,
            headers: {
                "Content-Type": null,
                ...options?.headers
            },
            url: "/api/v1/parsing/upload"
        });
    }
    /**
   * Usage
   * Get parsing usage for user
   */ static usageApiV1ParsingUsageGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/usage"
        });
    }
    /**
   * Get Job
   * Get a job by id
   */ static getJobApiV1ParsingJobJobIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}"
        });
    }
    /**
   * Get Parsing Job Details
   * Get a job by id
   */ static getParsingJobDetailsApiV1ParsingJobJobIdDetailsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/details"
        });
    }
    /**
   * Get Job Text Result
   * Get a job by id
   */ static getJobTextResultApiV1ParsingJobJobIdResultTextGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/text"
        });
    }
    /**
   * Get Job Raw Text Result
   * Get a job by id
   */ static getJobRawTextResultApiV1ParsingJobJobIdResultRawTextGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/raw/text"
        });
    }
    /**
   * Get Job Result
   * Get a job by id
   */ static getJobResultApiV1ParsingJobJobIdResultMarkdownGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/markdown"
        });
    }
    /**
   * Get Job Raw Md Result
   * Get a job by id
   */ static getJobRawMdResultApiV1ParsingJobJobIdResultRawMarkdownGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/raw/markdown"
        });
    }
    /**
   * Get Job Json Result
   * Get a job by id
   */ static getJobJsonResultApiV1ParsingJobJobIdResultJsonGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/json"
        });
    }
    /**
   * Get Job Json Raw Result
   * Get a job by id
   */ static getJobJsonRawResultApiV1ParsingJobJobIdResultRawJsonGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/result/raw/json"
        });
    }
    /**
   * Get Parsing History Result
   * Get parsing history for user
   */ static getParsingHistoryResultApiV1ParsingHistoryGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/history"
        });
    }
    /**
   * Generate Presigned Url
   * Generate a presigned URL for a job
   */ static generatePresignedUrlApiV1ParsingJobJobIdReadFilenameGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/parsing/job/{job_id}/read/{filename}"
        });
    }
}
class ComponentDefinitionsService {
    /**
   * List Transformation Definitions
   * List transformation component definitions.
   */ static listTransformationDefinitionsApiV1ComponentDefinitionConfigurableTransformationsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/component-definition/configurable-transformations"
        });
    }
    /**
   * List Data Source Definitions
   * List data source component definitions.
   */ static listDataSourceDefinitionsApiV1ComponentDefinitionDataSourcesGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/component-definition/data-sources"
        });
    }
    /**
   * List Data Sink Definitions
   * List data sink component definitions.
   */ static listDataSinkDefinitionsApiV1ComponentDefinitionDataSinksGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/component-definition/data-sinks"
        });
    }
}
class BillingService {
    /**
   * Create Checkout Session
   * Create a new checkout session.
   */ static createCheckoutSessionApiV1BillingCheckoutSessionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/billing/checkout-session"
        });
    }
    /**
   * Create Customer Portal Session
   * Create a new customer portal session.
   */ static createCustomerPortalSessionApiV1BillingCustomerPortalSessionPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/billing/customer-portal-session"
        });
    }
    /**
   * Stripe Webhook
   * Stripe webhook endpoint.
   */ static stripeWebhookApiV1BillingWebhookPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/billing/webhook"
        });
    }
}
class ExtractionService {
    /**
   * Create Schema
   */ static createSchemaApiV1ExtractionSchemasPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/extraction/schemas"
        });
    }
    /**
   * List Schemas
   */ static listSchemasApiV1ExtractionSchemasGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/extraction/schemas"
        });
    }
    /**
   * Infer Schema
   */ static inferSchemaApiV1ExtractionSchemasInferPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/extraction/schemas/infer"
        });
    }
    /**
   * Get Schema
   */ static getSchemaApiV1ExtractionSchemasSchemaIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/extraction/schemas/{schema_id}"
        });
    }
    /**
   * Update Schema
   */ static updateSchemaApiV1ExtractionSchemasSchemaIdPut(options) {
        return (options?.client ?? client).put({
            ...options,
            url: "/api/v1/extraction/schemas/{schema_id}"
        });
    }
    /**
   * List Jobs
   */ static listJobsApiV1ExtractionJobsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/extraction/jobs"
        });
    }
    /**
   * Run Job
   */ static runJobApiV1ExtractionJobsPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/extraction/jobs"
        });
    }
    /**
   * Get Job
   */ static getJobApiV1ExtractionJobsJobIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/extraction/jobs/{job_id}"
        });
    }
    /**
   * Run Jobs In Batch
   */ static runJobsInBatchApiV1ExtractionJobsBatchPost(options) {
        return (options?.client ?? client).post({
            ...options,
            url: "/api/v1/extraction/jobs/batch"
        });
    }
    /**
   * Get Job Result
   */ static getJobResultApiV1ExtractionJobsJobIdResultGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/v1/extraction/jobs/{job_id}/result"
        });
    }
}
class DeprecatedService {
    /**
   * Get Job Image Result
   * Get a job by id
   */ static getJobImageResultApiParsingJobJobIdResultImageNameGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/image/{name}"
        });
    }
    /**
   * Get Supported File Extensions
   * Get a list of supported file extensions
   */ static getSupportedFileExtensionsApiParsingSupportedFileExtensionsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/supported_file_extensions"
        });
    }
    /**
   * Upload File
   * Upload a file to s3 and create a job. return a job id
   */ static uploadFileApiParsingUploadPost(options) {
        return (options?.client ?? client).post({
            ...options,
            ...k,
            headers: {
                "Content-Type": null,
                ...options?.headers
            },
            url: "/api/parsing/upload"
        });
    }
    /**
   * Usage
   * Get parsing usage for user
   */ static usageApiParsingUsageGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/usage"
        });
    }
    /**
   * Get Job
   * Get a job by id
   */ static getJobApiParsingJobJobIdGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}"
        });
    }
    /**
   * Get Parsing Job Details
   * Get a job by id
   */ static getParsingJobDetailsApiParsingJobJobIdDetailsGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/details"
        });
    }
    /**
   * Get Job Text Result
   * Get a job by id
   */ static getJobTextResultApiParsingJobJobIdResultTextGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/text"
        });
    }
    /**
   * Get Job Raw Text Result
   * Get a job by id
   */ static getJobRawTextResultApiParsingJobJobIdResultRawTextGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/raw/text"
        });
    }
    /**
   * Get Job Result
   * Get a job by id
   */ static getJobResultApiParsingJobJobIdResultMarkdownGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/markdown"
        });
    }
    /**
   * Get Job Raw Md Result
   * Get a job by id
   */ static getJobRawMdResultApiParsingJobJobIdResultRawMarkdownGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/raw/markdown"
        });
    }
    /**
   * Get Job Json Result
   * Get a job by id
   */ static getJobJsonResultApiParsingJobJobIdResultJsonGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/json"
        });
    }
    /**
   * Get Job Json Raw Result
   * Get a job by id
   */ static getJobJsonRawResultApiParsingJobJobIdResultRawJsonGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/result/raw/json"
        });
    }
    /**
   * Get Parsing History Result
   * Get parsing history for user
   */ static getParsingHistoryResultApiParsingHistoryGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/history"
        });
    }
    /**
   * Generate Presigned Url
   * Generate a presigned URL for a job
   */ static generatePresignedUrlApiParsingJobJobIdReadFilenameGet(options) {
        return (options?.client ?? client).get({
            ...options,
            url: "/api/parsing/job/{job_id}/read/{filename}"
        });
    }
}

// This file is auto-generated by @hey-api/openapi-ts
/**
 * Schema for an API Key.
 */ const mode = {
    ADVANCED: "advanced"
};
const mode2 = {
    AUTO: "auto"
};
/**
 * Type of the embedding model.
 */ const type = {
    AZURE_EMBEDDING: "AZURE_EMBEDDING"
};
/**
 * Type of the embedding model.
 */ const type2 = {
    BEDROCK_EMBEDDING: "BEDROCK_EMBEDDING"
};
const BoxAuthMechanism = {
    DEVELOPER_TOKEN: "developer_token",
    CCG: "ccg"
};
const mode3 = {
    CHARACTER: "character"
};
/**
 * Type of the embedding model.
 */ const type3 = {
    COHERE_EMBEDDING: "COHERE_EMBEDDING"
};
const ConfigurableDataSinkNames = {
    PINECONE: "PINECONE",
    POSTGRES: "POSTGRES",
    QDRANT: "QDRANT",
    AZUREAI_SEARCH: "AZUREAI_SEARCH",
    MONGODB_ATLAS: "MONGODB_ATLAS",
    MILVUS: "MILVUS"
};
const ConfigurableDataSourceNames = {
    S3: "S3",
    AZURE_STORAGE_BLOB: "AZURE_STORAGE_BLOB",
    GOOGLE_DRIVE: "GOOGLE_DRIVE",
    MICROSOFT_ONEDRIVE: "MICROSOFT_ONEDRIVE",
    MICROSOFT_SHAREPOINT: "MICROSOFT_SHAREPOINT",
    SLACK: "SLACK",
    NOTION_PAGE: "NOTION_PAGE",
    CONFLUENCE: "CONFLUENCE",
    JIRA: "JIRA",
    BOX: "BOX"
};
const ConfigurableTransformationNames = {
    CHARACTER_SPLITTER: "CHARACTER_SPLITTER",
    PAGE_SPLITTER_NODE_PARSER: "PAGE_SPLITTER_NODE_PARSER",
    CODE_NODE_PARSER: "CODE_NODE_PARSER",
    SENTENCE_AWARE_NODE_PARSER: "SENTENCE_AWARE_NODE_PARSER",
    TOKEN_AWARE_NODE_PARSER: "TOKEN_AWARE_NODE_PARSER",
    MARKDOWN_NODE_PARSER: "MARKDOWN_NODE_PARSER",
    MARKDOWN_ELEMENT_NODE_PARSER: "MARKDOWN_ELEMENT_NODE_PARSER"
};
const mode4 = {
    ELEMENT: "element"
};
const job_name = {
    EVAL_DATASET_JOB: "eval_dataset_job"
};
const EvalMetric = {
    RELEVANCY: "RELEVANCY",
    FAITHFULNESS: "FAITHFULNESS"
};
/**
 * Vector store filter conditions to combine different filters.
 */ const FilterCondition = {
    AND: "and",
    OR: "or"
};
/**
 * Vector store filter operator.
 */ const FilterOperator = {
    __: "<=",
    _: "<",
    IN: "in",
    NIN: "nin",
    ANY: "any",
    ALL: "all",
    TEXT_MATCH: "text_match",
    CONTAINS: "contains",
    IS_EMPTY: "is_empty"
};
/**
 * Type of the embedding model.
 */ const type4 = {
    GEMINI_EMBEDDING: "GEMINI_EMBEDDING"
};
/**
 * Type of the embedding model.
 */ const type5 = {
    HUGGINGFACE_API_EMBEDDING: "HUGGINGFACE_API_EMBEDDING"
};
/**
 * Enum for mapping original job names to readable names.
 */ const JobNameMapping = {
    MANAGED_INGESTION: "MANAGED_INGESTION",
    DATA_SOURCE: "DATA_SOURCE",
    FILES_UPDATE: "FILES_UPDATE",
    FILE_UPDATER: "FILE_UPDATER",
    PARSE: "PARSE",
    TRANSFORM: "TRANSFORM",
    INGESTION: "INGESTION"
};
const LlamaParseSupportedFileExtensions = {
    _PDF: ".pdf",
    _DOC: ".doc",
    _DOCX: ".docx",
    _DOCM: ".docm",
    _DOT: ".dot",
    _DOTX: ".dotx",
    _DOTM: ".dotm",
    _RTF: ".rtf",
    _WPS: ".wps",
    _WPD: ".wpd",
    _SXW: ".sxw",
    _STW: ".stw",
    _SXG: ".sxg",
    _PAGES: ".pages",
    _MW: ".mw",
    _MCW: ".mcw",
    _UOT: ".uot",
    _UOF: ".uof",
    _UOS: ".uos",
    _UOP: ".uop",
    _PPT: ".ppt",
    _PPTX: ".pptx",
    _POT: ".pot",
    _PPTM: ".pptm",
    _POTX: ".potx",
    _POTM: ".potm",
    _KEY: ".key",
    _ODP: ".odp",
    _ODG: ".odg",
    _OTP: ".otp",
    _FOPD: ".fopd",
    _SXI: ".sxi",
    _STI: ".sti",
    _EPUB: ".epub",
    _JPG: ".jpg",
    _JPEG: ".jpeg",
    _PNG: ".png",
    _GIF: ".gif",
    _BMP: ".bmp",
    _SVG: ".svg",
    _TIFF: ".tiff",
    _WEBP: ".webp",
    _HTML: ".html",
    _HTM: ".htm",
    _XLS: ".xls",
    _XLSX: ".xlsx",
    _XLSM: ".xlsm",
    _XLSB: ".xlsb",
    _XLW: ".xlw",
    _CSV: ".csv",
    _DIF: ".dif",
    _SYLK: ".sylk",
    _SLK: ".slk",
    _PRN: ".prn",
    _NUMBERS: ".numbers",
    _ET: ".et",
    _ODS: ".ods",
    _FODS: ".fods",
    _UOS1: ".uos1",
    _UOS2: ".uos2",
    _DBF: ".dbf",
    _WK1: ".wk1",
    _WK2: ".wk2",
    _WK3: ".wk3",
    _WK4: ".wk4",
    _WKS: ".wks",
    _WQ1: ".wq1",
    _WQ2: ".wq2",
    _WB1: ".wb1",
    _WB2: ".wb2",
    _WB3: ".wb3",
    _QPW: ".qpw",
    _XLR: ".xlr",
    _ETH: ".eth",
    _TSV: ".tsv"
};
/**
 * Status of managed ingestion with partial Updates.
 */ const ManagedIngestionStatus = {
    NOT_STARTED: "NOT_STARTED",
    IN_PROGRESS: "IN_PROGRESS",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS"
};
/**
 * Message role.
 */ const MessageRole = {
    SYSTEM: "system",
    USER: "user",
    ASSISTANT: "assistant",
    FUNCTION: "function",
    TOOL: "tool",
    CHATBOT: "chatbot",
    MODEL: "model"
};
/**
 * Node relationships used in `BaseNode` class.
 *
 * Attributes:
 * SOURCE: The node is the source document.
 * PREVIOUS: The node is the previous node in the document.
 * NEXT: The node is the next node in the document.
 * PARENT: The node is the parent node in the document.
 * CHILD: The node is a child node in the document.
 */ const NodeRelationship = {
    _1: "1",
    _2: "2",
    _3: "3",
    _4: "4",
    _5: "5"
};
const mode5 = {
    NONE: "none"
};
const ObjectType = {
    _1: "1",
    _2: "2",
    _3: "3",
    _4: "4"
};
/**
 * Type of the embedding model.
 */ const type6 = {
    OPENAI_EMBEDDING: "OPENAI_EMBEDDING"
};
const mode6 = {
    PAGE: "page"
};
/**
 * Enum for representing the languages supported by the parser
 */ const ParserLanguages = {
    AF: "af",
    AZ: "az",
    BS: "bs",
    CS: "cs",
    CY: "cy",
    DA: "da",
    DE: "de",
    EN: "en",
    ES: "es",
    ET: "et",
    FR: "fr",
    GA: "ga",
    HR: "hr",
    HU: "hu",
    ID: "id",
    IS: "is",
    IT: "it",
    KU: "ku",
    LA: "la",
    LT: "lt",
    LV: "lv",
    MI: "mi",
    MS: "ms",
    MT: "mt",
    NL: "nl",
    NO: "no",
    OC: "oc",
    PI: "pi",
    PL: "pl",
    PT: "pt",
    RO: "ro",
    RS_LATIN: "rs_latin",
    SK: "sk",
    SL: "sl",
    SQ: "sq",
    SV: "sv",
    SW: "sw",
    TL: "tl",
    TR: "tr",
    UZ: "uz",
    VI: "vi",
    AR: "ar",
    FA: "fa",
    UG: "ug",
    UR: "ur",
    BN: "bn",
    AS: "as",
    MNI: "mni",
    RU: "ru",
    RS_CYRILLIC: "rs_cyrillic",
    BE: "be",
    BG: "bg",
    UK: "uk",
    MN: "mn",
    ABQ: "abq",
    ADY: "ady",
    KBD: "kbd",
    AVA: "ava",
    DAR: "dar",
    INH: "inh",
    CHE: "che",
    LBE: "lbe",
    LEZ: "lez",
    TAB: "tab",
    TJK: "tjk",
    HI: "hi",
    MR: "mr",
    NE: "ne",
    BH: "bh",
    MAI: "mai",
    ANG: "ang",
    BHO: "bho",
    MAH: "mah",
    SCK: "sck",
    NEW: "new",
    GOM: "gom",
    SA: "sa",
    BGC: "bgc",
    TH: "th",
    CH_SIM: "ch_sim",
    CH_TRA: "ch_tra",
    JA: "ja",
    KO: "ko",
    TA: "ta",
    TE: "te",
    KN: "kn"
};
/**
 * Enum for dataset partition names.
 */ const PartitionNames = {
    DATA_SOURCE_ID_PARTITION: "data_source_id_partition",
    PIPELINE_ID_PARTITION: "pipeline_id_partition",
    EVAL_DATASET_ID_PARTITION: "eval_dataset_id_partition",
    FILE_ID_PARTITION: "file_id_partition",
    PIPELINE_FILE_ID_PARTITION: "pipeline_file_id_partition",
    FILE_PARSING_ID_PARTITION: "file_parsing_id_partition",
    EXTRACTION_SCHEMA_ID_PARTITION: "extraction_schema_id_partition"
};
/**
 * Enum for representing the type of a pipeline
 */ const PipelineType = {
    PLAYGROUND: "PLAYGROUND",
    MANAGED: "MANAGED"
};
/**
 * Enum of possible pooling choices with pooling behaviors.
 */ const Pooling = {
    CLS: "cls",
    MEAN: "mean",
    LAST: "last"
};
/**
 * Pydantic program mode.
 */ const PydanticProgramMode = {
    DEFAULT: "default",
    OPENAI: "openai",
    LLM: "llm",
    FUNCTION: "function",
    GUIDANCE: "guidance",
    LM_FORMAT_ENFORCER: "lm-format-enforcer"
};
const RetrievalMode = {
    CHUNKS: "chunks",
    FILES_VIA_METADATA: "files_via_metadata",
    FILES_VIA_CONTENT: "files_via_content",
    AUTO_ROUTED: "auto_routed"
};
const mode7 = {
    SEMANTIC: "semantic"
};
const mode8 = {
    SENTENCE: "sentence"
};
/**
 * Enum for representing the status of a job
 */ const StatusEnum = {
    PENDING: "PENDING",
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    PARTIAL_SUCCESS: "PARTIAL_SUCCESS"
};
const SupportedLLMModelNames = {
    GPT_3_5_TURBO: "GPT_3_5_TURBO",
    GPT_4: "GPT_4",
    GPT_4_TURBO: "GPT_4_TURBO",
    GPT_4O: "GPT_4O",
    GPT_4O_MINI: "GPT_4O_MINI",
    AZURE_OPENAI: "AZURE_OPENAI"
};
const mode9 = {
    TOKEN: "token"
};
const TransformationCategoryNames = {
    NODE_PARSER: "NODE_PARSER",
    EMBEDDING: "EMBEDDING"
};
/**
 * Type of the embedding model.
 */ const type7 = {
    VERTEXAI_EMBEDDING: "VERTEXAI_EMBEDDING"
};
/**
 * Copied from llama_index.embeddings.vertex.base.VertexEmbeddingMode
 * since importing llama_index.embeddings.vertex.base incurs a lot of memory usage.
 */ const VertexEmbeddingMode = {
    DEFAULT: "default",
    CLASSIFICATION: "classification",
    CLUSTERING: "clustering",
    SIMILARITY: "similarity",
    RETRIEVAL: "retrieval"
};

exports.APIKeyCreateSchema = APIKeyCreateSchema;
exports.APIKeySchema = APIKeySchema;
exports.APIKeyUpdateSchema = APIKeyUpdateSchema;
exports.AdvancedModeTransformConfigSchema = AdvancedModeTransformConfigSchema;
exports.ApiKeysService = ApiKeysService;
exports.AutoTransformConfigSchema = AutoTransformConfigSchema;
exports.AzureOpenAIEmbeddingConfigSchema = AzureOpenAIEmbeddingConfigSchema;
exports.AzureOpenAIEmbeddingSchema = AzureOpenAIEmbeddingSchema;
exports.BaseConnectionValidationSchema = BaseConnectionValidationSchema;
exports.BasePromptTemplateSchema = BasePromptTemplateSchema;
exports.BaseSchema = BaseSchema;
exports.BedrockEmbeddingConfigSchema = BedrockEmbeddingConfigSchema;
exports.BedrockEmbeddingSchema = BedrockEmbeddingSchema;
exports.BillingService = BillingService;
exports.Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema = Body_import_pipeline_metadata_api_v1_pipelines__pipeline_id__metadata_putSchema;
exports.Body_upload_file_api_parsing_upload_postSchema = Body_upload_file_api_parsing_upload_postSchema;
exports.Body_upload_file_api_v1_files_postSchema = Body_upload_file_api_v1_files_postSchema;
exports.Body_upload_file_api_v1_parsing_upload_postSchema = Body_upload_file_api_v1_parsing_upload_postSchema;
exports.BoxAuthMechanism = BoxAuthMechanism;
exports.BoxAuthMechanismSchema = BoxAuthMechanismSchema;
exports.CharacterChunkingConfigSchema = CharacterChunkingConfigSchema;
exports.CharacterSplitterSchema = CharacterSplitterSchema;
exports.ChatDataSchema = ChatDataSchema;
exports.ChatInputParamsSchema = ChatInputParamsSchema;
exports.ChatMessageSchema = ChatMessageSchema;
exports.CheckoutSessionCreatePayloadSchema = CheckoutSessionCreatePayloadSchema;
exports.CloudAzStorageBlobDataSourceSchema = CloudAzStorageBlobDataSourceSchema;
exports.CloudAzureAISearchVectorStoreSchema = CloudAzureAISearchVectorStoreSchema;
exports.CloudBoxDataSourceSchema = CloudBoxDataSourceSchema;
exports.CloudConfluenceDataSourceSchema = CloudConfluenceDataSourceSchema;
exports.CloudDocumentCreateSchema = CloudDocumentCreateSchema;
exports.CloudDocumentSchema = CloudDocumentSchema;
exports.CloudGoogleDriveDataSourceSchema = CloudGoogleDriveDataSourceSchema;
exports.CloudJiraDataSourceSchema = CloudJiraDataSourceSchema;
exports.CloudMilvusVectorStoreSchema = CloudMilvusVectorStoreSchema;
exports.CloudMongoDBAtlasVectorSearchSchema = CloudMongoDBAtlasVectorSearchSchema;
exports.CloudNotionPageDataSourceSchema = CloudNotionPageDataSourceSchema;
exports.CloudOneDriveDataSourceSchema = CloudOneDriveDataSourceSchema;
exports.CloudPineconeVectorStoreSchema = CloudPineconeVectorStoreSchema;
exports.CloudPostgresVectorStoreSchema = CloudPostgresVectorStoreSchema;
exports.CloudQdrantVectorStoreSchema = CloudQdrantVectorStoreSchema;
exports.CloudS3DataSourceSchema = CloudS3DataSourceSchema;
exports.CloudSharepointDataSourceSchema = CloudSharepointDataSourceSchema;
exports.CloudSlackDataSourceSchema = CloudSlackDataSourceSchema;
exports.CodeSplitterSchema = CodeSplitterSchema;
exports.CohereEmbeddingConfigSchema = CohereEmbeddingConfigSchema;
exports.CohereEmbeddingSchema = CohereEmbeddingSchema;
exports.ComponentDefinitionsService = ComponentDefinitionsService;
exports.ConfigurableDataSinkNames = ConfigurableDataSinkNames;
exports.ConfigurableDataSinkNamesSchema = ConfigurableDataSinkNamesSchema;
exports.ConfigurableDataSourceNames = ConfigurableDataSourceNames;
exports.ConfigurableDataSourceNamesSchema = ConfigurableDataSourceNamesSchema;
exports.ConfigurableTransformationDefinitionSchema = ConfigurableTransformationDefinitionSchema;
exports.ConfigurableTransformationNames = ConfigurableTransformationNames;
exports.ConfigurableTransformationNamesSchema = ConfigurableTransformationNamesSchema;
exports.ConfiguredTransformationItemSchema = ConfiguredTransformationItemSchema;
exports.CustomerPortalSessionCreatePayloadSchema = CustomerPortalSessionCreatePayloadSchema;
exports.DataSinkCreateSchema = DataSinkCreateSchema;
exports.DataSinkDefinitionSchema = DataSinkDefinitionSchema;
exports.DataSinkSchema = DataSinkSchema;
exports.DataSinkUpdateSchema = DataSinkUpdateSchema;
exports.DataSinksService = DataSinksService;
exports.DataSourceCreateSchema = DataSourceCreateSchema;
exports.DataSourceDefinitionSchema = DataSourceDefinitionSchema;
exports.DataSourceSchema = DataSourceSchema;
exports.DataSourceUpdateSchema = DataSourceUpdateSchema;
exports.DataSourcesService = DataSourcesService;
exports.DefaultOrganizationUpdateSchema = DefaultOrganizationUpdateSchema;
exports.DeprecatedService = DeprecatedService;
exports.ElementSegmentationConfigSchema = ElementSegmentationConfigSchema;
exports.EvalDatasetCreateSchema = EvalDatasetCreateSchema;
exports.EvalDatasetJobParamsSchema = EvalDatasetJobParamsSchema;
exports.EvalDatasetJobRecordSchema = EvalDatasetJobRecordSchema;
exports.EvalDatasetSchema = EvalDatasetSchema;
exports.EvalDatasetUpdateSchema = EvalDatasetUpdateSchema;
exports.EvalExecutionCreateSchema = EvalExecutionCreateSchema;
exports.EvalExecutionParamsOverrideSchema = EvalExecutionParamsOverrideSchema;
exports.EvalExecutionParamsSchema = EvalExecutionParamsSchema;
exports.EvalMetric = EvalMetric;
exports.EvalMetricSchema = EvalMetricSchema;
exports.EvalQuestionCreateSchema = EvalQuestionCreateSchema;
exports.EvalQuestionResultSchema = EvalQuestionResultSchema;
exports.EvalQuestionSchema = EvalQuestionSchema;
exports.EvalsService = EvalsService;
exports.ExtractionJobCreateBatchSchema = ExtractionJobCreateBatchSchema;
exports.ExtractionJobCreateSchema = ExtractionJobCreateSchema;
exports.ExtractionJobSchema = ExtractionJobSchema;
exports.ExtractionResultSchema = ExtractionResultSchema;
exports.ExtractionSchemaCreateSchema = ExtractionSchemaCreateSchema;
exports.ExtractionSchemaInferSchema = ExtractionSchemaInferSchema;
exports.ExtractionSchemaSchema = ExtractionSchemaSchema;
exports.ExtractionSchemaUpdateSchema = ExtractionSchemaUpdateSchema;
exports.ExtractionService = ExtractionService;
exports.FileCreateSchema = FileCreateSchema;
exports.FileSchema = FileSchema;
exports.FilesService = FilesService;
exports.FilterCondition = FilterCondition;
exports.FilterConditionSchema = FilterConditionSchema;
exports.FilterOperator = FilterOperator;
exports.FilterOperatorSchema = FilterOperatorSchema;
exports.GeminiEmbeddingConfigSchema = GeminiEmbeddingConfigSchema;
exports.GeminiEmbeddingSchema = GeminiEmbeddingSchema;
exports.HTTPValidationErrorSchema = HTTPValidationErrorSchema;
exports.HuggingFaceInferenceAPIEmbeddingConfigSchema = HuggingFaceInferenceAPIEmbeddingConfigSchema;
exports.HuggingFaceInferenceAPIEmbeddingSchema = HuggingFaceInferenceAPIEmbeddingSchema;
exports.IngestionErrorResponseSchema = IngestionErrorResponseSchema;
exports.InputMessageSchema = InputMessageSchema;
exports.JobNameMapping = JobNameMapping;
exports.JobNameMappingSchema = JobNameMappingSchema;
exports.LLMModelDataSchema = LLMModelDataSchema;
exports.LLMParametersSchema = LLMParametersSchema;
exports.LLMSchema = LLMSchema;
exports.LlamaParseParametersSchema = LlamaParseParametersSchema;
exports.LlamaParseSupportedFileExtensions = LlamaParseSupportedFileExtensions;
exports.LlamaParseSupportedFileExtensionsSchema = LlamaParseSupportedFileExtensionsSchema;
exports.LocalEvalResultsSchema = LocalEvalResultsSchema;
exports.LocalEvalSchema = LocalEvalSchema;
exports.LocalEvalSetCreateSchema = LocalEvalSetCreateSchema;
exports.LocalEvalSetsSchema = LocalEvalSetsSchema;
exports.ManagedIngestionStatus = ManagedIngestionStatus;
exports.ManagedIngestionStatusResponseSchema = ManagedIngestionStatusResponseSchema;
exports.ManagedIngestionStatusSchema = ManagedIngestionStatusSchema;
exports.MarkdownElementNodeParserSchema = MarkdownElementNodeParserSchema;
exports.MarkdownNodeParserSchema = MarkdownNodeParserSchema;
exports.MessageAnnotationSchema = MessageAnnotationSchema;
exports.MessageRole = MessageRole;
exports.MessageRoleSchema = MessageRoleSchema;
exports.MetadataFilterSchema = MetadataFilterSchema;
exports.MetadataFiltersSchema = MetadataFiltersSchema;
exports.MetricResultSchema = MetricResultSchema;
exports.NodeParserSchema = NodeParserSchema;
exports.NodeRelationship = NodeRelationship;
exports.NodeRelationshipSchema = NodeRelationshipSchema;
exports.NoneChunkingConfigSchema = NoneChunkingConfigSchema;
exports.NoneSegmentationConfigSchema = NoneSegmentationConfigSchema;
exports.ObjectType = ObjectType;
exports.ObjectTypeSchema = ObjectTypeSchema;
exports.OpenAIEmbeddingConfigSchema = OpenAIEmbeddingConfigSchema;
exports.OpenAIEmbeddingSchema = OpenAIEmbeddingSchema;
exports.OrganizationCreateSchema = OrganizationCreateSchema;
exports.OrganizationSchema = OrganizationSchema;
exports.OrganizationUpdateSchema = OrganizationUpdateSchema;
exports.OrganizationsService = OrganizationsService;
exports.PageScreenshotMetadataSchema = PageScreenshotMetadataSchema;
exports.PageScreenshotNodeWithScoreSchema = PageScreenshotNodeWithScoreSchema;
exports.PageSegmentationConfigSchema = PageSegmentationConfigSchema;
exports.PageSplitterNodeParserSchema = PageSplitterNodeParserSchema;
exports.ParserLanguages = ParserLanguages;
exports.ParserLanguagesSchema = ParserLanguagesSchema;
exports.ParsingHistoryItemSchema = ParsingHistoryItemSchema;
exports.ParsingJobJsonResultSchema = ParsingJobJsonResultSchema;
exports.ParsingJobMarkdownResultSchema = ParsingJobMarkdownResultSchema;
exports.ParsingJobSchema = ParsingJobSchema;
exports.ParsingJobTextResultSchema = ParsingJobTextResultSchema;
exports.ParsingService = ParsingService;
exports.ParsingUsageSchema = ParsingUsageSchema;
exports.PartitionNames = PartitionNames;
exports.PartitionNamesSchema = PartitionNamesSchema;
exports.PermissionSchema = PermissionSchema;
exports.PipelineConfigurationHashesSchema = PipelineConfigurationHashesSchema;
exports.PipelineCreateSchema = PipelineCreateSchema;
exports.PipelineDataSourceCreateSchema = PipelineDataSourceCreateSchema;
exports.PipelineDataSourceSchema = PipelineDataSourceSchema;
exports.PipelineDataSourceUpdateSchema = PipelineDataSourceUpdateSchema;
exports.PipelineDeploymentSchema = PipelineDeploymentSchema;
exports.PipelineFileCreateSchema = PipelineFileCreateSchema;
exports.PipelineFileSchema = PipelineFileSchema;
exports.PipelineFileUpdateSchema = PipelineFileUpdateSchema;
exports.PipelineSchema = PipelineSchema;
exports.PipelineType = PipelineType;
exports.PipelineTypeSchema = PipelineTypeSchema;
exports.PipelineUpdateSchema = PipelineUpdateSchema;
exports.PipelinesService = PipelinesService;
exports.PlaygroundSessionSchema = PlaygroundSessionSchema;
exports.Pooling = Pooling;
exports.PoolingSchema = PoolingSchema;
exports.PresetRetrievalParamsSchema = PresetRetrievalParamsSchema;
exports.PresignedUrlSchema = PresignedUrlSchema;
exports.ProjectCreateSchema = ProjectCreateSchema;
exports.ProjectSchema = ProjectSchema;
exports.ProjectUpdateSchema = ProjectUpdateSchema;
exports.ProjectsService = ProjectsService;
exports.PromptMixinPromptsSchema = PromptMixinPromptsSchema;
exports.PromptSpecSchema = PromptSpecSchema;
exports.PydanticProgramMode = PydanticProgramMode;
exports.PydanticProgramModeSchema = PydanticProgramModeSchema;
exports.RelatedNodeInfoSchema = RelatedNodeInfoSchema;
exports.RetrievalMode = RetrievalMode;
exports.RetrievalModeSchema = RetrievalModeSchema;
exports.RetrievalParamsSchema = RetrievalParamsSchema;
exports.RetrieveResultsSchema = RetrieveResultsSchema;
exports.RoleSchema = RoleSchema;
exports.SemanticChunkingConfigSchema = SemanticChunkingConfigSchema;
exports.SentenceChunkingConfigSchema = SentenceChunkingConfigSchema;
exports.SentenceSplitterSchema = SentenceSplitterSchema;
exports.StatusEnum = StatusEnum;
exports.StatusEnumSchema = StatusEnumSchema;
exports.SupportedLLMModelNames = SupportedLLMModelNames;
exports.SupportedLLMModelNamesSchema = SupportedLLMModelNamesSchema;
exports.SupportedLLMModelSchema = SupportedLLMModelSchema;
exports.TextNodeSchema = TextNodeSchema;
exports.TextNodeWithScoreSchema = TextNodeWithScoreSchema;
exports.TokenChunkingConfigSchema = TokenChunkingConfigSchema;
exports.TokenTextSplitterSchema = TokenTextSplitterSchema;
exports.TransformationCategoryNames = TransformationCategoryNames;
exports.TransformationCategoryNamesSchema = TransformationCategoryNamesSchema;
exports.UserOrganizationCreateSchema = UserOrganizationCreateSchema;
exports.UserOrganizationDeleteSchema = UserOrganizationDeleteSchema;
exports.UserOrganizationRoleCreateSchema = UserOrganizationRoleCreateSchema;
exports.UserOrganizationRoleSchema = UserOrganizationRoleSchema;
exports.UserOrganizationSchema = UserOrganizationSchema;
exports.ValidationErrorSchema = ValidationErrorSchema;
exports.ValidationService = ValidationService;
exports.VertexAIEmbeddingConfigSchema = VertexAIEmbeddingConfigSchema;
exports.VertexEmbeddingMode = VertexEmbeddingMode;
exports.VertexEmbeddingModeSchema = VertexEmbeddingModeSchema;
exports.VertexTextEmbeddingSchema = VertexTextEmbeddingSchema;
exports.client = client;
exports.job_name = job_name;
exports.mode = mode;
exports.mode2 = mode2;
exports.mode3 = mode3;
exports.mode4 = mode4;
exports.mode5 = mode5;
exports.mode6 = mode6;
exports.mode7 = mode7;
exports.mode8 = mode8;
exports.mode9 = mode9;
exports.type = type;
exports.type2 = type2;
exports.type3 = type3;
exports.type4 = type4;
exports.type5 = type5;
exports.type6 = type6;
exports.type7 = type7;
