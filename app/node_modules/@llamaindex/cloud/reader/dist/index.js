import { FileReader, Document } from '@llamaindex/core/schema';
import { getEnv, fs, path } from '@llamaindex/env';
import { ParsingService } from '../../api/dist/index.js';

var T = /\{[^{}]+\}/g, h = ({ allowReserved: n, name: i, value: e })=>{
    if (e == null) return "";
    if (typeof e == "object") throw new Error("Deeply-nested arrays/objects aren\u2019t supported. Provide your own `querySerializer()` to handle these.");
    return `${i}=${n ? e : encodeURIComponent(e)}`;
}, U = (n)=>{
    switch(n){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, $ = (n)=>{
    switch(n){
        case "form":
            return ",";
        case "pipeDelimited":
            return "|";
        case "spaceDelimited":
            return "%20";
        default:
            return ",";
    }
}, D = (n)=>{
    switch(n){
        case "label":
            return ".";
        case "matrix":
            return ";";
        case "simple":
            return ",";
        default:
            return "&";
    }
}, j = ({ allowReserved: n, explode: i, name: e, style: a, value: o })=>{
    if (!i) {
        let r = (n ? o : o.map((c)=>encodeURIComponent(c))).join($(a));
        switch(a){
            case "label":
                return `.${r}`;
            case "matrix":
                return `;${e}=${r}`;
            case "simple":
                return r;
            default:
                return `${e}=${r}`;
        }
    }
    let s = U(a), t = o.map((r)=>a === "label" || a === "simple" ? n ? r : encodeURIComponent(r) : h({
            allowReserved: n,
            name: e,
            value: r
        })).join(s);
    return a === "label" || a === "matrix" ? s + t : t;
}, C = ({ allowReserved: n, explode: i, name: e, style: a, value: o })=>{
    if (o instanceof Date) return `${e}=${o.toISOString()}`;
    if (a !== "deepObject" && !i) {
        let r = [];
        Object.entries(o).forEach(([u, l])=>{
            r = [
                ...r,
                u,
                n ? l : encodeURIComponent(l)
            ];
        });
        let c = r.join(",");
        switch(a){
            case "form":
                return `${e}=${c}`;
            case "label":
                return `.${c}`;
            case "matrix":
                return `;${e}=${c}`;
            default:
                return c;
        }
    }
    let s = D(a), t = Object.entries(o).map(([r, c])=>h({
            allowReserved: n,
            name: a === "deepObject" ? `${e}[${r}]` : r,
            value: c
        })).join(s);
    return a === "label" || a === "matrix" ? s + t : t;
}, _ = ({ path: n, url: i })=>{
    let e = i, a = i.match(T);
    if (a) for (let o of a){
        let s = !1, t = o.substring(1, o.length - 1), r = "simple";
        t.endsWith("*") && (s = !0, t = t.substring(0, t.length - 1)), t.startsWith(".") ? (t = t.substring(1), r = "label") : t.startsWith(";") && (t = t.substring(1), r = "matrix");
        let c = n[t];
        if (c == null) continue;
        if (Array.isArray(c)) {
            e = e.replace(o, j({
                explode: s,
                name: t,
                style: r,
                value: c
            }));
            continue;
        }
        if (typeof c == "object") {
            e = e.replace(o, C({
                explode: s,
                name: t,
                style: r,
                value: c
            }));
            continue;
        }
        if (r === "matrix") {
            e = e.replace(o, `;${h({
                name: t,
                value: c
            })}`);
            continue;
        }
        let u = encodeURIComponent(r === "label" ? `.${c}` : c);
        e = e.replace(o, u);
    }
    return e;
}, b = ({ allowReserved: n, array: i, object: e } = {})=>(o)=>{
        let s = [];
        if (o && typeof o == "object") for(let t in o){
            let r = o[t];
            if (r != null) {
                if (Array.isArray(r)) {
                    s = [
                        ...s,
                        j({
                            allowReserved: n,
                            explode: !0,
                            name: t,
                            style: "form",
                            value: r,
                            ...i
                        })
                    ];
                    continue;
                }
                if (typeof r == "object") {
                    s = [
                        ...s,
                        C({
                            allowReserved: n,
                            explode: !0,
                            name: t,
                            style: "deepObject",
                            value: r,
                            ...e
                        })
                    ];
                    continue;
                }
                s = [
                    ...s,
                    h({
                        allowReserved: n,
                        name: t,
                        value: r
                    })
                ];
            }
        }
        return s.join("&");
    }, A = (n)=>{
    if (n) {
        if (n.startsWith("application/json") || n.endsWith("+json")) return "json";
        if (n === "multipart/form-data") return "formData";
        if ([
            "application/",
            "audio/",
            "image/",
            "video/"
        ].some((i)=>n.startsWith(i))) return "blob";
        if (n.startsWith("text/")) return "text";
    }
}, w = ({ baseUrl: n, path: i, query: e, querySerializer: a, url: o })=>{
    let s = o.startsWith("/") ? o : `/${o}`, t = n + s;
    i && (t = _({
        path: i,
        url: t
    }));
    let r = e ? a(e) : "";
    return r.startsWith("?") && (r = r.substring(1)), r && (t += `?${r}`), t;
}, R = (n, i)=>{
    let e = {
        ...n,
        ...i
    };
    return e.baseUrl?.endsWith("/") && (e.baseUrl = e.baseUrl.substring(0, e.baseUrl.length - 1)), e.headers = O(n.headers, i.headers), e;
}, O = (...n)=>{
    let i = new Headers;
    for (let e of n){
        if (!e || typeof e != "object") continue;
        let a = e instanceof Headers ? e.entries() : Object.entries(e);
        for (let [o, s] of a)if (s === null) i.delete(o);
        else if (Array.isArray(s)) for (let t of s)i.append(o, t);
        else s !== void 0 && i.set(o, typeof s == "object" ? JSON.stringify(s) : s);
    }
    return i;
}, y = class {
    constructor(){
        this._fns = [];
    }
    clear() {
        this._fns = [];
    }
    exists(i) {
        return this._fns.indexOf(i) !== -1;
    }
    eject(i) {
        let e = this._fns.indexOf(i);
        e !== -1 && (this._fns = [
            ...this._fns.slice(0, e),
            ...this._fns.slice(e + 1)
        ]);
    }
    use(i) {
        this._fns = [
            ...this._fns,
            i
        ];
    }
}, P = ()=>({
        error: new y,
        request: new y,
        response: new y
    }), E = {
    bodySerializer: (n)=>JSON.stringify(n)
}, W = b({
    allowReserved: !1,
    array: {
        explode: !0,
        style: "form"
    },
    object: {
        explode: !0,
        style: "deepObject"
    }
}), B = {
    "Content-Type": "application/json"
}, x = (n = {})=>({
        ...E,
        baseUrl: "",
        fetch: globalThis.fetch,
        headers: B,
        parseAs: "auto",
        querySerializer: W,
        ...n
    });
var J = (n = {})=>{
    let i = R(x(), n), e = ()=>({
            ...i
        }), a = (t)=>(i = R(i, t), e()), o = P(), s = async (t)=>{
        let r = {
            ...i,
            ...t,
            headers: O(i.headers, t.headers)
        };
        r.body && r.bodySerializer && (r.body = r.bodySerializer(r.body)), r.body || r.headers.delete("Content-Type");
        let c = w({
            baseUrl: r.baseUrl ?? "",
            path: r.path,
            query: r.query,
            querySerializer: typeof r.querySerializer == "function" ? r.querySerializer : b(r.querySerializer),
            url: r.url
        }), u = {
            redirect: "follow",
            ...r
        }, l = new Request(c, u);
        for (let f of o.request._fns)l = await f(l, r);
        let I = r.fetch, p = await I(l);
        for (let f of o.response._fns)p = await f(p, l, r);
        let g = {
            request: l,
            response: p
        };
        if (p.ok) {
            if (p.status === 204 || p.headers.get("Content-Length") === "0") return {
                data: {},
                ...g
            };
            if (r.parseAs === "stream") return {
                data: p.body,
                ...g
            };
            let f = (r.parseAs === "auto" ? A(p.headers.get("Content-Type")) : r.parseAs) ?? "json", S = await p[f]();
            return f === "json" && r.responseTransformer && (S = await r.responseTransformer(S)), {
                data: S,
                ...g
            };
        }
        let m = await p.text();
        try {
            m = JSON.parse(m);
        } catch  {}
        let d = m;
        for (let f of o.error._fns)d = await f(m, p, l, r);
        if (d = d || {}, r.throwOnError) throw d;
        return {
            error: d,
            ...g
        };
    };
    return {
        connect: (t)=>s({
                ...t,
                method: "CONNECT"
            }),
        delete: (t)=>s({
                ...t,
                method: "DELETE"
            }),
        get: (t)=>s({
                ...t,
                method: "GET"
            }),
        getConfig: e,
        head: (t)=>s({
                ...t,
                method: "HEAD"
            }),
        interceptors: o,
        options: (t)=>s({
                ...t,
                method: "OPTIONS"
            }),
        patch: (t)=>s({
                ...t,
                method: "PATCH"
            }),
        post: (t)=>s({
                ...t,
                method: "POST"
            }),
        put: (t)=>s({
                ...t,
                method: "PUT"
            }),
        request: s,
        setConfig: a,
        trace: (t)=>s({
                ...t,
                method: "TRACE"
            })
    };
};

async function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}

// Do not modify this variable or cause type errors
// eslint-disable-next-line no-var
var process;
/**
 * Represents a reader for parsing files using the LlamaParse API.
 * See https://github.com/run-llama/llama_parse
 */ class LlamaParseReader extends FileReader {
    #client;
    constructor(params = {}){
        super(), // The base URL of the Llama Cloud Platform.
        this.baseUrl = "https://api.cloud.llamaindex.ai", // The result type for the parser.
        this.resultType = "text", // The interval in seconds to check if the parsing is done.
        this.checkInterval = 1, // The maximum timeout in seconds to wait for the parsing to finish.
        this.maxTimeout = 2000, // Whether to print the progress of the parsing.
        this.verbose = true, // The language of the text to parse.
        this.language = [
            "en"
        ], // Deprecated. Use vendorMultimodal params. Whether to use gpt-4o to extract text from documents.
        this.gpt4oMode = false, // Whether or not to ignore and skip errors raised during parsing.
        this.ignoreErrors = true, // Whether to split by page using the pageSeparator or '\n---\n' as default.
        this.splitByPage = true, // Whether to use the vendor multimodal API.
        this.useVendorMultimodalModel = false;
        Object.assign(this, params);
        this.language = Array.isArray(this.language) ? this.language : [
            this.language
        ];
        this.stdout = params.stdout ?? typeof process !== "undefined" ? process.stdout : undefined;
        const apiKey = params.apiKey ?? getEnv("LLAMA_CLOUD_API_KEY");
        if (!apiKey) {
            throw new Error("API Key is required for LlamaParseReader. Please pass the apiKey parameter or set the LLAMA_CLOUD_API_KEY environment variable.");
        }
        this.apiKey = apiKey;
        if (this.baseUrl.endsWith("/")) {
            this.baseUrl = this.baseUrl.slice(0, -"/".length);
        }
        if (this.baseUrl.endsWith("/api/parsing")) {
            this.baseUrl = this.baseUrl.slice(0, -"/api/parsing".length);
        }
        if (params.gpt4oMode) {
            params.gpt4oApiKey = params.gpt4oApiKey ?? getEnv("LLAMA_CLOUD_GPT4O_API_KEY");
            this.gpt4oApiKey = params.gpt4oApiKey;
        }
        if (params.useVendorMultimodalModel) {
            params.vendorMultimodalApiKey = params.vendorMultimodalApiKey ?? getEnv("LLAMA_CLOUD_VENDOR_MULTIMODAL_API_KEY");
            this.vendorMultimodalApiKey = params.vendorMultimodalApiKey;
        }
        this.#client = J(x({
            headers: {
                Authorization: `Bearer ${this.apiKey}`
            },
            baseUrl: this.baseUrl
        }));
    }
    // Create a job for the LlamaParse API
    async #createJob(data, filename) {
        if (this.verbose) {
            console.log("Started uploading the file");
        }
        // todo: remove Blob usage when we drop Node.js 18 support
        const file = globalThis.File && filename ? new File([
            data
        ], filename) : new Blob([
            data
        ]);
        const body = {
            file,
            language: this.language,
            parsing_instruction: this.parsingInstruction,
            skip_diagonal_text: this.skipDiagonalText,
            invalidate_cache: this.invalidateCache,
            do_not_cache: this.doNotCache,
            fast_mode: this.fastMode,
            do_not_unroll_columns: this.doNotUnrollColumns,
            page_separator: this.pageSeparator,
            page_prefix: this.pagePrefix,
            page_suffix: this.pageSuffix,
            gpt4o_mode: this.gpt4oMode,
            gpt4o_api_key: this.gpt4oApiKey,
            bounding_box: this.boundingBox,
            target_pages: this.targetPages,
            use_vendor_multimodal_model: this.useVendorMultimodalModel,
            vendor_multimodal_model_name: this.vendorMultimodalModelName,
            vendor_multimodal_api_key: this.vendorMultimodalApiKey,
            premium_mode: this.premiumMode,
            webhook_url: this.webhookUrl,
            take_screenshot: this.takeScreenshot,
            disable_ocr: this.disableOcr,
            disable_reconstruction: this.disableReconstruction,
            input_s3_path: this.inputS3Path,
            output_s3_path_prefix: this.outputS3PathPrefix,
            continuous_mode: this.continuousMode,
            is_formatting_instruction: this.isFormattingInstruction,
            annotate_links: this.annotateLinks,
            azure_openai_deployment_name: this.azureOpenaiDeploymentName,
            azure_openai_endpoint: this.azureOpenaiEndpoint,
            azure_openai_api_version: this.azureOpenaiApiVersion,
            azure_openai_key: this.azureOpenaiKey
        };
        const response = await ParsingService.uploadFileApiV1ParsingUploadPost({
            client: this.#client,
            throwOnError: true,
            signal: AbortSignal.timeout(this.maxTimeout * 1000),
            body
        });
        return response.data.id;
    }
    // Get the result of the job
    async getJobResult(jobId, resultType) {
        const signal = AbortSignal.timeout(this.maxTimeout * 1000);
        let tries = 0;
        while(true){
            await sleep(this.checkInterval * 1000);
            // Check the job status. If unsuccessful response, checks if maximum timeout has been reached. If reached, throws an error
            const result = await ParsingService.getJobApiV1ParsingJobJobIdGet({
                client: this.#client,
                throwOnError: true,
                path: {
                    job_id: jobId
                },
                signal
            });
            const { data } = result;
            const status = data["status"];
            // If job has completed, return the result
            if (status === "SUCCESS") {
                let result;
                switch(resultType){
                    case "json":
                        {
                            result = await ParsingService.getJobJsonResultApiV1ParsingJobJobIdResultJsonGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                signal
                            });
                            break;
                        }
                    case "markdown":
                        {
                            result = await ParsingService.getJobResultApiV1ParsingJobJobIdResultMarkdownGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                signal
                            });
                            break;
                        }
                    case "text":
                        {
                            result = await ParsingService.getJobTextResultApiV1ParsingJobJobIdResultTextGet({
                                client: this.#client,
                                throwOnError: true,
                                path: {
                                    job_id: jobId
                                },
                                signal
                            });
                            break;
                        }
                }
                return result.data;
            // If job is still pending, check if maximum timeout has been reached. If reached, throws an error
            } else if (status === "PENDING") {
                signal.throwIfAborted();
                if (this.verbose && tries % 10 === 0) {
                    this.stdout?.write(".");
                }
                tries++;
            } else {
                if (this.verbose) {
                    console.error(`Recieved Error response ${status} for job ${jobId}.  Got Error Code: ${data.error_code} and Error Message: ${data.error_message}`);
                }
                throw new Error(`Failed to parse the file: ${jobId}, status: ${status}`);
            }
        }
    }
    /**
   * Loads data from a file and returns an array of Document objects.
   * To be used with resultType = "text" and "markdown"
   *
   * @param {Uint8Array} fileContent - The content of the file to be loaded.
   * @param {string} filename - The name of the file to be loaded.
   * @return {Promise<Document[]>} A Promise object that resolves to an array of Document objects.
   */ async loadDataAsContent(fileContent, filename) {
        return this.#createJob(fileContent, filename).then(async (jobId)=>{
            if (this.verbose) {
                console.log(`Started parsing the file under job id ${jobId}`);
            }
            // Return results as Document objects
            const jobResults = await this.getJobResult(jobId, this.resultType);
            const resultText = jobResults[this.resultType];
            // Split the text by separator if splitByPage is true
            if (this.splitByPage) {
                return this.splitTextBySeparator(resultText);
            }
            return [
                new Document({
                    text: resultText
                })
            ];
        }).catch((error)=>{
            if (this.ignoreErrors) {
                console.warn(`Error while parsing the file: ${error.message ?? error.detail}`);
                return [];
            } else {
                throw error;
            }
        });
    }
    /**
   * Loads data from a file and returns an array of JSON objects.
   * To be used with resultType = "json"
   *
   * @param {string} filePathOrContent - The file path to the file or the content of the file as a Buffer
   * @return {Promise<Record<string, any>[]>} A Promise that resolves to an array of JSON objects.
   */ async loadJson(filePathOrContent) {
        let jobId;
        const isFilePath = typeof filePathOrContent === "string";
        try {
            const data = isFilePath ? await fs.readFile(filePathOrContent) : filePathOrContent;
            // Creates a job for the file
            jobId = await this.#createJob(data, isFilePath ? path.basename(filePathOrContent) : undefined);
            if (this.verbose) {
                console.log(`Started parsing the file under job id ${jobId}`);
            }
            // Return results as an array of JSON objects (same format as Python version of the reader)
            const resultJson = await this.getJobResult(jobId, "json");
            resultJson.job_id = jobId;
            resultJson.file_path = isFilePath ? filePathOrContent : undefined;
            return [
                resultJson
            ];
        } catch (e) {
            if (this.ignoreErrors) {
                console.error(`Error while parsing the file under job id ${jobId}`, e);
                return [];
            } else {
                throw e;
            }
        }
    }
    /**
   * Downloads and saves images from a given JSON result to a specified download path.
   * Currently only supports resultType = "json"
   *
   * @param {Record<string, any>[]} jsonResult - The JSON result containing image information.
   * @param {string} downloadPath - The path to save the downloaded images.
   * @return {Promise<Record<string, any>[]>} A Promise that resolves to an array of image objects.
   */ async getImages(jsonResult, downloadPath) {
        try {
            // Create download directory if it doesn't exist (Actually check for write access, not existence, since fsPromises does not have a `existsSync` method)
            try {
                await fs.access(downloadPath);
            } catch  {
                await fs.mkdir(downloadPath, {
                    recursive: true
                });
            }
            const images = [];
            for (const result of jsonResult){
                const jobId = result.job_id;
                for (const page of result.pages){
                    if (this.verbose) {
                        console.log(`> Image for page ${page.page}: ${page.images}`);
                    }
                    for (const image of page.images){
                        const imageName = image.name;
                        const imagePath = await this.getImagePath(downloadPath, jobId, imageName);
                        await this.fetchAndSaveImage(imageName, imagePath, jobId);
                        // Assign metadata to the image
                        image.path = imagePath;
                        image.job_id = jobId;
                        image.original_pdf_path = result.file_path;
                        image.page_number = page.page;
                        images.push(image);
                    }
                }
            }
            return images;
        } catch (e) {
            console.error(`Error while downloading images from the parsed result`, e);
            if (this.ignoreErrors) {
                return [];
            } else {
                throw e;
            }
        }
    }
    async getImagePath(downloadPath, jobId, imageName) {
        return path.join(downloadPath, `${jobId}-${imageName}`);
    }
    async fetchAndSaveImage(imageName, imagePath, jobId) {
        const response = await ParsingService.getJobImageResultApiV1ParsingJobJobIdResultImageNameGet({
            client: this.#client,
            path: {
                job_id: jobId,
                name: imageName
            }
        });
        if (response.error) {
            throw new Error(`Failed to download image: ${response.error.detail}`);
        }
        const blob = await response.data;
        // Write the image buffer to the specified imagePath
        await fs.writeFile(imagePath, new Uint8Array(await blob.arrayBuffer()));
    }
    // Filters out invalid values (null, undefined, empty string) of specific params.
    filterSpecificParams(params, keysToCheck) {
        const filteredParams = {};
        for (const [key, value] of Object.entries(params)){
            if (keysToCheck.includes(key)) {
                if (value !== null && value !== undefined && value !== "") {
                    filteredParams[key] = value;
                }
            } else {
                filteredParams[key] = value;
            }
        }
        return filteredParams;
    }
    splitTextBySeparator(text) {
        const separator = this.pageSeparator ?? "\n---\n";
        const textChunks = text.split(separator);
        return textChunks.map((docChunk)=>new Document({
                text: docChunk
            }));
    }
}

export { LlamaParseReader };
