import { FileReader, Document } from '@llamaindex/core/schema';
import { ParserLanguages } from '../../api/dist/index.js';

type Language = ParserLanguages;
type ResultType = "text" | "markdown" | "json";
type WriteStream = {
    write: (text: string) => void;
};
/**
 * Represents a reader for parsing files using the LlamaParse API.
 * See https://github.com/run-llama/llama_parse
 */
declare class LlamaParseReader extends FileReader {
    #private;
    apiKey: string;
    baseUrl: string;
    resultType: ResultType;
    checkInterval: number;
    maxTimeout: number;
    verbose: boolean;
    language: ParserLanguages[];
    parsingInstruction?: string | undefined;
    skipDiagonalText?: boolean | undefined;
    invalidateCache?: boolean | undefined;
    doNotCache?: boolean | undefined;
    fastMode?: boolean | undefined;
    doNotUnrollColumns?: boolean | undefined;
    pageSeparator?: string | undefined;
    pagePrefix?: string | undefined;
    pageSuffix?: string | undefined;
    gpt4oMode: boolean;
    gpt4oApiKey?: string | undefined;
    boundingBox?: string | undefined;
    targetPages?: string | undefined;
    ignoreErrors: boolean;
    splitByPage: boolean;
    useVendorMultimodalModel: boolean;
    vendorMultimodalModelName?: string | undefined;
    vendorMultimodalApiKey?: string | undefined;
    webhookUrl?: string | undefined;
    premiumMode?: boolean | undefined;
    takeScreenshot?: boolean | undefined;
    disableOcr?: boolean | undefined;
    disableReconstruction?: boolean | undefined;
    inputS3Path?: string | undefined;
    outputS3PathPrefix?: string | undefined;
    continuousMode?: boolean | undefined;
    isFormattingInstruction?: boolean | undefined;
    annotateLinks?: boolean | undefined;
    azureOpenaiDeploymentName?: string | undefined;
    azureOpenaiEndpoint?: string | undefined;
    azureOpenaiApiVersion?: string | undefined;
    azureOpenaiKey?: string | undefined;
    stdout?: WriteStream | undefined;
    constructor(params?: Partial<Omit<LlamaParseReader, "language" | "apiKey">> & {
        language?: ParserLanguages | ParserLanguages[] | undefined;
        apiKey?: string | undefined;
    });
    private getJobResult;
    /**
     * Loads data from a file and returns an array of Document objects.
     * To be used with resultType = "text" and "markdown"
     *
     * @param {Uint8Array} fileContent - The content of the file to be loaded.
     * @param {string} filename - The name of the file to be loaded.
     * @return {Promise<Document[]>} A Promise object that resolves to an array of Document objects.
     */
    loadDataAsContent(fileContent: Uint8Array, filename?: string): Promise<Document[]>;
    /**
     * Loads data from a file and returns an array of JSON objects.
     * To be used with resultType = "json"
     *
     * @param {string} filePathOrContent - The file path to the file or the content of the file as a Buffer
     * @return {Promise<Record<string, any>[]>} A Promise that resolves to an array of JSON objects.
     */
    loadJson(filePathOrContent: string | Uint8Array): Promise<Record<string, any>[]>;
    /**
     * Downloads and saves images from a given JSON result to a specified download path.
     * Currently only supports resultType = "json"
     *
     * @param {Record<string, any>[]} jsonResult - The JSON result containing image information.
     * @param {string} downloadPath - The path to save the downloaded images.
     * @return {Promise<Record<string, any>[]>} A Promise that resolves to an array of image objects.
     */
    getImages(jsonResult: Record<string, any>[], downloadPath: string): Promise<Record<string, any>[]>;
    private getImagePath;
    private fetchAndSaveImage;
    private filterSpecificParams;
    private splitTextBySeparator;
}

export { type Language, LlamaParseReader, type ResultType };
